---
layout: post
title: "每日心得-机器学习之路"
date: 2019-09-19
tag: 日志
---









**深度学习/机器学习算法** 

**职位描述**

```
1. 多年计算机互联网行业从业经验
2. 熟悉Opencv等图像算法基本库，了解人脸识别、检测、对比、跟踪、三维重建等算法
3. 熟悉caffe、Tensorflow等深度学习框架
4. 熟悉卷积神经网、循环神经网等深度学习理论和相关网络结构、了解模型优化、模型压缩相关方法
5. 掌握Python，同时熟练运用C++、Java者优先
```

```
1 数学基础扎实
2 熟练掌握数据挖掘，机器学习等常用算法
3 熟练掌握Python，pandas等数据处理工具，对数据库有了解，
4 有金融工程背景 以及 相关金融从业资格证书优先考虑
5 性格开朗，有良好的沟通协调能力
```

```
	熟悉Python语言, 能够根据需要引入Python开源库和第三方软件包，结合业务展开二次开发
	掌握Numpy,Pandas,Scipy等相关数据分析类库, Matplotlib,PyEcharts等相关可视化库。
	熟悉使用MySQL和Redis等数据库的操作
	熟练使用SQL语句，熟悉EXCEL函数及数据透视表；
	熟悉Scrapy爬虫框架, 了解PhantomJS、Selenium、WebDriver爬虫相关技术
	了解Python的多进程、多线程
	了解JS, CSS, HTML, JQuery, JSON, AJAX等Web前端技术
	掌握Git分布式版本控制系统
```

**工作范围**

```
1 金融建模
2 策略实现，部署，数据清洗等辅助性工作
```









## 方向

**量化及数据分析**

上海风述信息科技有限公司，是一家专注于大数据分析的系统服务商

量化先行，基于对行业数据的分析、产业的研究，以及对公司商业模式、管理文化、产品服务的理解，所进行估值后的投资。



**密度聚类（DBSCAN）**

基于密度的聚类算法

已有的经典聚类算法通常考虑一种数据密度的情景,例如在基于密度的聚类算法(DBSCAN)[1]中,隐含假定数据的簇密度是一致的.

算法有一个弱点，即更倾向于发现凸形的分类，该缺陷在某些情况下会将实际同属一类的样本误拆为不同的类别；而密度聚类（DBSCAN）在距离聚类的基础上进行了优化，大大提高了聚类结果的合理性。



**PyEcharts 等相关可视化库**

```
author = 'damao'

from pyecharts import Bar,Pie,Scatter,Gauge,HeatMap,Funnel,WordCloud,Line,Grid,Map,Liquid
import random

"""柱状图"""
skill = ['Q','W','E','R']
var1 = [110,60,5,200]
var2 = [90,100,300,500]
bar = Bar("英雄联盟","League of Legends")
bar.add("无极剑圣",skill,var1,s_more_utils=True)
bar.add("诡术妖姬",skill,var2,is_more_utils=True)
bar.show_config()
bar.render(r".\my_first_Bar.html")

"""饼图"""
attr = ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","鞋子"]
v1 = [11,12,13,10,10,10]
pie = Pie("各产品销售情况")
pie.add("",attr,v1,is_label_show=True)
pie.render(r".\my_first_Pie.html")

"""环形图"""
attr = ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","鞋子"]
v1 = [11,12,13,10,10,10]
pie = Pie("饼图—圆环图示例",title_pos="center")
pie.add("",attr,v1,radius=[40,75],label_text_color=None,
       is_label_show=True,legend_orient="vertical",
       legend_pos="left")
pie.render(r".\my_first_Huanxing.html")

"""散点图"""
v1=[10,20,30,40,50,60]
v2=[10,20,30,40,50,60]
scatter=Scatter("散点图示例")
scatter.add("A",v1,v2)
scatter.add("B",v1[::-1],v2)
scatter.render(r".\my_first_Sandian.html")

"""仪表盘"""
gauge=Gauge("业务指标完成率—仪表盘")
gauge.add("业务指标","完成率",66.66)
gauge.render(r".\my_first_Yibiaopan.html")

"""热力图"""
x_axis=[
    "12a","1a","2a","3a","4a","5a","6a","7a","8a","9a","10a","11a",
    "12p","1p","2p","3p","4p","5p","6p","7p","8p","9p","10p","11p",]
y_axis=[
    "Saturday","Friday","Thursday","Wednesday","Tuesday","Monday","Sunday"]
data=[[i,j,random.randint(0,50)] for i in range(24) for j in range(7)]
heatmap=HeatMap()
heatmap.add("热力图直角坐标系",x_axis,y_axis,data,is_visualmap=True,
           visual_text_color="#000",visual_orient="horizontal")
heatmap.render(r".\my_first_Hotmap.html")

"""漏斗图"""
attr=["潜在","接触","意向","明确","投入","谈判","成交"]
value=[140,120,100,80,60,40,20]
funnel=Funnel("销售管理分析漏斗图")
funnel.add("商品",attr,value,is_label_show=True,
          label_pos="inside",label_text_color="#fff")
funnel.render(r".\my_first_Loudou.html")

"""词云图"""
name=[
    "Sam s  Club","Macys","Amy Schumer","Jurassic World","Charter Communications",
    "Chick Fil A","Planet Fitness","Pitch Perfect","Express","Home","Johnny Depp",
    "Lena Dunham","Lewis Hamilton","KXAN","Mary Ellen Mark","Farrah Abraham",
    "Rita Ora","Serena Williams","NCAA baseball tournament","Point Break"
]
value=[
    10000,6181,4386,4055,2467,2244,1898,1484,1112,
    965,847,582,555,550,462,366,360,282,273,265]
wordcloud=WordCloud(width=1300,height=620)
wordcloud.add("",name,value,word_size_range=[20,100])
wordcloud.render(r".\my_first_Ciyun.html")

"""组合图"""
line=Line("折线图",width=1200)
attr=["周一","周二","周三","周四","周五","周六","周日"]
line.add("最高气温",attr,[11,11,15,13,12,13,10],
        mark_point=["max","min"],mark_line=["average"])
line.add("最低气温",attr,[1,-2,2,5,3,2,0],
        mark_point=["max","min"],mark_line=["average"],
        legend_pos="20%")
attr=["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
v1=[11,12,13,10,10,10]
pie=Pie("饼图",title_pos="55%")
pie.add("",attr,v1,radius=[45,65],center=[65,50],
       legend_pos="80%",legend_orient="vertical")
grid=Grid()
grid.add(line,grid_right="55%")
grid.add(pie,grid_left="60%")
grid.render(r".\my_first_Zuhetu.html")

"""水球图"""
liquid = Liquid("水球图示例")
liquid.add("Liquid", [0.8])
liquid.show_config()
liquid.render(r".\my_first_Shuiqiu1.html")

liquid = Liquid("水球图示例")
liquid.add("Liquid", [0.6, 0.5, 0.4, 0.3], is_liquid_animation=False, shape='diamond')
liquid.show_config()
liquid.render(r".\my_first_Shuiqiu2.html")

"""地图"""
value = [155, 10, 66, 78, 33, 80, 190, 53, 49.6]
attr = ["福建", "山东", "北京", "上海", "甘肃", "新疆", "河南", "广西", "西藏"]
map = Map("Map 结合 VisualMap 示例", width=1200, height=600)
map.add("", attr, value, maptype='china', is_visualmap=True, visual_text_color='#000')
map.show_config()
map.render(r".\my_first_Ditu.html")
```



```
厦门骐俊物联科技股份有限公司（简称：骐俊物联）是专注于物联网无线通信技术（2G/3G/4G/5G/NB-IoT/eMTC/LoRa/Wi-Fi/BT等）、物联网定位技术（GPS/BDS/LBS等）研发和应用的专业物联网技术方案提供商。公司拥有多项自主知识产权及核心技术，针对客户需求自主设计、研发的无线通信和定位系列模组及相关软件技术，已广泛应用于智能家居、车联网、智能表计、移动支付、公网对讲、智慧市政等丰富的物联网细分领域，产品及服务的多样性和可靠性能充分满足不同市场的需求。

骐俊物联于2018年4月成立生产制造中心，专注于物联网无线通信模组产品的SMT表面贴装制造及后道测试生产。骐俊物联生产制造中心高速SMT产线选用FUJI NXTIII系列贴片机，单线体配置为: 6*M3III+1*M6III，单线体CPH可高达230,000点；高速SMT贴片机贴装精度高达±0.025mm，模组化的设计理念使其具备更优的兼容性和拓展性，可通过更换工作头及更改模组组合来完美适应不同类型的产品。骐俊物联秉承“全员参与，精细研制；持续改进，客户满意”的十六字质量方针，本着“细心、精心、用心，品质永远称心”的质量目标，持续为客户提供合格的产品和满意的服务。

       未来，骐俊物联将始终贯彻“无线创造价值，物联改变生活”的理念，持续深耕物联网核心技术，助力成就物联网未来世界。
```



## 了解

**ROC曲线与AUC属于同一指标**

roc曲线（）	相同 的时候看 准招，不同的场景，看不同的指标。项目经验 		；

```
receiver operating characteristic  受试者工作特征
ROC的全名叫做Receiver Operating Characteristic，其主要分析工具是一个画在二维平面上的曲线——ROC curve。平面的横坐标是false positive rate(FPR)，纵坐标是true positive rate(TPR)。对某个分类器而言，我们可以根据其在测试样本上的表现得到一个TPR和FPR点对。这样，此分类器就可以映射成ROC平面上的一个点。调整这个分类器分类时候使用的阈值，我们就可以得到一个经过(0, 0)，(1, 1)的曲线，这就是此分类器的ROC曲线。
```

auc是面积，是值  ，二分类，正负样本，看比例差 比较大 0.9  ；评估

```
样本的比例，值，不同下的召回率；精确率-召回率曲线 Precision-Recall Curve
AUC（Area Under roc Curve）是一种用来度量分类模型好坏的一个标准。
准确率  accuracy rate    precision  precision rate
精确率  precision ratio
```



**特征工程**

```
特征值
n条隐藏的知识；
在哪儿用到 numpy ，哪儿用到pandas
```







**python算法 指的是		机器学习算法；**

```
常用机器学习算法： 	原理 场景 优缺点（网上）； 对比（李航）

									算法：	难点； 痛点；业务了解

自己定位要到位：			初级数据分析师；要去模仿，少去创造
```



**大数据：Hadoop**

```
分为：分布式计算（map reduce） 、分布式存储（H）
成长经历：
项目：做了几个场景，分为 1个；2个
负责模块： 做这个给谁用
技术进行描述：

类比：
spark								大数据（应用）
深度学习（技术：参差网络）   知识图谱（应用） 
```





**单词**

```
虚拟机：
桥接： 广播功能，ip就是本机的ip
Nat： 本机可以，默认

打字速度：
英文：70 
中文：120-》100
jupyter Notebook

字节跳动：
cclear v5.57

stack栈

冒泡排序：
1576329 原始数据
156327 9最后找到9
```











## 机器学习算法

**算法选择参考**

````
看过国外的文章，有一篇文章中给出了一个简单的算法选择技巧：
首当其冲应该选择的就是逻辑回归，如果它的效果不怎么样，那么可以将它的结果作为基准来参考，在基础上与其他算法进行比较；
然后试试决策树（随机森林）看看是否可以大幅度提升你的模型性能。即便最后你并没有把它当做为最终模型，你也可以使用随机森林来移除噪声变量，做特征选择；
如果特征的数量和观测样本特别多，那么当资源和时间充足时（这个前提很重要），使用SVM不失为一种选择。
通常情况下：【XGBOOST>=GBDT>=SVM>=RF>=Adaboost>=Other…】，现在深度学习很热门，很多领域都用到，它是以神经网络为基础的。
算法固然重要，但好的数据却要优于好的算法，设计优良特征是大有裨益的。假如你有一个超大数据集，那么无论你使用哪种算法可能对分类性能都没太大影响（此时就可以根据速度和易用性来进行抉择）。
````





```
常见算法优缺点

1.朴素贝叶斯

朴素贝叶斯属于生成式模型（关于生成模型和判别式模型，主要还是在于是否是要求联合分布），非常简单，你只是做了一堆计数。如果注有条件独立性假设（一个比较严格的条件），朴素贝叶斯分类器的收敛速度将快于判别模型，如逻辑回归，所以你只需要较少的训练数据即可。即使NB条件独立假设不成立，NB分类器在实践中仍然表现的很出色。它的主要缺点是它不能学习特征间的相互作用，用mRMR中R来讲，就是特征冗余。引用一个比较经典的例子，比如，虽然你喜欢Brad Pitt和Tom Cruise的电影，但是它不能学习出你不喜欢他们在一起演的电影。



优点：

朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。

对小规模的数据表现很好，能个处理多分类任务，适合增量式训练；

对缺失数据不太敏感，算法也比较简单，常用于文本分类。



缺点：

需要计算先验概率；

分类决策存在错误率；

对输入数据的表达形式很敏感。



2.Logistic Regression（逻辑回归）

属于判别式模型，有很多正则化模型的方法（L0， L1，L2，etc），而且你不必像在用朴素贝叶斯那样担心你的特征是否相关。与决策树与SVM机相比，你还会得到一个不错的概率解释，你甚至可以轻松地利用新数据来更新模型（使用在线梯度下降算法，online gradient descent）。如果你需要一个概率架构（比如，简单地调节分类阈值，指明不确定性，或者是要获得置信区间），或者你希望以后将更多的训练数据快速整合到模型中去，那么使用它吧。



Sigmoid函数：

g(x)=1/(1+exp(-x))

优点： 

实现简单，广泛的应用于工业问题上；

分类时计算量非常小，速度很快，存储资源低；

便利的观测样本概率分数；

对逻辑回归而言，多重共线性并不是问题，它可以结合L2正则化来解决该问题；



缺点：

当特征空间很大时，逻辑回归的性能不是很好；

容易欠拟合，一般准确度不太高

不能很好地处理大量多类特征或变量；

只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须线性可分；

对于非线性特征，需要进行转换；



3.线性回归

线性回归是用于回归的，而不像Logistic回归是用于分类，其基本思想是用梯度下降法对最小二乘法形式的误差函数进行优化，当然也可以用normal equation直接求得参数的解，结果为：



而在LWLR（局部加权线性回归）中，参数的计算表达式为:



由此可见LWLR与LR不同，LWLR是一个非参数模型，因为每次进行回归计算都要遍历训练样本至少一次。



优点： 实现简单，计算简单；

缺点： 不能拟合非线性数据.



4.最近邻算法——KNN

KNN即最近邻算法，其主要过程为：

1. 计算训练样本和测试样本中每个样本点的距离（常见的距离度量有欧式距离，马氏距离等）； 2. 对上面所有的距离值进行排序； 3. 选前k个最小距离的样本； 4. 根据这k个样本的标签进行投票，得到最后的分类类别； 



如何选择一个最佳的K值，这取决于数据。一般情况下，在分类时较大的K值能够减小噪声的影响。但会使类别之间的界限变得模糊。一个较好的K值可通过各种启发式技术来获取，比如，交叉验证。另外噪声和非相关性特征向量的存在会使K近邻算法的准确性减小。



近邻算法具有较强的一致性结果。随着数据趋于无限，算法保证错误率不会超过贝叶斯算法错误率的两倍。对于一些好的K值，K近邻保证错误率不会超过贝叶斯理论误差率。



KNN算法的优点

理论成熟，思想简单，既可以用来做分类也可以用来做回归；
可用于非线性分类；
训练时间复杂度为O(n)；
对数据没有假设，准确度高，对outlier不敏感；



缺点
计算量大；
样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）；
需要大量的内存；



5.决策树
易于解释。它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分（举个例子，决策树能轻松处理好类别A在某个特征维度x的末端，类别B在中间，然后类别A又出现在特征维度x前端的情况）。它的缺点之一就是不支持在线学习，于是在新样本到来后，决策树需要全部重建。另一个缺点就是容易出现过拟合，但这也就是诸如随机森林RF（或提升树boosted tree）之类的集成方法的切入点。另外，随机森林经常是很多分类问题的赢家（通常比支持向量机好上那么一丁点），它训练快速并且可调，同时你无须担心要像支持向量机那样调一大堆参数，所以在以前都一直很受欢迎。

决策树中很重要的一点就是选择一个属性进行分枝，因此要注意一下信息增益的计算公式，并深入理解它。
信息熵的计算公式中；
n代表有n个分类类别（比如假设是2类问题，那么n=2）。分别计算这2类样本在总样本中出现的概率p1和p2，这样就可以计算出未选中属性分枝前的信息熵。
现在选中一个属性$x_i$用来进行分枝，此时分枝规则是：如果$x_i=v$的话，将样本分到树的一个分支；如果不相等则进入另一个分支。很显然，分支中的样本很有可能包括2个类别，分别计算这2个分支的熵H1和H2,计算出分枝后的总信息熵H’ =p1  H1+p2  H2,则此时的信息增益ΔH = H - H’。以信息增益为原则，把所有的属性都测试一边，选择一个使增益最大的属性作为本次分枝属性。


决策树自身的优点
计算简单，易于理解，可解释性强；
比较适合处理有缺失属性的样本；
能够处理不相关的特征；
在相对短的时间内能够对大型数据源做出可行且效果良好的结果。

缺点
容易发生过拟合（随机森林可以很大程度上减少过拟合）；
忽略了数据之间的相关性；
对于那些各类别样本数量不一致的数据，在决策树当中,信息增益的结果偏向于那些具有更多数值的特征（只要是使用了信息增益，都有这个缺点，如RF）。



5.1 Adaboosting
AdaBoost算法(通过迭代弱分类器而产生最终的强分类器的算法)
Adaboost是一种加和模型，每个模型都是基于上一次模型的错误率来建立的，过分关注分错的样本，而对正确分类的样本减少关注度，逐次迭代之后，可以得到一个相对较好的模型。是一种典型的boosting算法。下面是总结下它的优缺点。
优点
adaboost是一种有很高精度的分类器。
可以使用各种方法构建子分类器，Adaboost算法提供的是框架。
当使用简单分类器时，计算出的结果是可以理解的，并且弱分类器的构造极其简单。
简单，不用做特征筛选。
不容易发生overfitting。
关于随机森林和GBDT等组合算法，参考这篇文章：机器学习-组合算法总结

缺点：对outlier比较敏感

5.2 xgboost
这是一个近年来出现在各大比赛的大杀器，夺冠选手很大部分都使用了它。
高准确率高效率高并发，支持自定义损失函数，既可以用来分类又可以用来回归
可以像随机森林一样输出特征重要性，因为速度快，适合作为高维特征选择的一大利器
在目标函数中加入正则项，控制了模型的复杂程度，可以避免过拟合
支持列抽样，也就是随机选择特征，增强了模型的稳定性
对缺失值不敏感，可以学习到包含缺失值的特征的分裂方向
另外一个广受欢迎的原因是支持并行，速度杠杠的
用的好，你会发现他的全部都是优点



6.SVM支持向量机
高准确率，为避免过拟合提供了很好的理论保证，而且就算数据在原特征空间线性不可分，只要给个合适的核函数，它就能运行得很好。在动辄超高维的文本分类问题中特别受欢迎。可惜内存消耗大，难以解释，运行和调参也有些烦人，而随机森林却刚好避开了这些缺点，比较实用。
优点
可以解决高维问题，即大型特征空间；
能够处理非线性特征的相互作用；
无需依赖整个数据；
可以提高泛化能力；
需要对数据提前归一化，很多人使用的时候忽略了这一点，毕竟是基于距离的模型，所以LR也需要归一化

缺点
当观测样本很多时，效率并不是很高；
一个可行的解决办法是模仿随机森林，对数据分解，训练多个模型，然后求平均，时间复杂度降低p倍，分多少份，降多少倍
对非线性问题没有通用解决方案，有时候很难找到一个合适的核函数；
对缺失数据敏感；
对于核的选择也是有技巧的（libsvm中自带了四种核函数：线性核、多项式核、RBF以及sigmoid核）：
第一，如果样本数量小于特征数，那么就没必要选择非线性核，简单的使用线性核就可以了；
第二，如果样本数量大于特征数目，这时可以使用非线性核，将样本映射到更高维度，一般可以得到更好的结果；
第三，如果样本数目和特征数目相等，该情况可以使用非线性核，原理和第二种一样。
对于第一种情况，也可以先对数据进行降维，然后使用非线性核，这也是一种方法。



7. 人工神经网络的优缺点
人工神经网络的优点：
分类的准确度高；
并行分布处理能力强,分布存储及学习能力强，
对噪声神经有较强的鲁棒性和容错能力，能充分逼近复杂的非线性关系；
具备联想记忆的功能。

人工神经网络的缺点：
神经网络需要大量的参数，如网络拓扑结构、权值和阈值的初始值；
不能观察之间的学习过程，输出结果难以解释，会影响到结果的可信度和可接受程度；
学习时间过长,甚至可能达不到学习的目的。



8、K-Means聚类
关于K-Means聚类的文章，链接：机器学习算法-K-means聚类。关于K-Means的推导，里面有着很强大的EM思想。
优点
算法简单，容易实现 ；
对处理大数据集，该算法是相对可伸缩的和高效率的，因为它的复杂度大约是O(nkt)，
其中n是所有对象的数目，k是簇的数目,t是迭代的次数。通常k<<n。这个算法通常局部收敛。
算法尝试找出使平方误差函数值最小的k个划分。当簇是密集的、球状或团状的，且簇与簇之间区别明显时，聚类效果较好。

缺点
对数据类型要求较高，适合数值型数据；
可能收敛到局部最小值，在大规模数据上收敛较慢
K值比较难以选取；
对初值的簇心值敏感，对于不同的初始值，可能会导致不同的聚类结果；
不适合于发现非凸面形状的簇，或者大小差别很大的簇。
对于”噪声”和孤立点数据敏感，少量的该类数据能够对平均值产生极大影响。
```





## 深度学习10大算法

深度学习与神经网络

```
深度学习网络与“典型”的前馈多层网络之间是有一些区别的，如下：
深度学习网络比之前的网络有更多的神经元
深度学习网络具有更复杂的连接层的方式
深度学习网络需要用强大的计算能力来训练
深度学习网络能够进行自动特征提取

因此深度学习可以被定义为在以下四个基本网络框架中拥有大量参数和层的神经网络：
无监督预训练网络（Unsupervised Pre-trained Networks）
卷积神经网络（Convolutional Neural Networks）
循环神经网络（Recurrent Neural Networks）-rnn
递归神经网络 （Recursive Neural Networks）
我主要对后三个框架比较感兴趣。

cnn卷积神经网络：基本上就是用共享权重在空间中进行扩展的标准神经网络。设计CNN主要是为了通过内部卷积来识别图片，内部卷积可以看到待识别物体的边。

rnn循环神经网络：基本上是在时间上进行扩展的标准神经网络，因为边进入下一个时间步，而不是在同一时间步进入下一个层。设计RNN主要是为了识别序列，例如语音信号或者文本。它里面的循环意味着网络中存在短暂的记忆。

rnn递归神经网络：更类似于分层网络，其中输入序列没有真正的时间面，而是输入必须以树状方式分层处理。



以下10种方法可以应用于所有这些体系结构。
1、反向传播
建立聊城市气象因素与上消化道出血发病的反向传播(back propagation,BP)神经网络预测模型。
反向传播是“误差反向传播”的简称，它是一种计算函数（在神经网络中以函数形式存在）偏微分的方法。当你要用一个基于梯度的方法来解决一个最优问题时（注意梯度下降只是解决这类问题的一种方法），你希望在每一次迭代中计算函数梯度。
对于神经网络而言，目标函数具有合成的形式。那么如何计算梯度呢？一般情况下有两种常见的方法：
1）微分分析法。当你知道这个函数的形式时，你只需要用链式法则计算导数即可；
2）用有限差分方法来近似微分。这种方法的计算量很大，因为函数评估的数量是O（N），其中N是参数的数量。与微分分析法相比，这是比较昂贵的。不过，有限差分通常在调试时验证后端实现。


2、随机梯度下降
一个直观理解梯度下降的方法是去想象一条溯源山顶的河流。这条河流会沿着山势梯度的方向流向山麓下的最低点。
如果让人来走，可能就不一样了，你可能会先随便选一个方向，然后沿着这个方向的梯度向下走；过一会儿再随机换一个方向向下走；最后你发现自己差不多也到了谷底了。
当n很大时，每次迭代计算所有的梯度会非常耗时。
随机梯度下降的想法就是每次在Delta f_i 中随机选取一个计算代替上面的Delta f_i，以这个随机选取的方向作为下降的方向。这样的方法反而比梯度下降能够更快地到达（局部）最优解。


3、学习率衰减
在训练模型的时候，通常会遇到这种情况：我们平衡模型的训练速度和损失（loss）后选择了相对合适的学习率（learning rate），但是训练集的损失下降到一定的程度后就不在下降了，比如training loss一直在0.7和0.9之间来回震荡，不能进一步下降。如下图所示：



遇到这种情况通常可以通过适当降低学习率（learning rate）来实现。但是，降低学习率又会延长训练所需的时间。

学习率衰减（learning rate decay）就是一种可以平衡这两者之间矛盾的解决方案。学习率衰减的基本思想是：学习率随着训练的进行逐渐衰减。

学习率衰减基本有两种实现方法：

线性衰减。例如：每过5个epochs学习率减半；

指数衰减。例如：每过5个epochs将学习率乘以0.1。


4、dropout
在当前的大规模神经网络中有两个缺点：

费时；
容易过拟合

Dropout 可以很好地解决这个问题。Dropout说的简单一点就是在前向传导的时候，让某个神经元的激活值以一定的概率p停止工作，示意图如下：



每次做完dropout，相当于从原始的网络中找到一个更瘦的网络。

Hinton在其论文中做了这样的类比，无性繁殖可以保留大段的优秀基因，而有性繁殖则将基因随机拆了又拆，破坏了大段基因的联合适应性；但是自然选择了有性繁殖，物竞天择，适者生存，可见有性繁殖的强大。dropout 也能达到同样的效果，它强迫一个神经单元，和随机挑选出来的其他神经单元共同工作，消除减弱了神经元节点间的联合适应性，增强了泛化能力。


5、max pooling
池化（Pooling）是卷积神经网络中另一个重要的概念，它实际上是一种形式的向下采样。有多种不同形式的非线性池化函数，而其中“最大池化（Max pooling）”是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。



直觉上，这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。通常来说，CNN的卷积层之间都会周期性地插入池化层。 


6、批标准化
包括深度网络在内的神经网络需要仔细调整权重初始化和学习参数。批标准化使这些变得轻松许多。

权重问题：

无论权重的初始化如何，是随机的还是经验性的选择，它们离学习权重都会很远。考虑一个小批量，初期在所需的特征激活方面会有很多异常值。

深层神经网络本身是病态的，初始层中的微小扰动都会导致后面层的非常大的变化。

在反向传播过程中，这些现象会导致梯度弥散。这就意味着在学习权重产生所需要的输出前，必须对梯度的异常值进行补偿，这将导致需要额外的时段来收敛。



批量归一化使这些梯度从分散到正常值并在小批量范围内流向共同目标（通过归一化）。

学习率问题：一般来说，学习率需要保持较低的值，使得只有一小部分的梯度来校正权重，原因是要使异常激活的梯度不影响已学习到的激活。通过批量标准化，可以减少这些异常激活，因此也就可以使用更高的学习率来加速学习过程。


7、long short-term memory
LSTM网络具有以下三个方面，使其与循环神经网络中的常见神经元不同：

1）它能够决定何时让输入进入神经元；

2）它能够决定何时记住上一个时间步中计算的内容；

3）它决定何时让输出传递到下一个时间步。

LSTM的美妙之处在于它能够根据当前的输入本身来决定所有这些。 所以你看下面的图表：



当前时间的输入信号x（t）决定所有上述3个点。 输入门决定点1，遗忘门决定点2，输出门决定点3。任何一条输入都能够采取所有这三个决定。这种设计其实是受到了我们大脑如何工作的启发，并且可以基于输入来处理突然的上下文切换。


8、skip-gram
词嵌入模型的目标是为每个词项学习一个高维密集表示，其中嵌入向量之间的相似性显示了相应词之间的语义或句法相似性。 Skip-gram是一个学习词嵌入算法的模型。

skip-gram模型（以及许多其他的词语嵌入模型）背后的主要思想如下：两个词项相似，如果它们共享相似的上下文。



换句话说，假设你有一个句子，例如“猫是哺乳动物”；如果你用“狗”而不是“猫”，这个句子还是一个有意义的句子。因此在这个例子中，“狗”和“猫”可以共享相同的上下文（即“是哺乳动物”）。

基于上述假设，你可以考虑一个上下文窗口（一个包含k个连续项的窗口），然后你跳过其中一个单词，试着去学习一个能够得到除跳过项外的所有项的神经网络，并预测跳过的这个项。如果两个词在一个大语料库中反复共享相似的语境，则这些词的嵌入向量将具有相近的向量。


9、连续词袋
在自然语言处理问题中，我们希望学习将文档中的每个单词表示为一个数字的向量，使得出现在相似的上下文中的单词具有彼此接近的向量。在连续的单词模型中，目标是能够使用围绕特定单词的上下文并预测特定单词。

 

我们通过在一个大的语料库中采取大量的句子来做到这一点，每当我们看到一个单词时，我们就提取周围的单词。 然后，我们将上下文单词输入到一个神经网络，并预测在这个上下文中间的单词。

当我们有成千上万个这样的上下文单词和中间词时，我们就有一个神经网络数据集的实例。 我们训练神经网络，最后编码的隐藏层输出表示了特定单词的嵌入。 恰巧，当我们对大量的句子进行训练时，类似语境中的单词得到相似的向量。


10、迁移学习
让我们想一下如何在CNN中处理一张图片。假设有一张图片，你对它进行卷积处理，然后你得到的输出是像素的组合，我们姑且称之为“边”吧。我们再次使用卷积，这时候你得到的输出将是边的组合，我们称之为“线”。如果再次使用卷积，那么你将得到线的组合，等等。

每一层都是在寻找相应的特定模式。你的神经网络最后一层一般会给出非常特定的模式。也许你在处理ImageNet，你的网络最后一层可能是在找孩子、狗或飞机或别的任何东西。如果你向前两层看，网络可能是在找眼睛、耳朵、嘴巴或者轮子。



深度卷积神经网络中的每一层的深入都是在构建越来越高层次的特征表示。最后两层会产生你输入模型的数据中的特定模式。换句话说，早期的层提取的特征则广泛得多，在提取的大量的类中有很多简单的模式。

迁移学习就是当你用一个数据集训练CNN时，砍掉最后的一（些）层，再用另一个不同的数据集重新训练最后一（些）层的模型。直观地说，你在重新训练模型来识别不同的高级层次特征。作为结果，训练时间大幅减少。所以当你没有足够的数据或者训练的资源时，迁移学习是非常有用的一个工具。
```













## 参考文献

```

[1] https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff

[2] http://blog.echen.me/2011/04/27/choosing-a-machine-learning-classifier/

[3] http://www.csuldw.com/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/ 
```

