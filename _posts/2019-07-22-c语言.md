

# 一、c数据类型

1.基本类型

- 数值类型 
  - short短整型
  - int整型
  - long长整型
  - float单精度
  - double双精度
- 字符串类型 char

2.构造类型

- 数组
- 结构体 struct
- 共同体 union
- 枚举类型 enum

3.指针类型

4.空类型void



# 二、C语言

### 一、序言

#### 1.什么是C语言（who）

c语言是人类和计算机交流的一种方式

ANSI C是C语言的标准

#### 2.C语言的特点（what）

1. 简单
2. 快速
3. 高性能
4. 兼容性号
5. 功能强大
6. 易于学习

#### 3.C语言最适合做什么

- linux嵌入式
  - 小巧
  - 灵活
  - 适合做小工具
- 操作系统
- 硬件编程
- 高性能软件(NGINX)

### 二、第一个程序

```c
#include <stdio.h>
int main()
{
	printf("hello word!\n");
	
	return 0;
}
```

$gcc a.c

### 三.多个源文件

max.c

```c
int max (int a,int b)
{
        if(a>b)
        {
                return a;
        }
        else
        {
                return b;
        }
}
```

hello.c

```c
#include <stdio.h>
#include "max.c"
int main()
{
        int a1 = 33;
        int a2 = 21;
        int maxNum=max(a1,a2);
        printf("the max value is %d\n",maxNum);
        return 0;
}
```

$gcc hello.c -o main.out

### 4.头文件与函数分离

max.c

```c
int max (int a,int b)
{
        if(a>b)
        {
                return a;
        }
        else
        {
                return b;
        }
}
```

max.h

```c
int max(int a,int b);
```

hello.c

```c
#include <stdio.h>
#include "max.h"

int main()
{
        int a1 = 33;
        int a2 = 21;
        int maxNum=max(a1,a2);
        printf("the max value is %d\n",maxNum);
        return 0;
}
```

$gcc max.o hello.c

#### 5.Makefile

Makefile 使文件

```c
hello.out:max.o min.o hello.c
        gcc max.o min.o hello.c -o hello.out
max.o:max.c
        gcc -c max.c
min.o:min.c
        gcc -c min.c
```

$make

# 三、vim

```vim

sudo apt-get update  乌班图的更新软件
sudo apt-get install vim 安装vim
gcc协议，gcc就是cc ；gcc -v 是查看版本

i前面
a后面。：shift+a 行首插入
q推出
o 行尾
shift +o

1.文件和目录 （乌班图中）
cd〜或cd / home进入主目录1
cd ..				返回上一目录
cd ../ ..	返回上两级目录2
pwd				显示当前工作路径
ls								查看目录中的文件
ls -F							查看目录中的文件3
ls -l							显示文件和目录的详细资料
ls -a							显示系统隐藏文件
ls * [0-9] *			显示包含数字0-9的文件和目录  4
mkdir xxx					创建xxx目录
mkdir xx1 xx2			同时创建xx1和xx2目录     5
rm -f file1			删除文件file1
rmdir xxx1			删除xxx1目录
rm -rf dir1			删除dir1目录以及该目录的所有内容6
rm -rf dir1 dir2同时删除这两个目录下的所有内容
mv dir1 dir2		将dir1重命名为dir2    7
cp dir1 dir2		拷贝dir1新的拷贝贝项为dir2
cp目录/ *				拷贝目录目录下所有的文件到当前目录下  8
 cp -a / tmp / 				dir1将dir1目录复制到当前目录 9
touch -t（YYMMDDhhmm）file1修改文件file1的时间戳  10
```

### Makefile文件

```

# this is make file
hello.out:max.o min.o hello.c -o hello.out
hello.out:max.o min.o hello.c 
        gcc max.o min.o hello.c  
max.o:max.c    对max.o进行编译
        gcc -c max.c
min.o:max.c
        gcc -c min.c
```

### 字符串指针和c中问好用法

```c
C语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中
#include <stdio.h>
#include <string.h>
int main(){
    char str[] = "http://c.biancheng.net";
    int len = strlen(str), i;
    //直接输出字符串
    printf("%s\n", str);
    //每次输出一个字符
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");
    return

      
      
//Gpu cpu	一行中出现?(问好)：
# include <stdio.h>

int main()
{
int a =1;
int b = 2;
char c;
(a>b)?printf("d"):printf("ds\n");

	return 0;
}
```







# 三、C语言的内存

### 1.GDB

用于调试的一种工具，可以轻松的看到程序内部运行结构

```
gcc -g main.c -o main.out 				#将文件转成可支持gdb调试的调试文件
gdb ./main.out 							#进行调试
gdb中的使用方法：
-l										#显示源代码
enter									#继续执行代码
start 									#开始调试
p/print		a							#打印a运行结果
n										#继续执行	
$1/$2/$3								代表第一第二第三执行结果
s										#代表进入函数内部
bt										#查看函数堆栈
f   1									#表示切换到1这个函数栈
q										#退出调试
x/3d <x0ffffffffffffffffff>				# 从开始的地方按照十进制的类型连续显示三位；
```

### 2. 计算机中数据(重要)

数据的表示方法:计算机中一般以16进制的数来自动分配保存的地址;

一个16进制的数等于四个2进制的数如（0xF = 1111 = 15）；

```
从上往下分为：
系统内核：								#用于给系统自己处理的内存空间：24个十六进制字节
栈内存：								 #系统自动分配当执行代码程序的时候，需要在栈内分配数据的内存
自由分配区：							    #用于个人处理数据自由分配的空间
堆									   #堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程											序结束时可能由OS回收，分配方式倒是类似于链表
数据段：								 #用于存储 global const 等全局变量常量的数据
代码段：								 #存储代码的部分，main函数入口也在此区域
```

### 3.指针和内存的实质

```
//无指针的情况下
#include<stdio.h>
int change(int a，int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

int main()
{
    int a = 5;
    int b = 3;
    change(a,b);
    printr("a:%d;b:%d",a,b);
    
}

//以上结果输出：a:5;b:3									#结果并没有改变；
// 有指针的情况下
#include<stdio.h>
int change(int *a,int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int main()
{
    int a = 5;
    int b = 3;
    change(&a,&b);
    printr("a:%d;b:%d",a,b);
    
}
//以上结果输出：a:3;b:5									#结果改变；
```

### 通过以上，得知:

```
#### 指针*：

#### 保存的就是我们的内存地址；在有*的情况下，他会根据内存地址找到相应变量的值

#### 如果变量保存的也是内存地址，那么他会根据指针找到变量下的内存的值；指针也就是我们说的线索

#### gdb 中：

#### p	a =>	(a : x0ffffffffffffffff);

#### p	*a =>	5;

#### 变量：

#### 变量实质上就是一个代号，里面可以是值，也可以是内存地址；

#### \&a;

#### 实质上是吧变量a的内存地址取出来；gdb中	p	&a =>	(a : x0ffffffffffffffff);	p	a=>	5;

#### 注意：在我们强行取出一个没有定义的值时，系统会给出一个不确定的值，该值可能带来程序的不可控性；


```

### 4.内存中各个类型的内存大小：

```
#### 在分配地址中，编译器会进行内存分配优化，会将所有同类型的分配在相邻；

#### 1. 整型类型：	32位b	4字节；

#### 2. 64位系统下指针会占	64位b	8字节；

#### 3. 32位系统下指针会占	32位b	4字节；
```



#### 

### 5. 栈内存和代码段分配的内存大小

```

#### 在分配地址中，编译器会进行内存分配优化，会将所有同类型的分配在相邻；

#### 1. 整型类型：	32位b	4字节；

#### 2. 64位系统下指针会占	64位b	8字节；

#### 3. 32位系统下指针会占	32位b	4字节；
```

### 6. 数组声明的内存排列

```
#### 在内存中，数组的排列顺序的连续的

#### 数组的定义：int array[3]；
3 代表数组有多少个值；

```

### 

# 四、指针



### 1. 函数指针：

```
（* pdemo）(a);				pdemo 是一个函数的内存地址
							  通过*来指向该内存下的函数
							  前面（）代表：告诉系统这是代码段下的一个函数不是栈内和堆内的内存地址；让他去代码段内找到该函数
							  后面的（）代表运行并传参；
```

### 2.指针的运算；

```
指针加：		#会先判断指针下的值是什么类型，然后在根据类型所占空间大小增加字节位数；
指针偏移：		p代表指针;		p+=3;		代表讲指针p向下移动三个（字节）！；
```





# 五、数组指针

数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。以`int arr[] = { 99, 15, 100, 888, 252 };`为例，该数组在内存中的分布如下图所示：

![array](https://17625074822.github.io/images/array.jpg)

定义数组时，要给出数组名和数组长度，数组名可以认为是一个指针，它指向数组的第 0 个元素。在C语言中，我们将第 0 个元素的地址称为数组的首地址。以上面的数组为例，下图是 arr 的指向：![array1](https://17625074822.github.io/images/array1.jpg)

数组名的本意是表示整个数组，也就是表示多份数据的集合，但在使用过程中经常会转换为指向数组第 0 个元素的指针，所以上面使用了“认为”一词，表示数组名和数组首地址并不总是等价。初学者可以暂时忽略这个细节，把数组名当做指向第 0 个元素的指针使用即可

下面的例子演示了如何以指针的方式遍历数组元素：

```c
#include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int len = sizeof(arr) / sizeof(int);  //求数组长度
    int i;
    for(i=0; i<len; i++){
        printf("%d  ", *(arr[i] );  //*(arr+i)等价于arr[i]
    }
    printf("\n");
    return 0;
}
```

我们也可以定义一个指向数组的指针，例如：

```
int arr[] = { 99, 15, 100, 888, 252 };
int *p = arr;
```

arr 本身就是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以`int *p = arr;``int *p = &arr[0];`

强调一遍，“arr 本身就是一个指针”这种表述并不准确，严格来说应该是“arr 被转换成了一个指针”

如果一个指针指向了数组，我们就称它为数组指针（Array Pointer）。

数组指针指向的是数组中的一个具体元素，而不是整个数组，所以数组指针的类型和数组元素的类型有关，上面的例子中，p 指向的数组元素是 int 类型，所以 p 的类型必须也是`int *`。

反过来想，p 并不知道它指向的是一个数组，p 只知道它指向的是一个整数，究竟如何使用 p 取决于程序员的编码。





# 2.C指针

### 1.初始指针

main.c

```
#include <stdio.h>
void change(int *a,int *b)
{
        int tmp = *a;
        *a = *b;
        *b = tmp;
}
int main()
{
        int a=5;
        int b=3;
        change(&a,&b);
        printf("num a=%d\nnum b=%d\n",a,b);
        return 0;
}
```

&a 传递内存地址

### 2.gdb工具

1. 要使用gdb工具调试c程序,需要在编译时加入-g参数

   gcc -g main.c -o main.out

2. gdb ./main.out

3. l查看源代码

   回车继续

4. start开始调试

5. n下一行

   先显示,后执行

6. p a

   打印a变量

7. change(a,b)

   按s 进入该方法

8. bt查看堆栈

   ```
   #0  change (a=5, b=3) at main2.c:6
   #1  0x000055555555468e in main () at main2.c:15
   ```

9. f 0 表示切换0

10. quit 退出

### 3.内存管理

1. 32位系统地址总线32位，64位系统地址总线64位
2. 2的32次方约等于4G
3. 64位操作系统用户可用48位,剩余内存运行系统
4. 内存管理

### 4.指针

指针的本质就是内存地址

### 5.操作系统对内存的管理

```c
#include <stdio.h>
int global=0;

int rect(int a,int b)
{
        static int count=0;
        count++;
        global++;
        int s=a*b;
        return s;
}

int quadrate(int a)
{
        static int count=0;
        count++;
        global++;
        int s = rect(a,a);
        return s;
}

int main()
{
        int a=3;
        int b=4;
        int *pa = &a;
        int *pb = &b;
        int *pglobal = &global;
        int (*pquadrate)(int a)=&quadrate;
        int s=quadrate(a);
        printf("%d\n",s);
}
```

gcc -g ./ex.c -o ex.out

gdb ./ex.out

```linux
//代码段1
p &rect
$1 = (int (*)(int, int)) 0x5555555546aa <rect> //函数内存地址
(gdb) p &quadrate
$2 = (int (*)(int)) 0x5555555546e1 <quadrate> //函数内存地址，函数指令越多,内存差值越多

//数据段2
(gdb) p &global
$3 = (int *) 0x555555755014 <global>//数据内存地址

//函数段3
//一个函数可以被多次调用
(gdb) p &a
$4 = (int *) 0x7fffffffddcc //int 4字节
(gdb) p &b
$5 = (int *) 0x7fffffffddd0
(gdb) p &pa
$6 = (int **) 0x7fffffffddd8//64位系统指针8字节，32位系统指针4个字节
(gdb) p &pb
$7 = (int **) 0x7fffffffdde0
(gdb) p &s
$10 = (int *) 0x7fffffffddd4//int 都放在一起声明,所以int类型都连续
```

### 5.函数栈以及代码段

```c
(gdb) p &s
$1 = (int *) 0x7fffffffddac
(gdb) s
rect (a=3, b=3) at ./ex.c:7
7		count++;
(gdb) 
8		global++;
(gdb) 
9		int s=a*b;
(gdb) bt
#0  rect (a=3, b=3) at ./ex.c:9
#1  0x0000555555554719 in quadrate (a=3) at ./ex.c:18
#2  0x0000555555554776 in main () at ./ex.c:30
(gdb) p &s
$2 = (int *) 0x7fffffffdd84

    
(gdb) p &count
$3 = (int *) 0x55555575501c <count>
(gdb) f 0
#0  rect (a=3, b=3) at ./ex.c:9
9		int s=a*b;
(gdb) p &count
$4 = (int *) 0x555555755018 <count>

(gdb) p &global
$5 = (int *) 0x555555755014 <global>
(gdb) f 0
#0  rect (a=3, b=3) at ./ex.c:9
9		int s=a*b;
(gdb) p &global
$6 = (int *) 0x555555755014 <global>
 
   
//不同方法中同一变量在不同内存地址中
//静态变量,变量在数据段中
//全局变量也在数据段中
```

### 6.指针指向与数据访问

1. p a //a的值
2. p pa //a的地址
3. p *pa //先取a的地址,再获得a的值

### 7.数据声明的内存排列

```c
#include <stdio.h>
int main()
{
        int a=3;
        int b=2;
        int array[3];
        array[0]=1;
        array[1]=10;
        array[2]=100;
        int *p=&a;
        int i;
        for(i=0;i<6;i++)
        {
                printf("*p=%d\n",*p);
                p++;
        }
        printf("----------------------------------------------------\n");
        p=&a;
        for(i=0;i<6;i++)
        {
                printf("*p[%d]=%d\n",i,p[i]);
        }
}
```