

# 一、c数据类型

1.基本类型

- 数值类型 
  - short短整型
  - int整型
  - long长整型
  - float单精度
  - double双精度
- 字符串类型 char

2.构造类型

- 数组
- 结构体 struct
- 共同体 union
- 枚举类型 enum

3.指针类型

4.空类型void



# 二、C语言序言

### 什么是C语言（who）

c语言是人类和计算机交流的一种方式

ANSI C是C语言的标准

### C语言的特点（what）

1. 简单
2. 快速
3. 高性能
4. 兼容性号
5. 功能强大
6. 易于学习

### c语言适合做什么（can）

1. 适合做Linux嵌入式，Linux小工具
2. 操作系统
3. 硬件编程
4. 对高性能要求的应用程序(NGINX)







# 三、vim

```vim

sudo apt-get update  乌班图的更新软件
sudo apt-get install vim 安装vim
gcc协议，gcc就是cc ；gcc -v 是查看版本

i前面
a后面。：shift+a 行首插入
q推出
o 行尾
shift +o

1.文件和目录 （乌班图中）
cd〜或cd / home进入主目录1
cd ..				返回上一目录
cd ../ ..	返回上两级目录2
pwd				显示当前工作路径
ls								查看目录中的文件
ls -F							查看目录中的文件3
ls -l							显示文件和目录的详细资料
ls -a							显示系统隐藏文件
ls * [0-9] *			显示包含数字0-9的文件和目录  4
mkdir xxx					创建xxx目录
mkdir xx1 xx2			同时创建xx1和xx2目录     5
rm -f file1			删除文件file1
rmdir xxx1			删除xxx1目录
rm -rf dir1			删除dir1目录以及该目录的所有内容6
rm -rf dir1 dir2同时删除这两个目录下的所有内容
mv dir1 dir2		将dir1重命名为dir2    7
cp dir1 dir2		拷贝dir1新的拷贝贝项为dir2
cp目录/ *				拷贝目录目录下所有的文件到当前目录下  8
 cp -a / tmp / 				dir1将dir1目录复制到当前目录 9
touch -t（YYMMDDhhmm）file1修改文件file1的时间戳  10
```

### Makefile文件

```

# this is make file
hello.out:max.o min.o hello.c -o hello.out
hello.out:max.o min.o hello.c 
        gcc max.o min.o hello.c  
max.o:max.c    对max.o进行编译
        gcc -c max.c
min.o:max.c
        gcc -c min.c
```

### 字符串指针和c中问好用法

```c
C语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中
#include <stdio.h>
#include <string.h>
int main(){
    char str[] = "http://c.biancheng.net";
    int len = strlen(str), i;
    //直接输出字符串
    printf("%s\n", str);
    //每次输出一个字符
    for(i=0; i<len; i++){
        printf("%c", str[i]);
    }
    printf("\n");
    return

      
      
//Gpu cpu	一行中出现?(问好)：
# include <stdio.h>

int main()
{
int a =1;
int b = 2;
char c;
(a>b)?printf("d"):printf("ds\n");

	return 0;
}
```







# 三、C语言的内存

### 1.GDB

用于调试的一种工具，可以轻松的看到程序内部运行结构

```
gcc -g main.c -o main.out 				#将文件转成可支持gdb调试的调试文件
gdb ./main.out 							#进行调试
gdb中的使用方法：
-l										#显示源代码
enter									#继续执行代码
start 									#开始调试
p/print		a							#打印a运行结果
n										#继续执行	
$1/$2/$3								代表第一第二第三执行结果
s										#代表进入函数内部
bt										#查看函数堆栈
f   1									#表示切换到1这个函数栈
q										#退出调试
x/3d <x0ffffffffffffffffff>				# 从开始的地方按照十进制的类型连续显示三位；
```

### 2. 计算机中数据(重要)

数据的表示方法:计算机中一般以16进制的数来自动分配保存的地址;

一个16进制的数等于四个2进制的数如（0xF = 1111 = 15）；

```
从上往下分为：
系统内核：								#用于给系统自己处理的内存空间：24个十六进制字节
栈内存：								 #系统自动分配当执行代码程序的时候，需要在栈内分配数据的内存
自由分配区：							    #用于个人处理数据自由分配的空间
堆									   #堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程											序结束时可能由OS回收，分配方式倒是类似于链表
数据段：								 #用于存储 global const 等全局变量常量的数据
代码段：								 #存储代码的部分，main函数入口也在此区域
```

### 3.指针和内存的实质

```
//无指针的情况下
#include<stdio.h>
int change(int a，int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

int main()
{
    int a = 5;
    int b = 3;
    change(a,b);
    printr("a:%d;b:%d",a,b);
    
}

//以上结果输出：a:5;b:3									#结果并没有改变；
// 有指针的情况下
#include<stdio.h>
int change(int *a,int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int main()
{
    int a = 5;
    int b = 3;
    change(&a,&b);
    printr("a:%d;b:%d",a,b);
    
}
//以上结果输出：a:3;b:5									#结果改变；
```

### 通过以上，得知:

```
#### 指针*：

#### 保存的就是我们的内存地址；在有*的情况下，他会根据内存地址找到相应变量的值

#### 如果变量保存的也是内存地址，那么他会根据指针找到变量下的内存的值；指针也就是我们说的线索

#### gdb 中：

#### p	a =>	(a : x0ffffffffffffffff);

#### p	*a =>	5;

#### 变量：

#### 变量实质上就是一个代号，里面可以是值，也可以是内存地址；

#### \&a;

#### 实质上是吧变量a的内存地址取出来；gdb中	p	&a =>	(a : x0ffffffffffffffff);	p	a=>	5;

#### 注意：在我们强行取出一个没有定义的值时，系统会给出一个不确定的值，该值可能带来程序的不可控性；


```

### 4.内存中各个类型的内存大小：

```
#### 在分配地址中，编译器会进行内存分配优化，会将所有同类型的分配在相邻；

#### 1. 整型类型：	32位b	4字节；

#### 2. 64位系统下指针会占	64位b	8字节；

#### 3. 32位系统下指针会占	32位b	4字节；
```



#### 

### 5. 栈内存和代码段分配的内存大小

```

#### 在分配地址中，编译器会进行内存分配优化，会将所有同类型的分配在相邻；

#### 1. 整型类型：	32位b	4字节；

#### 2. 64位系统下指针会占	64位b	8字节；

#### 3. 32位系统下指针会占	32位b	4字节；
```

### 6. 数组声明的内存排列

```
#### 在内存中，数组的排列顺序的连续的

#### 数组的定义：int array[3]；
3 代表数组有多少个值；

```

### 

# 四、指针



### 1. 函数指针：

```
（* pdemo）(a);				pdemo 是一个函数的内存地址
							  通过*来指向该内存下的函数
							  前面（）代表：告诉系统这是代码段下的一个函数不是栈内和堆内的内存地址；让他去代码段内找到该函数
							  后面的（）代表运行并传参；
```

### 2.指针的运算；

```
指针加：		#会先判断指针下的值是什么类型，然后在根据类型所占空间大小增加字节位数；
指针偏移：		p代表指针;		p+=3;		代表讲指针p向下移动三个（字节）！；
```





# 五、数组指针

数组（Array）是一系列具有相同类型的数据的集合，每一份数据叫做一个数组元素（Element）。数组中的所有元素在内存中是连续排列的，整个数组占用的是一块内存。以`int arr[] = { 99, 15, 100, 888, 252 };`为例，该数组在内存中的分布如下图所示：

![array](https://17625074822.github.io/images/array.jpg)

定义数组时，要给出数组名和数组长度，数组名可以认为是一个指针，它指向数组的第 0 个元素。在C语言中，我们将第 0 个元素的地址称为数组的首地址。以上面的数组为例，下图是 arr 的指向：![array1](https://17625074822.github.io/images/array1.jpg)

数组名的本意是表示整个数组，也就是表示多份数据的集合，但在使用过程中经常会转换为指向数组第 0 个元素的指针，所以上面使用了“认为”一词，表示数组名和数组首地址并不总是等价。初学者可以暂时忽略这个细节，把数组名当做指向第 0 个元素的指针使用即可

下面的例子演示了如何以指针的方式遍历数组元素：

```c
#include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int len = sizeof(arr) / sizeof(int);  //求数组长度
    int i;
    for(i=0; i<len; i++){
        printf("%d  ", *(arr[i] );  //*(arr+i)等价于arr[i]
    }
    printf("\n");
    return 0;
}
```

我们也可以定义一个指向数组的指针，例如：

```
int arr[] = { 99, 15, 100, 888, 252 };
int *p = arr;
```

arr 本身就是一个指针，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以`int *p = arr;``int *p = &arr[0];`

强调一遍，“arr 本身就是一个指针”这种表述并不准确，严格来说应该是“arr 被转换成了一个指针”

如果一个指针指向了数组，我们就称它为数组指针（Array Pointer）。

数组指针指向的是数组中的一个具体元素，而不是整个数组，所以数组指针的类型和数组元素的类型有关，上面的例子中，p 指向的数组元素是 int 类型，所以 p 的类型必须也是`int *`。

反过来想，p 并不知道它指向的是一个数组，p 只知道它指向的是一个整数，究竟如何使用 p 取决于程序员的编码。