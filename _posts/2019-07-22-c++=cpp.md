---
layout: post
title: "C++语言实战"
date: 2019-07-22
tag: 语言language
---







<!--toc-->

Mac终端运行c++他山之石

## Mac终端运行c++

```
方法一：
1 g++ 源文件名　　编译源文件，产生a.out
2 ./文件名　　　　运行  例如：./a.out < 输入文件名 > 输出文件名
➜  时间复杂度 git:(master) ✗ cd c++  
进入文件夹
➜  c++ git:(master) ✗ g++ s.cpp          
➜  c++ git:(master) ✗ ./a.out      
请输入本月用电量（单位：度）：
2
本月需要支付电费:1.2元
共需要1个1元和2个1角的硬币



方法二：
g++ -o 【目标文件名】 【原文件名】
➜  c++ git:(master) ✗ g++ -o test s.cpp
➜  c++ git:(master) ✗ ./test
➜  c++ git:(master) ✗ ./s
//和上面同样的效果
请输入本月用电量（单位：度）：
2
本月需要支付电费:1.2元
共需要1个1元和2个1角的硬币
➜  c++ git:(master) ✗ ./test 
请输入本月用电量（单位：度）：
43534
本月需要支付电费:26120.4元
共需要26120个1元和4个1角的硬币
➜  c++ git:(master) ✗ ./test           
请输入本月用电量（单位：度）：
-32
本月需要支付电费:-19.2元
共需要-19个1元和-2个1角的硬币




```



`Ctrl + -`

- 1.在编辑器中写好C++代码
- 2.打开终端打开文件对应的地址
- 3.用g++命令来编译.cpp文件
- 4.用./文件名来运行

c2.cpp

```c++
// #include "iostream"
#include <iostream>
int main()
{
	printf("hello world\n"); 
  //必须双信号
    return 0;
}

// hello world
// [Finished in 0.9s]
```



s.cpp 文件

```cpp
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
    int quantity,yuan;
    double  charge,jiao;
    cout << "请输入本月用电量（单位：度）：" << endl;
    
    cin>>quantity ;
    charge=0.6*quantity;
    cout<<"本月需要支付电费:"<<charge <<"元"<<endl;
    yuan=charge;
    jiao=(charge-yuan)*10;

    cout<<endl;
    cout<<"共需要"<<yuan<<"个1元和"<<jiao<<"个1角的硬币"<<endl;

    return 0;
}
```











## 发展

Microsoft visual studio =微软视觉工作室

The C++ Programming Language/c plus plus=====c++编程语言/ C++

C++(The C++ Programming Language/c plus plus)在C语言的基础上开发了一种面向对象编程语言，应用非常广泛。常用于系统开发，引擎开发等应用领域，支持类、封装、继承、多态等特性。C++语言灵活，运算符的数据结构丰富、具有结构化控制语句、程序执行效率高，而且同时具有高级语言与汇编语言的优点。

C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计，因而C++就适应的问题规模而论，大小由之。1983年该语言被正式命名为C++。自从C++被发明以来，它经历了3次主要的修订 ; 

1998年，C++的ANSI/IS0标准被投入使用。

Microsoft Visual C++（简称Visual C++、MSVC、VS或VC）是微软公司的C++开发工具，具有集成开发环境，可提供编辑C语言，C++以及C++/CLI等编程语言。VC++集成了便利的除错工具，特别是集成了微软Windows视窗操作系统应用程序接口（Windows API）、三维动画DirectX API，Microsoft .NET框架。

目前最新的版本是Microsoft Visual C++ 2019。





**一、区别：**

1、概念。C++是程序设计语言，是一种软件编制的通用规范，VC++是编程环境或者一种工具。VC++是微软公司在C++的基础上提供了一些Windows图形界面函数库，可以说VC++ 就是C++加上Windows图形库。

2、使用。C++是一门编程语言，而VC++是一个工具。C++是与平台无关的，VC++只能在Windows跑，学习VC++，是学Windows编程。应该先学编程语言，然后再具体的学习与平台相关的东西。

3、学习方式。VC++教材都是假设用户已经掌握了C++语言，没有C++基础，这样是无法理解MFC 的任何东西的。学好了C++，即使不学Visual C++，也是大有作为的。

**二、联系：**

C++是在C语言的基础上加入了“类”的概念以及“对象”的概念，所以C++是面向对象的编程语言。而VC++是在C++的基础上加入了对windows可视化（窗口化以及控件）操作的支持，所以它也是面向对象的编程语言。



## C/C++语言程序百例C/C++

语言经典、实用、趣味程序设计编程百例精解（1）

1.绘制余弦曲线

在屏幕上用“*”显示0~360度的余弦函数cos(x)曲线

*问题分析与算法设计
如果在程序中使用数组，这个问题十分简单。但若规定不能使用数组，问题就变得不容易了。
关键在于余弦曲线在0~360度的区间内，一行中要显示两个点，而对一般的显示器来说，只能按行输出，即：输出第一行信息后，只能向下一行输出，不能再返回到上一行。为了获得本文要求的图形就必须在一行中一次输出两个“*”。
为了同时得到余弦函数cos(x)图形在一行上的两个点，考虑利用cos(x)的左右对称性。将屏幕的行方向定义为x，列方向定义为y，则0~180度的图形与180~360度的图形是左右对称的，若定义图形的总宽度为62列，计算出x行0~180度时y点的坐标m，那么在同一行与之对称的180~360度的y点的坐标就 应为62-m。程序中利用反余弦函数acos计算坐标(x,y)的对应关系。
使用这种方法编出的程序短小精炼，体现了一定的技巧。

*程序说明与注释
#include<stdio.h>
#include<math.h>
int main()
{
double y;
int x,m;
for(y=1;y>=-1;y-=0.1) /*y为列方向，值从1到-1，步长为0.1*/
{
m=acos(y)*10; /*计算出y对应的弧度m，乘以10为图形放大倍数*/
for(x=1;x<m;x++) printf(" ");
printf("*"); /*控制打印左侧的 * 号*/
for(;x<62-m;x++)printf(" ");
printf("*\n"); /*控制打印同一行中对称的右侧*号*/
}

return 0;
}

*思考题
如何实现用“*”显示0~360度的sin(x)曲线。

在屏幕上显示0~360度的cos(x)曲线与直线f(x)=45*(y-1)+31的迭加图形。其中cos(x)图形用“*”表示，f(x)用“+”表示，在两个图形相交的点上则用f(x)图形的符号。

2.绘制余弦曲线和直线

*问题分析与算法设计
本题可以在上题的基础上进行修改。图形迭加的关键是要在分别计算出同一行中两个图形的列方向点坐标后，正确判断相互的位置关系。为此，可以先判断图形的交点，再分别控制打印两个不同的图形。

*程序注释与说明
#include<stdio.h>
#include<math.h>
int main()
{
double y;
int x,m,n,yy;
for(yy=0;yy<=20;yy++) /*对于第一个y坐标进行计算并在一行中打印图形*/
{
y=0.1*yy; /*y：屏幕行方向坐标*/
m=acos(1-y)*10; /*m: cos(x)曲线上y点对应的屏幕列坐标*/
n=45*(y-1)+31; /*n: 直线上y点对应的列坐标*/
for(x=0;x<=62;x++) /*x: 屏幕列方向坐标*/
if(x==m&&x==n) printf("+"); /*直线与cos(x)相交时打印“+”*/
else if(x==n) printf("+"); /*打印不相交时的直线图形*/
else if(x==m||x==62-m) printf("*"); /*打印不相交时的cos(x)图形*/
else printf(" "); /*其它情况打印空格*/
printf("\n");
}

return 0;
}

*思考题
如何实现sin(x)曲线与cos(x)曲线图形的同时显示。

3.绘制圆

在屏幕上用“*”画一个空心的圆

*问题分析与算法设计
打印圆可利用图形的左右对称性。根据圆的方程：
R*R=X*X+Y*Y
可以算出圆上每一点行和列的对应关系。

*程序说明与注释
#include<stdio.h>
#include<math.h>
int main()
{
double y;
int x,m;
for(y=10;y>=-10;y–)
{
m=2.5*sqrt(100-y*y); /*计算行y对应的列坐标m，2.5是屏幕纵横比调节系数因为屏幕的
行距大于列距，不进行调节显示出来的将是椭圆*/
for(x=1;x<30-m;x++) printf(" "); /*图形左侧空白控制*/
printf("*"); /*圆的左侧*/
for(;x<30+m;x++) printf(" "); /*图形的空心部分控制*/
printf("*\n"); /*圆的右侧*/
}
return 0;
}

*思考题
实现函数y=x2的图形与圆的图形叠加显示
4.歌星大奖赛

在歌星大奖赛中，有10个评委为参赛的选手打分，分数为1~100分。选手最后得分为：去掉一个最高分和一个最低分后其余8个分数的平均值。请编写一个程序实现。

*问题分析与算法设计
这个问题的算法十分简单，但是要注意在程序中判断最大、最小值的变量是如何赋值的。
*程序说明与注释
#include<stdio.h>
int main()
{
int integer,i,max,min,sum;
max=-32768; /*先假设当前的最大值max为C语言整型数的最小值*/
min=32767; /*先假设当前的最小值min为C语言整型数的最大值*/
sum=0; /*将求累加和变量的初值置为0*/
for(i=1;i<=10;i++)
{
printf("Input number %d=",i);
scanf("%d",&integer); /*输入评委的评分*/
sum+=integer; /*计算总分*/
if(integer>max)max=integer; /*通过比较筛选出其中的最高分*/
if(integer<min)min=integer; /*通过比较筛选出其中的最低分*/
}
printf("Canceled max score:%d\nCanceled min score:%d\n",max,min);
printf("Average score:%d\n",(sum-max-min)/8); /*输出结果*/
}

*运行结果
Input number1=90
Input number2=91
Input number3=93
Input number4=94
Input number5=90
Input number6=99
Input number7=97
Input number8=92
Input number9=91
Input number10=95
Canceled max score:99
Canceled min score:90
Average score:92

*思考题
题目条件不变，但考虑同时对评委评分进行裁判，即在10个评委中找出最公平(即评分最接返平均分)和最不公平(即与平均分的差距最大)的评委，程序应该怎样实现？
5.求最大数

问555555的约数中最大的三位数是多少？

*问题分析与算法设计
根据约数的定义，对于一个整数N，除去1和它自身外，凡能整除N的数即为N的约数。因此，最简单的方法是用2到N-1之间的所有数去除N，即可求出N的全部约数。本题只要求取约数中最大的三位数，则其取值范围可限制在100到999之间。
*程序说明与注释
#include<stdio.h>
int main()
{
long i;
int j;
printf("Please input number:");
scanf("%ld",&i);
for(j=999;j>=100;j–)
if(i%j==0)
{
printf("The max factor with 3 digits in %ld is:%d,\n",i,j);
break;
}
}

*运行结果
输入：555555
输出：The max factor with 3 digits in 555555 is:777
6.高次方数的尾数

求13的13次方的最后三位数

*问题分析与算法设计
解本题最直接的方法是：将13累乘13次方截取最后三位即可。
但是由于计算机所能表示的整数范围有限，用这种“正确”的算法不可能得到正确的结果。事实上，题目仅要求最后三位的值，完全没有必要求13的13次方的完整结果。
研究乘法的规律发现：乘积的最后三位的值只与乘数和被乘数的后三位有关，与乘数和被乘数的高位无关。利用这一规律，可以大大简化程序。
*程序说明与注释
#include<stdio.h>
int main()
{
int i,x,y,last=1; /*变量last保存求X的Y次方过程中的部分乘积的后三位*/
printf("Input X and Y(X**Y):");
scanf("%d**%d",&x,&y);
for(i=1;i<=y;i++) /*X自乘Y次*/
last=last*x%1000; /*将last乘X后对1000取模，即求积的后三位*/
printf("The last 3 digits of %d**%d is:%d\n",x,y,last%1000); /*打印结果*/
}

*运行结果
Input X and Y(X**Y):13**13
The last 3 digits of 13**13 is:253
Input X and Y(X**Y):13**20
The last 3 digits of 13**20 is:801
7.阶乘尾数零的个数

100!的尾数有多少个零？

 

*问题分析与算法设计
　　可以设想：先求出100!的值，然后数一下末尾有多少个零。事实上，与上题一样，由于计算机所能表示的整数范围有限，这是不可能的。
　　为了解决这个问题，必须首先从数学上分析在100!结果值的末尾产生零的条件。不难看出：一个整数若含有一个因子5，则必然会在求100!时产生一个零。因此问题转化为求1到100这100个整数中包含了多少个因子5。若整数N能被25整除，则N包含2个因子5；若整数N能被5整除，则N包含1个因子5。
*程序说明与注释
#include<stdio.h>
int main()
{
int a,count =0;
for(a=5;a<=100;a+=5) //循环从5开始，以5的倍数为步长，考察整数
{
++count; //若为5的倍数，计数器加1
if(!(a%25)) ++count; //若为25的倍数，计数器再加1
}
printf("The number of 0 in the end of 100! is: %d.\n",count); //打印结果
return 0;
}

*运行结果
The number of 0 in the end of 100! is: 24.

*问题进一步讨论

本题的求解程序是正确的，但是存在明显的缺点。程序中判断整数N包含多少个因子5的方法是与程序中的100有关的，若题目中的100改为1000，则就要修改程序中求因子5的数目的算法了。

*思考题

修改程序中求因子5的数目的算法，使程序可以求出任意N!的末尾有多少个零。
8.借书方案知多少

小明有五本新书，要借给A，B，C三位小朋友，若每人每次只能借一本，则可以有多少种不同的借法？

*问题分析与算法设计
本问题实际上是一个排列问题，即求从5个中取3个进行排列的方法的总数。首先对五本书从1至5进行编号，然后使用穷举的方法。假设三个人分别借这五本书中的一本，当三个人所借的书的编号都不相同时，就是满足题意的一种借阅方法。
*程序说明与注释
int main()
{
int a,b,c,count=0;
printf("There are diffrent methods for XM to distribute books to 3 readers:\n");
for(a=1;a<=5;a++) /*穷举第一个人借5本书中的1本的全部情况*/
for(b=1;b<=5;b++) /*穷举第二个人借5本书中的一本的全部情况*/
for(c=1;a!=b&&c<=5;c++) /*当前两个人借不同的书时，穷举第三个人借5本书
中的1本的全部情况*/
if(c!=a&&c!=b) /*判断第三人与前两个人借的书是否不同*/
printf(count%8?"%2d:%d,%d,%d ":"%2d:%d,%d,%d\n ",++count,a,b,c);
/*打印可能的借阅方法*/
}

*运行结果
There are diffrent methods for XM to distribute books to 3 readers:
1: 1,2,3 2: 1,2,4 3: 1,2,5 4: 1,3,2 5: 1,3,4
6: 1,3,5 7: 1,4,2 8: 1,4,3 9: 1,4,5 10:1,5,2
11:1,5,3 12:1,5,4 13:2,1,3 14:2,1,4 15:2,1,5
16:2,3,1 17:2,3,4 18:2,3,5 19:2,4,1 20:2,4,3
21:2,4,5 22:2,5,1 23:2,5,3 24:2,5,4 25:3,1,2
26:3,1,4 27:3,1,5 28:3,2,1 29:3,2,4 30:3,2,5
31:3,4,1 32:3,4,2 33:3,4,5 34:3,5,1 35:3,5,2
36:3,5,4 37:4,1,2 38:4,1,3 39:4,1,5 40:4,2,1
41:4,2,3 42:4,2,5 43:4,3,1 44:4,3,2 45:4,3,5
46:4,5,1 47:4,5,2 48:4,5,3 49:5,1,2 50:5,1,3
51:5,1,4 52:5,2,1 53:5,2,3 54:5,2,4 55:5,3,1
56:5,3,2 57:5,3,4 58:5,4,1 59:5,4,2 60:5,4,3

9.杨辉三角形

在屏幕上显示杨辉三角形

            1
          1 1
        1 2 1
       1 3 3 1
      1 4 6 4 1
   1 5 10 10 5 1
………………………………..

*问题分析与算法设计
杨辉三角形中的数，正是(x+y)的N次方幂展开式各项的系数。本题作为程序设计中具有代表性的题目，求解的方法很多，这里仅给出一种。
从杨辉三角形的特点出发，可以总结出：
1)第N行有N+1个值(设起始行为第0行)
2)对于第N行的第J个值：(N>=2)
当J=1或J=N+1时：其值为1
J!=1且J!=N+1时：其值为第N-1行的第J-1个值与第N-1行第J个值
之和
将这些特点提炼成数学公式可表示为：
1 x=1或x=N+1
c(x,y)=
c(x-1,y-1)+c(x-1,y) 其它

本程序应是根据以上递归的数学表达式编制的。
*程序说明与注释
#include<stdio.h>
int main()
{
int i,j,n=13;
printf("N=");
while(n>12)
scanf("%d",&n); /*控制输入正确的值以保证屏幕显示的图形正确*/
for(i=0;i<=n;i++) /*控制输出N行*/
{
for(j-0;j<24-2*i;j++) printf(" "); /*控制输出第i行前面的空格*/
for(j=1;j<i+2;j++) printf("%4d",c(i,j)); /*输出第i行的第j个值*/
printf("\n");
}
}

void int c(int x,int y) /*求杨辉三角形中第x行第y列的值*/
{
int z;
if((y==1)||(y==x+1)) return 1; /*若为x行的第1或第x+1列，则输出1*/
z=c(x-1,y-1)+c(x-1,y); /*否则，其值为前一行中第y-1列与第y列值之和*/
return z;
}

*思考题
自行设计一种实现杨辉三角形的方法
10.数制转换

将任一整数转换为二进制形式

*问题分析与算法设计
将十进制整数转换为二进制的方法很多，这里介绍的实现方法利用了C语言能够对位进行操作的特点。对于C语言来说，一个整数在计算机内就是以二进制的形式存储的，所以没有必要再将一个整数经过一系列的运算转换为二进制形式，只要将整数在内存中的二进制表示输出即可。
*程序说明与注释
#include<stdio.h>
void printb(int,int);
int main()
{
int x;printf("Input number:");
scanf("%d",&x);
printf("number of decimal form:%d\n",x);
printf(" it's binary form:");
printb(x,sizeof(int)*8); /*x:整数 sizeof(int):int型在内存中所占的字节数
sizeof(int)*8:int型对应的位数*/
putchar('\n');
}

void printb(int x,int n)
{
if(n>0)
{
putchar('0'+((unsigned)(x&(1<<(n-1)))>>(n-1))); /*输出第n位*/
printb(x,n-1); /*归调用，输出x的后n-1位*/
}
}

*运行结果
输入：8
输出：
number of decimal form:8
it's bunary form:0000000000001000
输入：-8
输出：number of decimal form:-8
it's binary form:1111111111111000
输入：32767
输出：number of decimal form:32767
it's binary form:0111111111111111
输入：-32768
输出：number of decimal form:-32768
it's binary form:1000000000000000
输入：128
输出：number of decimal form:128
it's binary form:0000000010000000

*问题的进一步讨论
充分利用C语言可以对位进行操作的特点，可以编写许多其它高级语言不便于编写甚至根本无法编写的程序。位操作是C语言的一大特点，在深入学习C语言的过程中应力求很好掌握。
程序中使用的位运算方法不是最佳的，也可以不用递归操作，大家可以自行对程序进行优化。

*思考题
将任意正整数转换为四进制或八进制数。





## 他山之石

```

```



