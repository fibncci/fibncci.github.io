---
layout: post
title: "青蛙过河"
date: 2019-07-25
tag: 学习
---



# 青蛙过河

#### 技术面试题；



### 1.python实现： 青蛙403.py

```python
count=0# wu 计数
class Solution:
    def canCross(self, stones):# List[int]) -> bool:
        if stones[1] > 1:
            return False
        # 相邻石子间隔的距离
        steps = [stones[i]-stones[i-1] for i in range(1, len(stones))]
        # 如果全是1、2，直接返回true
        if max(steps) < 3:
            return True
        # 定义一个字典维护每个位置跳跃过的步长的列表
        jump = {0:[1]}
        # i为当前位置
        i = 0


        while i < len(steps):
            # 指向下一个位置
            i += 1
            if not jump.get(i-1):
                # 如果当前位置没有发生跳跃则表示是跳过的石头直接下个位置
                continue
            # 弹出当前位置步长列表，也可以直接get，每次pop出来应该能减小空间占用
            step = jump.pop(i-1)
            # 存放当前位置添加过的步长，防止重复添加
            used_step = set()
            while step:
                # 如果i到了末尾则表示成功过河
                if i == len(steps):
                    return True
                # 每次从步长列表弹出一个步长
                cur_step = step.pop()
                if cur_step in used_step:
                    continue
                # 步长加入集合防止重复
                used_step.add(cur_step)
                # 当前位置能跳哪些步长
                able_step = [cur_step-1,cur_step,cur_step+1]
                for step_ in able_step:
                    start = 0
                    for j in range(i, len(steps)):
                        # 累加跳的步长
                        start += steps[j]
                        # 有匹配的直接添加到字典里匹配位置上的步长列表里
                        if start == step_:
                            jump.setdefault(j,[]).append(step_)
                        # 一旦超出则直接退出循环进入下一个步长匹配
                        if start > step_:
                            break
        # 没有新的位置匹配则表示没能过河
        return False
a = Solution()


stones = [0,1,3,5,6,8,12,17]
stones = [0,1,3,5,6,8,12,172]

b=a.canCross(stones)
print(b)

# 一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。

# 给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。

# 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

# 请注意：

# 石子的数量 ≥ 2 且 < 1100；
# 每一个石子的位置序号都是一个非负整数，且其 < 231；
# 第一个石子的位置永远是0。
# 示例 1:

# [0,1,3,5,6,8,12,17]

# 总共有8个石子。
# 第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,
# 第三个石子在序号为3的单元格的位置， 以此定义整个数组...
# 最后一个石子处于序号为17的单元格的位置。

# 返回 true。即青蛙可以成功过河，按照如下方案跳跃： 
# 跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 
# 跳2个单位到第4块石子, 然后跳3个单位到第6块石子, 
# 跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。
# 示例 2:

# [0,1,2,3,4,8,9,11]

# 返回 false。青蛙没有办法过河。 
# 这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。

```



### 2.php实现：

```php
//A11 + A12+A33 +A44
//数列占位符 —标记。
//二进制-1，穷举法 （排列组合）笛卡尔乘积
//0 1 2 3  4 5 6 8 12 100（trash）

  
<?php 
    function cross($arr){
        // 输入数据基本的判断
        if ( !is_array($arr) ) {
            return false;
        }

        $length=count($arr);
        if ($length<=1) {
            return false;
        }

        // 判断第1,2位的数值情况
        if ( ($arr[0]!=0) || ($arr[1]!=1) ) {
            return false;
        }

        if ($length==2) {
            return true;
        }

        // 长度为3时的判断
        if ($length==3) {
            if ( ($arr[2]==2) || ($arr[2]==3) ) {
                return true;
            }else{
                return false;
            }
        }

        // 保证数组元素皆为整型
        for ($i=0; $i < $length; $i++) { 
            if ( !is_int($arr[$i]) ) {
                return false;
            }
        }

        // 子数组的最大长度
        $len=$length-3;
        $arr1=array_slice($arr, 2, $len);

        // 子数组生成的初始方式
        $markStr=str_repeat(1, $len);

        // 生成初始子数组
        $arr2=newArr($arr,$arr1,$markStr);

        // 进行判断检测
        $res=examine($arr,$arr1,$arr2,$len,$markStr);

        return $res;
    }

    // 生成子数组
    function newArr($arr,$arr1,$markStr){
        $arr2=[];
        for ($i=0; $i < strlen($markStr); $i++) { 
            if ( $markStr[$i]==1 ) {
                array_push($arr2, $arr1[$i]);
            }
        }
        // 完善数组
        array_unshift($arr2,$arr[0],$arr[1]);
        array_push( $arr2,end($arr) );

        return $arr2;
    }

    function examine($arr,$arr1,$arr2,$len,$markStr,$times=1){
        // 所有可能的子数组的总数量
        $totalTimes=pow(2,$len);
        // var_dump($arr2);

        // 遍历子数组
        for ($i=1; $i < count($arr2)-1 ; $i++) { 
            // 计算元素分别与前后元素的差值
            $k1=$arr2[$i]-$arr2[$i-1];
            $k2=$arr2[$i+1]-$arr2[$i];

            // 进行差值判断
            if ( abs($k1-$k2)>1 ) {
                // 累计次数
                $times++;
                // 次数判断
                if ($times>$totalTimes) {
                    return false;
                }

                // 子数组生成方式的数据类型转换
                $markNum=toBinary($markStr);
                
                $markNum=decbin(--$markNum);
                $markStr=strval($markNum);
                $markStr=str_pad('0',$len, $markStr );

                // 生成新的子数组
                $arr2=newArr($arr,$arr1,$markStr);

                // 再次进行判断
                $res=examine($arr,$arr1,$arr2,$len,$markStr,$times);

                return $res;
            }
        }

        return $arr2;
    }

    function toBinary($str){
        $num=0;
        for ($i=0; $i < strlen($str); $i++) { 
            if ( $str[$i]==1 ) {
                $num+=pow(2,strlen($str)-1-$i);
            }
        }

        return $num;
    }

    var_dump( cross([0,1,2,3,5,6,8,12,16]) );

    // * 将字符串转换成二进制
    // * @param type $str
    // * @return type
    // */
    // function StrToBin($str){
    //     //1.列出每个字符
    //     $arr = preg_split('/(?<!^)(?!$)/u', $str);
    //     //2.unpack字符
    //     foreach($arr as &$v){
    //         $temp = unpack('H*', $v);
    //         $v = base_convert($temp[1], 16, 2);
    //         unset($temp);
    //     }

    //     return join(' ',$arr);
    // }



 ?>


```









### 3.c语言解决：青蛙403.c

```c
#include"stdlib.h"
#include"stdio.h"

#define MAX_LEN 1100

bool canCrossedByStep(int* stones, int stonesSize,int i,int j,int curStep);
bool canCross(int* stones, int stonesSize);
bool canCross(int* stones, int stonesSize) {
    if(stonesSize < 2)
    {
        return true;
    }
    if(stones[0] != 0 || stones[1] != 1)
    {
        return false;
    }
    return canCrossedByStep(stones, stonesSize,1,2, 1);
    
}

//i当前所在的位置，j寻找下一步的开始位置,curStep当前步长
bool canCrossedByStep(int* stones, int stonesSize,int i,int j,int curStep)
{
    if (j == stonesSize)
    {
        return true;
    }

    for (int k = j; k < stonesSize; ++k)
    {
        //已跳不过去，因为stones[index] > stones[k](index > k)
        if (stones[k] > stones[i] + curStep + 1)
        {
            return false;
        }
        else if (stones[k] == stones[i] + curStep + 1)
        {
            //后面不可能再跳过去了，可以直接return
            //printf("stones[j] == stones[i] + curStep + 1,stones[i]:%d,stones[j]:%d,step:%d\n",stones[i],stones[k],curStep + 1);
            return canCrossedByStep(stones, stonesSize,k,k+1,curStep + 1);
        }
        else if (stones[k] == stones[i] + curStep)
        {
            //printf("stones[j] == stones[i] + curStep,stones[i]:%d,stones[j]:%d,step:%d\n",stones[i],stones[k],curStep);
            if(canCrossedByStep(stones, stonesSize,k,k+1,curStep))
            {
                return true;
            }
        }
        else if (curStep - 1 > 0 && stones[k] == stones[i] + curStep - 1)
        {
            //printf("stones[j] == stones[i] + curStep - 1,stones[i]:%d,stones[j]:%d,step:%d\n",stones[i],stones[k],curStep - 1);
            if(canCrossedByStep(stones, stonesSize,k,k+1,curStep - 1))
            {
                return true;
            }
        }
    }
    return false;
}

int main()
{
    // int a[] = {0,1,3,5,6,8,12,17};
    // int b[] = {0,1,2,3,4,8,9,11};

    while(true){
        int buf[MAX_LEN];
        int index = 0;
        printf("please input array,limited length 1100:\n");
        while(scanf("%d",&buf[index]) && buf[index] >= 0){
           // printf("%d\n",buf[index]);
            ++index;
            if (index >= 1100)
            {
                break;
            }
        }
        printf("length:%d\n", index);
        printf("the result is:%d\n",canCross(buf,index));
    }
    return 1;
}

```

