---
layout: post
title: "R数据整理"
date: 2019-11-29
tag: sas
---









# 27 数据整理

## 27.1 tidyverse系统

假设数据以tibble格式保存（tibble是数据框类型的改进，readr包的`read_csv()`会生成此类）。 数据集经常需要选行子集、选列子集、排序、定义新变量、横向合并等操作， 而且经常会用若干个连续的操作分步处理， magrittr包的管道运算符`%>%`特别适用于这种分步处理。 dplyr包和tidyr包定义了一系列“动词”， 可以用比较自然的方式进行数据整理。

为了使用这些功能，可以载入`tidyverse`包， 则magrittr包，readr包，dplyr包和tidyr包都会被自动载入:

```
library(tidyverse)
```

下面的例子中用如下的一个班的学生数据作为例子， 保存在如下[`class.csv`](http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/class.csv)文件中：

```
name,sex,age,height,weight
Alice,F,13,56.5,84
Becka,F,13,65.3,98
Gail,F,14,64.3,90
Karen,F,12,56.3,77
Kathy,F,12,59.8,84.5
Mary,F,15,66.5,112
Sandy,F,11,51.3,50.5
Sharon,F,15,62.5,112.5
Tammy,F,14,62.8,102.5
Alfred,M,14,69,112.5
Duke,M,14,63.5,102.5
Guido,M,15,67,133
James,M,12,57.3,83
Jeffrey,M,13,62.5,84
John,M,12,59,99.5
Philip,M,16,72,150
Robert,M,12,64.8,128
Thomas,M,11,57.5,85
William,M,15,66.5,112
```

读入为tibble:

```
d.class <- read_csv(
  "class.csv", 
  col_types=cols(
  .default = col_double(),
  name=col_character(),
  sex=col_factor(levels=c("M", "F"))
))
```

R的NHANES扩展包提供了一个规模更大的示例数据框NHANES， 可以看作是美国扣除住院病人以外的人群的一个随机样本， 有10000个观测，有76个变量， 主题是个人的健康与营养方面的信息。 仅作为教学使用而不足以作为严谨的科研用数据。 原始数据的情况详见http://www.cdc.gov/nchs/nhanes.htm。 载入NHANES数据框：

```
library(NHANES)
data(NHANES)
print(dim(NHANES))
## [1] 10000    76
print(names(NHANES))
##  [1] "ID"               "SurveyYr"         "Gender"          
##  [4] "Age"              "AgeDecade"        "AgeMonths"       
##  [7] "Race1"            "Race3"            "Education"       
## [10] "MaritalStatus"    "HHIncome"         "HHIncomeMid"     
## [13] "Poverty"          "HomeRooms"        "HomeOwn"         
## [16] "Work"             "Weight"           "Length"          
## [19] "HeadCirc"         "Height"           "BMI"             
## [22] "BMICatUnder20yrs" "BMI_WHO"          "Pulse"           
## [25] "BPSysAve"         "BPDiaAve"         "BPSys1"          
## [28] "BPDia1"           "BPSys2"           "BPDia2"          
## [31] "BPSys3"           "BPDia3"           "Testosterone"    
## [34] "DirectChol"       "TotChol"          "UrineVol1"       
## [37] "UrineFlow1"       "UrineVol2"        "UrineFlow2"      
## [40] "Diabetes"         "DiabetesAge"      "HealthGen"       
## [43] "DaysPhysHlthBad"  "DaysMentHlthBad"  "LittleInterest"  
## [46] "Depressed"        "nPregnancies"     "nBabies"         
## [49] "Age1stBaby"       "SleepHrsNight"    "SleepTrouble"    
## [52] "PhysActive"       "PhysActiveDays"   "TVHrsDay"        
## [55] "CompHrsDay"       "TVHrsDayChild"    "CompHrsDayChild" 
## [58] "Alcohol12PlusYr"  "AlcoholDay"       "AlcoholYear"     
## [61] "SmokeNow"         "Smoke100"         "Smoke100n"       
## [64] "SmokeAge"         "Marijuana"        "AgeFirstMarij"   
## [67] "RegularMarij"     "AgeRegMarij"      "HardDrugs"       
## [70] "SexEver"          "SexAge"           "SexNumPartnLife" 
## [73] "SexNumPartYear"   "SameSex"          "SexOrientation"  
## [76] "PregnantNow"
```

变量ID是受试者编号， SurveyYr是调查年份， 同一受试者可能在多个调查年份中有数据。 变量中包括性别、年龄、种族、收入等人口学数据， 包括体重、身高、脉搏、血压等基本体检数据， 以及是否糖尿病、是否抑郁、是否怀孕、已生产子女数等更详细的健康数据， 运动习惯、饮酒、性生活等行为方面的数据。 这个教学用数据集最初的使用者是Cashmere高中的Michelle Dalrymple 和新西兰奥克兰大学的Chris Wild。

## 27.2 用`filter()`选择行子集

数据框的任何行子集仍为数据框，即使只有一行而且都是数值也是如此。 行子集可以用行下标选取， 如`d.class[8:12,]`。 函数`head()`取出数据框的前面若干行， `tail()`取出数据框的最后若干行。

dplyr包的`filter()`函数可以按条件选出符合条件的行组成的子集。 下例从`d.class`中选出年龄在13岁和13岁以下的女生：

```
d.class %>%
  filter(sex=="F", age<=13)
## # A tibble: 5 x 5
##   name  sex     age height weight
##   <chr> <fct> <dbl>  <dbl>  <dbl>
## 1 Alice F        13   56.5   84  
## 2 Becka F        13   65.3   98  
## 3 Karen F        12   56.3   77  
## 4 Kathy F        12   59.8   84.5
## 5 Sandy F        11   51.3   50.5
```

`filter()`函数第一个参数是要选择的数据框， 后续的参数是条件， 这些条件是需要同时满足的， 另外， 条件中取缺失值的观测自动放弃。 `filter()`会自动舍弃行名， 如果需要行名只能将其转换成数据框的一列。 `filter()`的结果为行子集数据框。 用在管道操作当中的时候第一自变量省略（是管道传递下来的）。

函数`head(x, n)`可以用来选择数据框前面若干行， `tail(x, n)`可以用来选择数据框后面若干行，如：

```
d.class %>%
  head(n=5)
## # A tibble: 5 x 5
##   name  sex     age height weight
##   <chr> <fct> <dbl>  <dbl>  <dbl>
## 1 Alice F        13   56.5   84  
## 2 Becka F        13   65.3   98  
## 3 Gail  F        14   64.3   90  
## 4 Karen F        12   56.3   77  
## 5 Kathy F        12   59.8   84.5
```

dplyr包的函数`slice(.data, ...)`可以用来选择指定序号的行子集， 正的序号表示保留，负的序号表示排除。如：

```
d.class %>%
  slice(3:5)
## # A tibble: 3 x 5
##   name  sex     age height weight
##   <chr> <fct> <dbl>  <dbl>  <dbl>
## 1 Gail  F        14   64.3   90  
## 2 Karen F        12   56.3   77  
## 3 Kathy F        12   59.8   84.5
```

## 27.3 用`sample_n()`对观测随机抽样

dplyr包的`sample_n(tbl, size)`函数可以从数据集`tbl`中随机无放回抽取`size`行，如：

```
d.class %>%
  sample_n(size = 3)
## # A tibble: 3 x 5
##   name   sex     age height weight
##   <chr>  <fct> <dbl>  <dbl>  <dbl>
## 1 Alfred M        14   69     112.
## 2 Robert M        12   64.8   128 
## 3 Philip M        16   72     150
```

`sample_n()`中加选项`replace=TRUE`可以变成有放回抽样。 可以用`weight`选项指定数据框中的一列作为抽样权重， 进行不等概抽样。

## 27.4 用`distinct()`去除重复行

有时我们希望得到一个或若干个变量组合的所有不同值。 dplyr包的`distinct()`函数可以对数据框指定若干变量， 然后筛选出所有不同值， 每组不同值仅保留一行。 指定变量名时是写成字符串形式而是直接写变量名， 这是dplyr和tidyr包的特点。 例如，筛选出性别与年龄的所有不同组合：

```
d.class %>%
  distinct(sex, age)
## # A tibble: 11 x 2
##    sex     age
##    <fct> <dbl>
##  1 F        13
##  2 F        14
##  3 F        12
##  4 F        15
##  5 F        11
##  6 M        14
##  7 M        15
##  8 M        12
##  9 M        13
## 10 M        16
## 11 M        11
```

如果希望保留数据框中其它变量， 可以加选项`.keep_all=TRUE`。

下面的程序查看NHANES数据框中ID与SurveyYr的组合的不同值的个数：

```
NHANES %>%
  distinct(ID, SurveyYr) %>%
  nrow()
## [1] 6779
```

这个结果提示有些人在某一调查年中有多个观测。

## 27.5 用`drop_na()`去除指定的变量有缺失值的行

在进行统计建模时， 通常需要用到的因变量和自变量都不包含缺失值。 tidyr包的`drop_na()`函数可以对数据框指定一到多个变量， 删去指定的变量有缺失值的行。 不指定变量时有任何变量缺失的行都会被删去。

用如

```
d.class %>%
  drop_na(age, height, weight)
```

又如，将NHANES中所有存在缺失值的行删去后数出保留的行数， 原来有10000行：

```
NHANES %>%
  drop_na() %>%
  nrow()
## [1] 0
```

可见所有行都有缺失值。下面仅剔除AlcoholDay缺失的观测并计数：

```
NHANES %>%
  drop_na(AlcoholDay) %>%
  nrow()
## [1] 4914
```

## 27.6 用`select()`选择列子集

dplyr包的`select()`选择列子集，并返回列子集结果。

可以指定变量名，如

```
d.class %>%
  select(name, age)
## # A tibble: 19 x 2
##    name      age
##    <chr>   <dbl>
##  1 Alice      13
##  2 Becka      13
##  3 Gail       14
##  4 Karen      12
##  5 Kathy      12
##  6 Mary       15
##  7 Sandy      11
##  8 Sharon     15
##  9 Tammy      14
## 10 Alfred     14
## 11 Duke       14
## 12 Guido      15
## 13 James      12
## 14 Jeffrey    13
## 15 John       12
## 16 Philip     16
## 17 Robert     12
## 18 Thomas     11
## 19 William    15
```

可以用冒号表示列范围，如

```
d.class %>%
  select(age:weight)
## # A tibble: 19 x 3
##      age height weight
##    <dbl>  <dbl>  <dbl>
##  1    13   56.5   84  
##  2    13   65.3   98  
##  3    14   64.3   90  
##  4    12   56.3   77  
##  5    12   59.8   84.5
##  6    15   66.5  112  
##  7    11   51.3   50.5
##  8    15   62.5  112. 
##  9    14   62.8  102. 
## 10    14   69    112. 
## 11    14   63.5  102. 
## 12    15   67    133  
## 13    12   57.3   83  
## 14    13   62.5   84  
## 15    12   59     99.5
## 16    16   72    150  
## 17    12   64.8  128  
## 18    11   57.5   85  
## 19    15   66.5  112
```

可以用数字序号表示列范围，如

```
d.class %>%
  select(3:5)
## # A tibble: 19 x 3
##      age height weight
##    <dbl>  <dbl>  <dbl>
##  1    13   56.5   84  
##  2    13   65.3   98  
##  3    14   64.3   90  
##  4    12   56.3   77  
##  5    12   59.8   84.5
##  6    15   66.5  112  
##  7    11   51.3   50.5
##  8    15   62.5  112. 
##  9    14   62.8  102. 
## 10    14   69    112. 
## 11    14   63.5  102. 
## 12    15   67    133  
## 13    12   57.3   83  
## 14    13   62.5   84  
## 15    12   59     99.5
## 16    16   72    150  
## 17    12   64.8  128  
## 18    11   57.5   85  
## 19    15   66.5  112
```

参数中前面写负号表示扣除，如

```
d.class %>%
  select(-name, -age)
## # A tibble: 19 x 3
##    sex   height weight
##    <fct>  <dbl>  <dbl>
##  1 F       56.5   84  
##  2 F       65.3   98  
##  3 F       64.3   90  
##  4 F       56.3   77  
##  5 F       59.8   84.5
##  6 F       66.5  112  
##  7 F       51.3   50.5
##  8 F       62.5  112. 
##  9 F       62.8  102. 
## 10 M       69    112. 
## 11 M       63.5  102. 
## 12 M       67    133  
## 13 M       57.3   83  
## 14 M       62.5   84  
## 15 M       59     99.5
## 16 M       72    150  
## 17 M       64.8  128  
## 18 M       57.5   85  
## 19 M       66.5  112
```

如果要选择的变量名已经保存为一个字符型向量， 可以用`one_of()`函数引入，如

```
vars <- c("name", "sex")
d.class %>%
  select(one_of(vars))
## # A tibble: 19 x 2
##    name    sex  
##    <chr>   <fct>
##  1 Alice   F    
##  2 Becka   F    
##  3 Gail    F    
##  4 Karen   F    
##  5 Kathy   F    
##  6 Mary    F    
##  7 Sandy   F    
##  8 Sharon  F    
##  9 Tammy   F    
## 10 Alfred  M    
## 11 Duke    M    
## 12 Guido   M    
## 13 James   M    
## 14 Jeffrey M    
## 15 John    M    
## 16 Philip  M    
## 17 Robert  M    
## 18 Thomas  M    
## 19 William M
```

`select()`有若干个配套函数可以按名字的模式选择变量列， 如

- `starts_with("se"): 选择名字以`“se”`开头的变量列；
- `ends_with("ght"): 选择名字以`“ght”`结尾的变量列；
- `contains("no"): 选择名字中含有子串`“no”`的变量列；
- `matches("^[[:alpha:]]+[[:digit:]]+$")`， 选择列名匹配某个正则表达式模式的变量列， 这里匹配前一部分是字母，后一部分是数字的变量名。
- `num_range("x", 1:3)`，选择`x1`, `x2`, `x3`。
- `everything()`: 代指所有选中的变量， 这可以用来将指定的变量次序提前， 其它变量排在后面。

R的字符串函数（如`paste()`）和正则表达式函数可以用来生成变量名子集。

R函数subset也能对数据框选取列子集和行子集。

如果需要选择单个变量并使得结果为普通向量， 可以用dplyr包的`pull()`函数，如：

```
d.class %>% pull(name)
##  [1] "Alice"   "Becka"   "Gail"    "Karen"   "Kathy"   "Mary"    "Sandy"  
##  [8] "Sharon"  "Tammy"   "Alfred"  "Duke"    "Guido"   "James"   "Jeffrey"
## [15] "John"    "Philip"  "Robert"  "Thomas"  "William"
```

`pull()`可以指定单个变量名， 也可以指定变量序号， 负的变量序号从最后一个变量数起。 缺省取出最后一个变量。

## 27.7 用`arrange()`排序

dplyr包的`arrange()`按照数据框的某一列或某几列排序， 返回排序后的结果，如

```
d.class %>%
  arrange(sex, age)
## # A tibble: 19 x 5
##    name    sex     age height weight
##    <chr>   <fct> <dbl>  <dbl>  <dbl>
##  1 Thomas  M        11   57.5   85  
##  2 James   M        12   57.3   83  
##  3 John    M        12   59     99.5
##  4 Robert  M        12   64.8  128  
##  5 Jeffrey M        13   62.5   84  
##  6 Alfred  M        14   69    112. 
##  7 Duke    M        14   63.5  102. 
##  8 Guido   M        15   67    133  
##  9 William M        15   66.5  112  
## 10 Philip  M        16   72    150  
## 11 Sandy   F        11   51.3   50.5
## 12 Karen   F        12   56.3   77  
## 13 Kathy   F        12   59.8   84.5
## 14 Alice   F        13   56.5   84  
## 15 Becka   F        13   65.3   98  
## 16 Gail    F        14   64.3   90  
## 17 Tammy   F        14   62.8  102. 
## 18 Mary    F        15   66.5  112  
## 19 Sharon  F        15   62.5  112.
```

用`desc()`包裹想要降序排列的变量，如

```
d.class %>%
  arrange(sex, desc(age))
## # A tibble: 19 x 5
##    name    sex     age height weight
##    <chr>   <fct> <dbl>  <dbl>  <dbl>
##  1 Philip  M        16   72    150  
##  2 Guido   M        15   67    133  
##  3 William M        15   66.5  112  
##  4 Alfred  M        14   69    112. 
##  5 Duke    M        14   63.5  102. 
##  6 Jeffrey M        13   62.5   84  
##  7 James   M        12   57.3   83  
##  8 John    M        12   59     99.5
##  9 Robert  M        12   64.8  128  
## 10 Thomas  M        11   57.5   85  
## 11 Mary    F        15   66.5  112  
## 12 Sharon  F        15   62.5  112. 
## 13 Gail    F        14   64.3   90  
## 14 Tammy   F        14   62.8  102. 
## 15 Alice   F        13   56.5   84  
## 16 Becka   F        13   65.3   98  
## 17 Karen   F        12   56.3   77  
## 18 Kathy   F        12   59.8   84.5
## 19 Sandy   F        11   51.3   50.5
```

排序时不论升序还是降序， 所有的缺失值都自动排到末尾。

R函数`order()`可以用来给出数据框的排序次序从而将数据框排序。

## 27.8 用`rename()`修改变量名

在dplyr包的`rename()`中用“新名字=旧名字”格式修改变量名， 如

```
d2.class <- d.class %>%
  rename(h=height, w=weight)
```

注意这样改名字不是对原始数据框修改而是返回改了名字后的新数据框。

## 27.9 用`mutate()`计算新变量

dplyr包的`mutate()`可以为数据框计算新变量， 返回含有新变量以及原变量的数据框。 如

```
d.class %>%
  mutate(
    rwh=weight/height, 
    sexc=ifelse(sex=="F", "女", "男"))
## # A tibble: 19 x 7
##    name    sex     age height weight   rwh sexc 
##    <chr>   <fct> <dbl>  <dbl>  <dbl> <dbl> <chr>
##  1 Alice   F        13   56.5   84   1.49  女   
##  2 Becka   F        13   65.3   98   1.50  女   
##  3 Gail    F        14   64.3   90   1.40  女   
##  4 Karen   F        12   56.3   77   1.37  女   
##  5 Kathy   F        12   59.8   84.5 1.41  女   
##  6 Mary    F        15   66.5  112   1.68  女   
##  7 Sandy   F        11   51.3   50.5 0.984 女   
##  8 Sharon  F        15   62.5  112.  1.8   女   
##  9 Tammy   F        14   62.8  102.  1.63  女   
## 10 Alfred  M        14   69    112.  1.63  男   
## 11 Duke    M        14   63.5  102.  1.61  男   
## 12 Guido   M        15   67    133   1.99  男   
## 13 James   M        12   57.3   83   1.45  男   
## 14 Jeffrey M        13   62.5   84   1.34  男   
## 15 John    M        12   59     99.5 1.69  男   
## 16 Philip  M        16   72    150   2.08  男   
## 17 Robert  M        12   64.8  128   1.98  男   
## 18 Thomas  M        11   57.5   85   1.48  男   
## 19 William M        15   66.5  112   1.68  男
```

用`mutate()`计算新变量时如果计算比较复杂， 也可以用多个语句组成复合语句，如：

```
d.class %>%
  mutate(
    sexc = {
      x <- rep("男", length(sex))
      x[sex == "F"] <- "女"
      x
    }
  )
## # A tibble: 19 x 6
##    name    sex     age height weight sexc 
##    <chr>   <fct> <dbl>  <dbl>  <dbl> <chr>
##  1 Alice   F        13   56.5   84   女   
##  2 Becka   F        13   65.3   98   女   
##  3 Gail    F        14   64.3   90   女   
##  4 Karen   F        12   56.3   77   女   
##  5 Kathy   F        12   59.8   84.5 女   
##  6 Mary    F        15   66.5  112   女   
##  7 Sandy   F        11   51.3   50.5 女   
##  8 Sharon  F        15   62.5  112.  女   
##  9 Tammy   F        14   62.8  102.  女   
## 10 Alfred  M        14   69    112.  男   
## 11 Duke    M        14   63.5  102.  男   
## 12 Guido   M        15   67    133   男   
## 13 James   M        12   57.3   83   男   
## 14 Jeffrey M        13   62.5   84   男   
## 15 John    M        12   59     99.5 男   
## 16 Philip  M        16   72    150   男   
## 17 Robert  M        12   64.8  128   男   
## 18 Thomas  M        11   57.5   85   男   
## 19 William M        15   66.5  112   男
```

注意这样生成新变量不是在原来的数据框中添加， 原来的数据框没有被修改， 而是返回添加了新变量的新数据框。 R软件的巧妙设计保证了这样虽然是生成了新数据框， 但是与原来数据框重复的列并不会重复保存。

计算公式中可以包含对数据框中变量的统计函数结果，如

```
d.class %>%
  mutate(
    cheight = height - mean(height))
```

新变量可以与老变量名相同， 这样就在输出中修改了老变量。

函数`transmute()`用法与`mutate()`类似， 但是仅保留新定义的变量， 不保留原来的所有变量。 如：

```
d.class %>%
  transmute(
    stdh = scale(height),
    stdw = scale(weight)  )
```

可见结果中仅保留了新定义的变量。

定义新变量也可以直接为数据框的新变量赋值：

```
d.class[["rwh"]] <- d.class[["weight"]] / d.class[["height"]]
```

这样的做法与`mutate()`的区别是这样不会生成新数据框， 新变量是在原数据框中增加的。

给数据框中某个变量赋值为`NULL`可以修改数据框， 从数据框中删去该变量。

## 27.10 用管道连接多次操作

管道运算符特别适用于对同一数据集进行多次操作。 例如，对`t.class`数据，先选出所有女生， 再去掉性别和age变量：

```
d.class %>%
  filter(sex=="F") %>%
  select(-sex, -age)
## # A tibble: 9 x 4
##   name   height weight   rwh
##   <chr>   <dbl>  <dbl> <dbl>
## 1 Alice    56.5   84   1.49 
## 2 Becka    65.3   98   1.50 
## 3 Gail     64.3   90   1.40 
## 4 Karen    56.3   77   1.37 
## 5 Kathy    59.8   84.5 1.41 
## 6 Mary     66.5  112   1.68 
## 7 Sandy    51.3   50.5 0.984
## 8 Sharon   62.5  112.  1.8  
## 9 Tammy    62.8  102.  1.63
```

管道操作的结果可以保存为新的tibble，如:

```
class_F <- d.class %>%
  filter(sex=="F") %>%
  select(-sex, -age)
```

## 27.11 数据简单汇总

dplyr包的`summarise()`函数可以对数据框计算统计量。 这个函数针对少量变量时很方便， 有大量变量需要对变量统一处理时不太方便。

以肺癌病人化疗数据[`cancer.csv`](http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/cancer.csv)为例， 有34个肺癌病人的数据：

```
d.cancer <- read_csv(
  "cancer.csv", locale=locale(encoding="GBK"))
## Parsed with column specification:
## cols(
##   id = col_double(),
##   age = col_double(),
##   sex = col_character(),
##   type = col_character(),
##   v0 = col_double(),
##   v1 = col_double()
## )
d.cancer
## # A tibble: 34 x 6
##       id   age sex   type     v0     v1
##    <dbl> <dbl> <chr> <chr> <dbl>  <dbl>
##  1     1    70 F     腺癌   26.5   2.91
##  2     2    70 F     腺癌  135.   35.1 
##  3     3    69 F     腺癌  210.   74.4 
##  4     4    68 M     腺癌   61    35.0 
##  5     5    67 M     鳞癌  238.  128.  
##  6     6    75 F     腺癌  330.  112.  
##  7     7    52 M     鳞癌  105.   32.1 
##  8     8    71 M     鳞癌   85.2  29.2 
##  9     9    68 M     鳞癌  102.   22.2 
## 10    10    79 M     鳞癌   65.5  21.9 
## # ... with 24 more rows
```

求年龄(age)的平均值、标准差：

```
d.cancer %>%
  summarise(mean.age=mean(age, na.rm=TRUE),
            sd.age=sd(age, na.rm=TRUE))
## # A tibble: 1 x 2
##   mean.age sd.age
##      <dbl>  <dbl>
## 1     64.1   9.16
```

更重要的是分组汇总。 dplyr包的`group_by()`函数对数据框（或tibble）分组， 随后的`summarise()`将按照分组汇总。 比如， 按不同性别计算人数与年龄平均值：

```
d.cancer %>%
  group_by(sex) %>%
  summarise(count=n(), mean.age=mean(age, na.rm=TRUE))
## # A tibble: 2 x 3
##   sex   count mean.age
##   <chr> <int>    <dbl>
## 1 F        13     66.1
## 2 M        21     63.2
```

其中`n()`计算某类的观测数（行数）。 为了计算某列的非缺失值个数，用`sum(!is.na(x))`。

常用的汇总函数有：

- 位置度量：`mean()`, `median()`。
- 分散程度（变异性）度量：`sd()`, `IQR()`, `mad()`。
- 分位数：`min()`, `max()`, `quantile()`。
- 按下标查询，如`first(x)`取出`x[1]`， `last(x)`取出`x`的最后一个元素， `nth(x,2)`取出`x[2]`。 可以提供一个缺省值以防某个下标位置不存在。
- 计数：`n()`给出某个组的观测数， `sum(!is.na(x))`统计`x`的非缺失值个数， `n_distinct(x)`统计`x`的不同值个数(缺失值也算一个值)。 `count(x)`给出`x`的每个不同值的个数（类似于`table()`函数）。

这里有些函数是dplyr包提供的， 仅适用于tibble类型。

下面的程序对d.cancer数据框分性别与病理类型分别统计人数：

```
d.cancer %>%
  group_by(sex, type) %>%
  summarise(freq=n())
## # A tibble: 4 x 3
## # Groups:   sex [2]
##   sex   type   freq
##   <chr> <chr> <int>
## 1 F     鳞癌      4
## 2 F     腺癌      9
## 3 M     鳞癌     18
## 4 M     腺癌      3
```

在有交叉分类时， `n()`、`mean()`这些汇总函数是针对最内层进行汇总， 汇总后最内层的分类变量不再当作分类。 比如， 上述结果仍按照sex分类， 但不再按照type分类。

事实上，不需要用`group_by()`， 交叉分类计算频数可以用dplyr的`count()`函数，如：

```
d.cancer %>%
  count(sex, type)
## # A tibble: 4 x 3
##   sex   type      n
##   <chr> <chr> <int>
## 1 F     鳞癌      4
## 2 F     腺癌      9
## 3 M     鳞癌     18
## 4 M     腺癌      3
```

又如，数出NHANES数据框中ID与SurveyYr每一对组合的出现次数, 筛选出二次及以上者，并降序排列，仅显示前100行结果：

```
NHANES %>%
  count(ID, SurveyYr) %>%
  filter(n >=2 ) %>%
  arrange(desc(n)) %>%
  head(100)
## # A tibble: 100 x 3
##       ID SurveyYr     n
##    <int> <fct>    <int>
##  1 70324 2011_12      8
##  2 62927 2011_12      7
##  3 63297 2011_12      7
##  4 69626 2011_12      7
##  5 60566 2009_10      6
##  6 61442 2009_10      6
##  7 63163 2011_12      6
##  8 63330 2011_12      6
##  9 63390 2011_12      6
## 10 63744 2011_12      6
## # ... with 90 more rows
```

用`group_by()`分组后除了可以分组汇总， 还可以分组筛选：

```
d.cancer %>%
  group_by(sex) %>%
  filter(rank(desc(v0)) <= 2) %>%
  arrange(sex, desc(v0))
## # A tibble: 4 x 6
## # Groups:   sex [2]
##      id   age sex   type     v0    v1
##   <dbl> <dbl> <chr> <chr> <dbl> <dbl>
## 1     6    75 F     腺癌   330. 112. 
## 2    25    NA F     鳞癌   223   25.6
## 3     5    67 M     鳞癌   238. 128. 
## 4    16    76 M     鳞癌   231. 113.
```

以上程序按性别分组后， 在每组中找出疗前体积排名在前两名的。

在分组后也可以根据每组的统计量用`mutate()`定义新变量。

用`group_by()`分组汇总后的结果不是普通的tibble， 总是带有分组信息。 这在后续的使用中可能会产生问题， 为此， 可以用`ungroup()`函数取消分组。 例如

```
d.cancer %>%
  group_by(sex, type) %>%
  summarise(freq=n()) %>%
  summarise(ntotal=sum(freq))
## # A tibble: 2 x 2
##   sex   ntotal
##   <chr>  <int>
## 1 F         13
## 2 M         21
```

可以看出并没有能够通过男、女分别的人数计算总人数。加入`ungroup()`：

```
d.cancer %>%
  group_by(sex, type) %>%
  summarise(freq=n()) %>%
  ungroup() %>%
  summarise(ntotal=sum(freq))
## # A tibble: 1 x 1
##   ntotal
##    <int>
## 1     34
```

得到了需要的结果。

## 27.12 长宽表转换

考虑如下的宽表，保存在CSV文件[`widetab.csv`](http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/widetab.csv)中：

```
"subject","x_1","x_2","x_3","y_1","y_2","y_3"
1,5,7,8,9,7,6
2,8,2,10,1,1,9
3,7,2,5,10,8,3
4,1,5,6,10,1,1
5,9,7,10,8,8,10
```

这个数据是5名病人3次检查的记录，每次检查有x和y两个测量项目。 每个病人的所有各次检查以及所有测量项目都在同一行， 称这样的表为宽表。读入为

```
d.wide <- read_csv("widetab.csv")
## Parsed with column specification:
## cols(
##   subject = col_double(),
##   x_1 = col_double(),
##   x_2 = col_double(),
##   x_3 = col_double(),
##   y_1 = col_double(),
##   y_2 = col_double(),
##   y_3 = col_double()
## )
```

现在希望将其中的时间分离出来， 不同时间变成不同的观测，每个病人的三次检查转换成三个观测。 tidyr包的`gather()`函数将宽表变成长表，但是将不同测量项目也转换到了不同的行：

```
d.wide %>%
  gather(x_1, x_2, x_3, y_1, y_2, y_3, key="variable", value="value")
## # A tibble: 30 x 3
##    subject variable value
##      <dbl> <chr>    <dbl>
##  1       1 x_1          5
##  2       2 x_1          8
##  3       3 x_1          7
##  4       4 x_1          1
##  5       5 x_1          9
##  6       1 x_2          7
##  7       2 x_2          2
##  8       3 x_2          2
##  9       4 x_2          5
## 10       5 x_2          7
## # ... with 20 more rows
```

tidyr包的`separate()`可以用来帮助拆分`x_1`, `y_1`这样的名字， 这样可以将测量项目名称与时间分离开来， 如：

```
d.wide %>%
  gather(x_1, x_2, x_3, y_1, y_2, y_3, key="variable", value="value") %>%
  separate(variable, into=c("variable", "time"), sep="_")
## # A tibble: 30 x 4
##    subject variable time  value
##      <dbl> <chr>    <chr> <dbl>
##  1       1 x        1         5
##  2       2 x        1         8
##  3       3 x        1         7
##  4       4 x        1         1
##  5       5 x        1         9
##  6       1 x        2         7
##  7       2 x        2         2
##  8       3 x        2         2
##  9       4 x        2         5
## 10       5 x        2         7
## # ... with 20 more rows
```

tidyr包的函数`spread()`可以将用变量名和变量值分别存储的变量， 恢复为每个变量一列的形式， 如：

```
d.wide %>%
  gather(x_1, x_2, x_3, y_1, y_2, y_3, key="variable", value="value") %>%
  separate(variable, into=c("variable", "time"), sep="_") %>%
  spread(key=variable, value=value)
## # A tibble: 15 x 4
##    subject time      x     y
##      <dbl> <chr> <dbl> <dbl>
##  1       1 1         5     9
##  2       1 2         7     7
##  3       1 3         8     6
##  4       2 1         8     1
##  5       2 2         2     1
##  6       2 3        10     9
##  7       3 1         7    10
##  8       3 2         2     8
##  9       3 3         5     3
## 10       4 1         1    10
## 11       4 2         5     1
## 12       4 3         6     1
## 13       5 1         9     8
## 14       5 2         7     8
## 15       5 3        10    10
```

这个结果已经变成每个病人每次检查为一个观测（记录）的形式。

如果变量名不像`x_1`, `y_3`这样整齐， 为了拆分变量名与时间，也可以用字符串函数。 比如，我们将d.wide中变量`x_1`改名为`x1`, `x_3`改名为`x3`, `y_1`改名为`abc1`， 删去其它变量：

```
d.wide %>%
  select(subject, x_1, x_3, y_1) %>%
  rename(x1=x_1, x3=x_3, abc1=y_1)
## # A tibble: 5 x 4
##   subject    x1    x3  abc1
##     <dbl> <dbl> <dbl> <dbl>
## 1       1     5     8     9
## 2       2     8    10     1
## 3       3     7     5    10
## 4       4     1     6    10
## 5       5     9    10     8
```

要将上述数据的变量与时间信息分离， 因为没有变量名与时间之间没有明确的分隔符也没有固定宽度， `separate()`函数难以分离这样的变量名与时间， 可以利用正则表达式：

```
d.wide %>%
  select(subject, x_1, x_3, y_1) %>%
  rename(x1=x_1, x3=x_3, abc1=y_1) %>%
  gather(x1, x3, abc1, key="variable", value="value") %>%
  mutate(time=as.numeric(gsub("^([[:alpha:]]+)([[:digit:]]+)$", "\\2", variable)),
         variable=gsub("^([[:alpha:]]+)([[:digit:]]+)$", "\\1", variable)) %>%
  spread(key=variable, value=value)
## # A tibble: 10 x 4
##    subject  time   abc     x
##      <dbl> <dbl> <dbl> <dbl>
##  1       1     1     9     5
##  2       1     3    NA     8
##  3       2     1     1     8
##  4       2     3    NA    10
##  5       3     1    10     7
##  6       3     3    NA     5
##  7       4     1    10     1
##  8       4     3    NA     6
##  9       5     1     8     9
## 10       5     3    NA    10
```

tidyr包还有一些方便函数。 长宽表转换问题中的某些数据是缺失的， 这些缺失值在某些形式中可见， 如上表中变量abc在time=3时的值， 在某些形式中根本没有表现出来。 在用`gather()`将宽表变长表时， 可以加`na.rm=TRUE`选项将不必要的缺失值观测删去。 函数`complete()`可以指定若干列， 使得这些列的所有不同组合均出现。 有时某个单元格缺失是表示该值等于其上一行的值， 这时可以用函数`fill()`指定该列按照这样的规则填充值。

## 27.13 拆分数据列

有时应该放在不同列的数据用分隔符分隔后放在同一列中了。 比如，下面数据集中“succ/total”列存放了用“/”分隔开的成功数与试验数：

```
d.sep <- read_csv(
"testid, succ/total
1, 1/10
2, 3/5
3, 2/8
")
d.sep
## # A tibble: 3 x 2
##   testid `succ/total`
##    <dbl> <chr>       
## 1      1 1/10        
## 2      2 3/5         
## 3      3 2/8
```

用`tidyr::separate()`可以将这样的列拆分为各自的变量列，如

```
d.sep %>%
  separate(`succ/total`, into=c("succ", "total"), 
           sep="/", convert=TRUE)
## # A tibble: 3 x 3
##   testid  succ total
##    <dbl> <int> <int>
## 1      1     1    10
## 2      2     3     5
## 3      3     2     8
```

其中`into`指定拆分后新变量名， `sep`指定分隔符， `convert=TRUE`要求自动将分割后的值转换为适当的类型。 `sep`还可以指定取子串的字符位置， 按位置拆分各个子串。

选项`extra`指出拆分时有多余内容的处理方法， 选项`fill`指出有不足内容的处理方法。

函数`extract()`可以按照某种正则表达式表示的模式从指定列拆分出对应于正则表达式中捕获组的一列或多列内容。

## 27.14 合并数据列

`tidyr::unite()`函数可以将同一行的两列或多列的内容合并成一列。 这是`separate()`的反向操作， 如：

```
d.sep %>%
  separate(`succ/total`, into=c("succ", "total"), 
           sep="/", convert=TRUE) %>%
  unite(ratio, succ, total, sep=":")
## # A tibble: 3 x 2
##   testid ratio
##    <dbl> <chr>
## 1      1 1:10 
## 2      2 3:5  
## 3      3 2:8
```

`unite()`的第一个参数是要修改的数据框， 这里用管道`%>%`传递进来， 第二个参数是合并后的变量名（`ratio`变量）， 其它参数是要合并的变量名，`sep`指定分隔符。 实际上用`mutate()`、`paste()`或者`sprintf()`也能完成合并。

## 27.15 横向合并

实际数据往往没有存放在单一的表中， 需要从多个表查找数据。 多个表之间的连接， 一般靠关键列（key）对准来连接。 连接可以是一对一的， 一对多的。 多对多连接应用较少， 因为多对多连接是所有两两组合。

在规范的数据库中，每个表都应该有主键， 这可以是一列，也可以是多列的组合。 为了确定某列是主键， 可以用`count()`和`filter()`，如

```
d.class %>%
  count(name) %>%
  filter(n>1)
## # A tibble: 0 x 2
## # ... with 2 variables: name <chr>, n <int>
```

没有发现重复出现的`name`， 说明`d.class`中`name`可以作为主键。

为了演示一对一的横向连接，我们将d.class拆分为两个数据集d1.class和d2.class, 两个数据集都有主键`name`， d1.class包含变量`name`, `sex`, d2.class包含变量`name`, `age`, `height`, `weight`, 并删去某些观测：

```
d1.class <- d.class %>%
  select(name, sex) %>%
  filter(!(name %in%  "Becka"))
d2.class <- d.class %>%
  select(name, age, height, weight)
```

用dplyr包的`inner_join()`函数将两个数据框按键值横向合并， 仅保留能匹配的观测。因为d1.class中丢失了Becka的观测， 所以合并后的数据框中也没有Becka的观测：

```
d1.class %>%
  inner_join(d2.class)
## Joining, by = "name"
## # A tibble: 18 x 5
##    name    sex     age height weight
##    <chr>   <fct> <dbl>  <dbl>  <dbl>
##  1 Alice   F        13   56.5   84  
##  2 Gail    F        14   64.3   90  
##  3 Karen   F        12   56.3   77  
##  4 Kathy   F        12   59.8   84.5
##  5 Mary    F        15   66.5  112  
##  6 Sandy   F        11   51.3   50.5
##  7 Sharon  F        15   62.5  112. 
##  8 Tammy   F        14   62.8  102. 
##  9 Alfred  M        14   69    112. 
## 10 Duke    M        14   63.5  102. 
## 11 Guido   M        15   67    133  
## 12 James   M        12   57.3   83  
## 13 Jeffrey M        13   62.5   84  
## 14 John    M        12   59     99.5
## 15 Philip  M        16   72    150  
## 16 Robert  M        12   64.8  128  
## 17 Thomas  M        11   57.5   85  
## 18 William M        15   66.5  112
```

横向连接自动找到了共同的变量`name`作为连接的键值， 可以在`inner_join()`中用`by=`指定键值变量名， 如果有不同的变量名， 可以用`by = c("a"="b")`的格式指定左数据框的键值a与右数据框的键值b匹配进行连接。

两个表的横向连接， 经常是多对一连接。 例如， `d.stu`中有学生学号、班级号、姓名、性别， `d.cl`中有班级号、班主任名、年级， 可以通过班级号将两个表连接起来：

```
d.stu <- tibble(
  sid=c(1,2,3,4,5,6),
  cid=c(1,2,1,2,1,2),
  sname=c("John", "Mary", "James", "Kitty", "Jasmine", "Kim"),
  sex=c("M", "F", "M", "F", "F", "M"))
d.stu
## # A tibble: 6 x 4
##     sid   cid sname   sex  
##   <dbl> <dbl> <chr>   <chr>
## 1     1     1 John    M    
## 2     2     2 Mary    F    
## 3     3     1 James   M    
## 4     4     2 Kitty   F    
## 5     5     1 Jasmine F    
## 6     6     2 Kim     M
d.cl <- tibble(
  cid=c(1,2),
  tname=c("Philip", "Joane"),
  grade=c("2017", "2016")
)
d.cl
## # A tibble: 2 x 3
##     cid tname  grade
##   <dbl> <chr>  <chr>
## 1     1 Philip 2017 
## 2     2 Joane  2016
d.stu %>%
  left_join(d.cl, by="cid")
## # A tibble: 6 x 6
##     sid   cid sname   sex   tname  grade
##   <dbl> <dbl> <chr>   <chr> <chr>  <chr>
## 1     1     1 John    M     Philip 2017 
## 2     2     2 Mary    F     Joane  2016 
## 3     3     1 James   M     Philip 2017 
## 4     4     2 Kitty   F     Joane  2016 
## 5     5     1 Jasmine F     Philip 2017 
## 6     6     2 Kim     M     Joane  2016
```

`left_join()`按照`by`变量指定的关键列匹配观测， 左数据集所有观测不论匹配与否全部保留， 右数据集仅使用与左数据集能匹配的观测。 不指定`by`变量时， 使用左、右数据集的共同列作为关键列。 如果左右数据集关键列变量名不同， 可以用`by=c("左名"="右名")`的格式。

类似地， `right_join()`保留右数据集的所有观测， 而仅保留左数据集中能匹配的观测。 `full_join()`保留所有观测。 `inner_join()`仅保留能匹配的观测。

## 27.16 利用第二个数据集筛选

`left_join()`将右表中与左表匹配的观测的额外的列添加到左表中。 如果希望按照右表筛选左表的观测， 可以用`semi_join()`， 函数`anti_join()`则是要求保留与右表不匹配的观测。

## 27.17 数据集的集合操作

R的`intersect()`，`union()`, `setdiff()`本来是以向量作为集合进行集合操作。 dplyr包也提供了这些函数， 但是将两个tibble的各行作为元素进行集合操作。

## 27.18 数据框纵向合并

矩阵或数据框要纵向合并，使用`rbind`函数即可。 要求变量集合是相同的，变量次序可以不同。

比如，有如下两个分开男生、女生的数据框：

```
d3.class <- d.class %>%
  select(name, sex, age) %>%
  filter(sex=="M")
d4.class <- d.class %>%
  select(name, sex, age) %>%
  filter(sex=="F")
```

合并行如下:

```
rbind(d3.class, d4.class)
## # A tibble: 19 x 3
##    name    sex     age
##    <chr>   <fct> <dbl>
##  1 Alfred  M        14
##  2 Duke    M        14
##  3 Guido   M        15
##  4 James   M        12
##  5 Jeffrey M        13
##  6 John    M        12
##  7 Philip  M        16
##  8 Robert  M        12
##  9 Thomas  M        11
## 10 William M        15
## 11 Alice   F        13
## 12 Becka   F        13
## 13 Gail    F        14
## 14 Karen   F        12
## 15 Kathy   F        12
## 16 Mary    F        15
## 17 Sandy   F        11
## 18 Sharon  F        15
## 19 Tammy   F        14
```

将下面的数据框的变量列次序打乱， 合并不受影响：

```
rbind(d3.class, d4.class[, c("age", "name", "sex")])
## # A tibble: 19 x 3
##    name    sex     age
##    <chr>   <fct> <dbl>
##  1 Alfred  M        14
##  2 Duke    M        14
##  3 Guido   M        15
##  4 James   M        12
##  5 Jeffrey M        13
##  6 John    M        12
##  7 Philip  M        16
##  8 Robert  M        12
##  9 Thomas  M        11
## 10 William M        15
## 11 Alice   F        13
## 12 Becka   F        13
## 13 Gail    F        14
## 14 Karen   F        12
## 15 Kathy   F        12
## 16 Mary    F        15
## 17 Sandy   F        11
## 18 Sharon  F        15
## 19 Tammy   F        14
```

## 27.19 标准化

设x是各列都为数值的列表(包括数据框和tibble)或数值型矩阵， 用`scale(x)`可以把每一列都标准化， 即每一列都减去该列的平均值，然后除以该列的样本标准差。 用`scale(x, center=TRUE, scale=FALSE)`仅中心化而不标准化。 如

```
d.class %>% 
  select(height, weight) %>%
  scale()
##            height      weight
##  [1,] -1.13843504 -0.70371312
##  [2,]  0.57794313 -0.08897522
##  [3,]  0.38290015 -0.44025402
##  [4,] -1.17744363 -1.01108207
##  [5,] -0.49479323 -0.68175819
##  [6,]  0.81199469  0.52576268
##  [7,] -2.15265850 -2.17469309
##  [8,]  0.03182280  0.54771760
##  [9,]  0.09033569  0.10861910
## [10,]  1.29960213  0.54771760
## [11,]  0.22686577  0.10861910
## [12,]  0.90951618  1.44786952
## [13,] -0.98240066 -0.74762297
## [14,]  0.03182280 -0.70371312
## [15,] -0.65082761 -0.02311045
## [16,]  1.88473105  2.19433697
## [17,]  0.48042164  1.22832027
## [18,] -0.94339207 -0.65980327
## [19,]  0.81199469  0.52576268
## attr(,"scaled:center")
##    height    weight 
##  62.33684 100.02632 
## attr(,"scaled:scale")
##    height    weight 
##  5.127075 22.773933
```

为了把`x`的每列变到内，可以用如下的方法：

```
d.class %>% 
  select(height, weight) %>%
  scale(center=apply(., 2, min),
      scale=apply(., 2, max) - apply(., 2, min))
```

其中的`.`在管道操作中表示被传递处理的变量（一般是数据框）。 也可以写一个自定义的进行零一标准化的函数：

```
scale01 <- function(x){
  mind <- apply(x, 2, min)
  maxd <- apply(x, 2, max)
  scale(x, center=mind, scale=maxd-mind)
}
d.class %>% 
  select(height, weight) %>%
  scale01
##          height    weight
##  [1,] 0.2512077 0.3366834
##  [2,] 0.6763285 0.4773869
##  [3,] 0.6280193 0.3969849
##  [4,] 0.2415459 0.2663317
##  [5,] 0.4106280 0.3417085
##  [6,] 0.7342995 0.6180905
##  [7,] 0.0000000 0.0000000
##  [8,] 0.5410628 0.6231156
##  [9,] 0.5555556 0.5226131
## [10,] 0.8550725 0.6231156
## [11,] 0.5893720 0.5226131
## [12,] 0.7584541 0.8291457
## [13,] 0.2898551 0.3266332
## [14,] 0.5410628 0.3366834
## [15,] 0.3719807 0.4924623
## [16,] 1.0000000 1.0000000
## [17,] 0.6521739 0.7788945
## [18,] 0.2995169 0.3467337
## [19,] 0.7342995 0.6180905
## attr(,"scaled:center")
## height weight 
##   51.3   50.5 
## attr(,"scaled:scale")
## height weight 
##   20.7   99.5
```

注意在管道操作中某个操作除了被传递的第一自变量外没有其它自变量时， 可以不写函数调用的空括号`()`。

函数`sweep()`可以执行对每列更一般的变换。

## 27.20 用`reshape`包做长宽表转换

前面已经讲到， 用tidyr的`gather()`、`separate()`、`spread()`等函数可以进行长宽表的转换。 reshape包是另一个可以进行长宽表转换的扩展包， 这里列出其使用方法作为参考， 建议主要使用tidyr的方法。

设数据框`d.long`变量为subject(病人号，有5个不同值)， `time`(随访序号，取1,2,3)， 变量`x`, y(每个病人每次随访的两个测量指标值)。 数据框有个观测（行）。 数据在如下的[`longtab.csv`](http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/longtab.csv)中：

```
subject,time,x,y
1,1,5,9
1,2,7,7
1,3,8,6
2,1,8,1
2,2,2,1
2,3,10,9
3,1,7,10
3,2,2,8
3,3,5,3
4,1,1,10
4,2,5,1
4,3,6,1
5,1,9,8
5,2,7,8
5,3,10,10
```

读入：

```
d.long <- as.data.frame(read_csv('longtab.csv'))
## Parsed with column specification:
## cols(
##   subject = col_double(),
##   time = col_double(),
##   x = col_double(),
##   y = col_double()
## )
```

(reshape包对tibble类型支持不好，所以转换成普通的数据框)

实际中，常常需要把每个病人的3次随访的6个测量指标合并到一行当中， 这称为长表变宽表问题； 反之则称为宽表变长表问题。

原始数据列表如下：

```
knitr::kable(d.long)
```

| subject | time | x    | y    |
| ------- | ---- | ---- | ---- |
| 1       | 1    | 5    | 9    |
| 1       | 2    | 7    | 7    |
| 1       | 3    | 8    | 6    |
| 2       | 1    | 8    | 1    |
| 2       | 2    | 2    | 1    |
| 2       | 3    | 10   | 9    |
| 3       | 1    | 7    | 10   |
| 3       | 2    | 2    | 8    |
| 3       | 3    | 5    | 3    |
| 4       | 1    | 1    | 10   |
| 4       | 2    | 5    | 1    |
| 4       | 3    | 6    | 1    |
| 5       | 1    | 9    | 8    |
| 5       | 2    | 7    | 8    |
| 5       | 3    | 10   | 10   |

### 27.20.1 用`melt()`融化

reshape包用`melt()`函数把数据框转换为一个容易变形的格式， 称为“融化”。 `melt()`函数把变量分为两种：分组用（`id.var`），测量用（`measure.var`）。 融化保持分组不变， 但是将所有的测量变量合并到一列中， 列名为`value`； 相应的变量名保存到一列中， 列名为`variable`。

如下程序把d.long转化为“融化”格式：

```
library(reshape)
## 
## 载入程辑包：'reshape'
## The following object is masked from 'package:dplyr':
## 
##     rename
## The following objects are masked from 'package:tidyr':
## 
##     expand, smiths
melt.long <- melt(as.data.frame(d.long),
  id.vars=c('subject', 'time'),
  measure.vars=c('x', 'y'))
```

融化后的数据框为：

```
knitr::kable(melt.long)
```

| subject | time | variable | value |
| ------- | ---- | -------- | ----- |
| 1       | 1    | x        | 5     |
| 1       | 2    | x        | 7     |
| 1       | 3    | x        | 8     |
| 2       | 1    | x        | 8     |
| 2       | 2    | x        | 2     |
| 2       | 3    | x        | 10    |
| 3       | 1    | x        | 7     |
| 3       | 2    | x        | 2     |
| 3       | 3    | x        | 5     |
| 4       | 1    | x        | 1     |
| 4       | 2    | x        | 5     |
| 4       | 3    | x        | 6     |
| 5       | 1    | x        | 9     |
| 5       | 2    | x        | 7     |
| 5       | 3    | x        | 10    |
| 1       | 1    | y        | 9     |
| 1       | 2    | y        | 7     |
| 1       | 3    | y        | 6     |
| 2       | 1    | y        | 1     |
| 2       | 2    | y        | 1     |
| 2       | 3    | y        | 9     |
| 3       | 1    | y        | 10    |
| 3       | 2    | y        | 8     |
| 3       | 3    | y        | 3     |
| 4       | 1    | y        | 10    |
| 4       | 2    | y        | 1     |
| 4       | 3    | y        | 1     |
| 5       | 1    | y        | 8     |
| 5       | 2    | y        | 8     |
| 5       | 3    | y        | 10    |

### 27.20.2 用`cast()`函数变形

用`cast()`函数把融化的数据框转换为要求的格式。 例如，下面的程序把melt.long重新转化成了原来d.long的格式：

```
d1 <- cast(melt.long, subject + time ~ variable)
```

`cast()`的第二自变量是公式， 波折号左边是分组变量，右边是要从纵向转为横向的变量， 这里把`variable`中的`x`和`y`转为横向， 相应的变量值从`value`中取出。 结果：

```
knitr::kable(d1)
```

| subject | time | x    | y    |
| ------- | ---- | ---- | ---- |
| 1       | 1    | 5    | 9    |
| 1       | 2    | 7    | 7    |
| 1       | 3    | 8    | 6    |
| 2       | 1    | 8    | 1    |
| 2       | 2    | 2    | 1    |
| 2       | 3    | 10   | 9    |
| 3       | 1    | 7    | 10   |
| 3       | 2    | 2    | 8    |
| 3       | 3    | 5    | 3    |
| 4       | 1    | 1    | 10   |
| 4       | 2    | 5    | 1    |
| 4       | 3    | 6    | 1    |
| 5       | 1    | 9    | 8    |
| 5       | 2    | 7    | 8    |
| 5       | 3    | 10   | 10   |

如下的程序把融化后的数据框转换为宽表， 5位病人每人的3次随访的6个测量值都合并到同一行中：

```
d2 <- cast(melt.long, subject ~ variable + time)
```

这里公式以病人作为仅有的分类， 而变量x, y和3个time(时间)都变成了横向:

```
knitr::kable(d2)
```

| subject | x_1  | x_2  | x_3  | y_1  | y_2  | y_3  |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1       | 5    | 7    | 8    | 9    | 7    | 6    |
| 2       | 8    | 2    | 10   | 1    | 1    | 9    |
| 3       | 7    | 2    | 5    | 10   | 8    | 3    |
| 4       | 1    | 5    | 6    | 10   | 1    | 1    |
| 5       | 9    | 7    | 10   | 8    | 8    | 10   |

变量名与时间之间以下划线连接。

### 27.20.3 宽表变成长表

当数据框是宽表， 变量名中用序号表示时间时， 需要先把变量名与时间分离出来。 比如， `d.wide`数据框是如下的一个子集：

```
d.wide <- data.frame(
  subject=1:5,
  x1=c(5,8,7,1,9),
  x2=c(7,2,2,5,7),
  y1=c(9,1,10,10,8)
)
d.wide
##   subject x1 x2 y1
## 1       1  5  7  9
## 2       2  8  2  1
## 3       3  7  2 10
## 4       4  1  5 10
## 5       5  9  7  8
```

还是先融化为长表：

```
melt.wide <- melt(
  d.wide, id.vars=c("subject"), measure.vars=c("x1", "x2", "y1"))
```

宽表融化后结果：

```
knitr::kable(melt.wide)
```

| subject | variable | value |
| ------- | -------- | ----- |
| 1       | x1       | 5     |
| 2       | x1       | 8     |
| 3       | x1       | 7     |
| 4       | x1       | 1     |
| 5       | x1       | 9     |
| 1       | x2       | 7     |
| 2       | x2       | 2     |
| 3       | x2       | 2     |
| 4       | x2       | 5     |
| 5       | x2       | 7     |
| 1       | y1       | 9     |
| 2       | y1       | 1     |
| 3       | y1       | 10    |
| 4       | y1       | 10    |
| 5       | y1       | 8     |

这个结果没有将时间分离出来，为此使用字符串处理：

```
melt.wide[,"time"] <- as.numeric(substring(melt.wide[,"variable"], 2))
melt.wide[,"variable"] <- substring(melt.wide[,"variable"], 1, 1)
knitr::kable(melt.wide)
```

| subject | variable | value | time |
| ------- | -------- | ----- | ---- |
| 1       | x        | 5     | 1    |
| 2       | x        | 8     | 1    |
| 3       | x        | 7     | 1    |
| 4       | x        | 1     | 1    |
| 5       | x        | 9     | 1    |
| 1       | x        | 7     | 2    |
| 2       | x        | 2     | 2    |
| 3       | x        | 2     | 2    |
| 4       | x        | 5     | 2    |
| 5       | x        | 7     | 2    |
| 1       | y        | 9     | 1    |
| 2       | y        | 1     | 1    |
| 3       | y        | 10    | 1    |
| 4       | y        | 10    | 1    |
| 5       | y        | 8     | 1    |

现在的`melt.wide`已经有分类变量`subject`，时间变量`time`， 变量名列`variable`和变量值列`value`，可以用`cast()`转换了。 例如， 转换成每个病人两次随访的格式，这时因为`y`没有第二次随访值， 会等于缺失值：

```
cast.wide <- cast(melt.wide, subject + time ~ variable)
knitr::kable(cast.wide)
```

| subject | time | x    | y    |
| ------- | ---- | ---- | ---- |
| 1       | 1    | 5    | 9    |
| 1       | 2    | 7    | NA   |
| 2       | 1    | 8    | 1    |
| 2       | 2    | 2    | NA   |
| 3       | 1    | 7    | 10   |
| 3       | 2    | 2    | NA   |
| 4       | 1    | 1    | 10   |
| 4       | 2    | 5    | NA   |
| 5       | 1    | 9    | 8    |
| 5       | 2    | 7    | NA   |

变量名与时间之间更复杂的连接关系， 如`abc1`, `abc2`, `x1`, `y1`， 不能简单用取子串完成， 可以借助正则表达式拆开。

### 27.20.4 变形同时进行概括

如果`cast()`后每组有不止一个值，可以指定一个统计函数进行汇总。 下面的程序计算每个病人的所有3次随访的x平均值和y平均值：

```
cast(melt.long, subject ~ variable, mean)
##   subject        x        y
## 1       1 6.666667 7.333333
## 2       2 6.666667 3.666667
## 3       3 4.666667 7.000000
## 4       4 4.000000 4.000000
## 5       5 8.666667 8.666667
```

下面的程序对每个病人的每个随访时间， 计算x和y的最大值：

```
cast(melt.long, subject + time ~ ., max)
##    subject time (all)
## 1        1    1     9
## 2        1    2     7
## 3        1    3     8
## 4        2    1     8
## 5        2    2     2
## 6        2    3    10
## 7        3    1    10
## 8        3    2     8
## 9        3    3     5
## 10       4    1    10
## 11       4    2     5
## 12       4    3     6
## 13       5    1     9
## 14       5    2     8
## 15       5    3    10
```

注意公式一端没有变量指定时用句点。

reshape包的某些函数与tidyverse系统中函数冲突， 所以使用完reshape后应卸载：

```
detach(package:reshape)
```









# 28 数据汇总

前面讲了用dplyr包的`summarise()`函数进行简单概括的方法。 下面描述其它一些数据概括方法。

## 28.1 用`summary()`函数作简单概括

在d.cancer中保存了34个病人的代码(id)、 年龄(age)、性别(sex)、病理类型(type)、放疗前肿瘤体积(v0)、放疗后肿瘤体积(v1)。 其中，sex、type用来作为分类，年龄可以作为连续型取值变量， 也可以分组后作为分类。体积是连续型取值变量。

对数值型向量`x`，用`summary(x)`可以获得变量的平均值、中位数、 最小值、最大值、四分之一和四分之三分位数。 如

```
summary(d.cancer[["v0"]])
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   12.58   43.77   93.40  110.08  157.18  330.24
summary(d.cancer[["v1"]])
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    2.30   12.73   30.62   44.69   72.94  128.34
```

可以看出放疗后体积减小了很多。

可以用盒形图表现类似的信息，如

```
boxplot(list('放疗前'=d.cancer[["v0"]], 
  '放疗后'=d.cancer[["v1"]]), main='肿瘤体积')
```

![img](http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/summary-summ_files/figure-html/summ-summ-boxp01-1.png)

对一个数据框`d`， 用`summary(d)`可以获得每个连续型变量的基本统计量， 和每个离散取值变量的频率。如

```
summary(d.cancer)
##        id             age            sex                type          
##  Min.   : 1.00   Min.   :49.00   Length:34          Length:34         
##  1st Qu.: 9.25   1st Qu.:55.00   Class :character   Class :character  
##  Median :17.50   Median :67.00   Mode  :character   Mode  :character  
##  Mean   :17.50   Mean   :64.13                                        
##  3rd Qu.:25.75   3rd Qu.:70.00                                        
##  Max.   :34.00   Max.   :79.00                                        
##                  NA's   :11                                           
##        v0               v1        
##  Min.   : 12.58   Min.   :  2.30  
##  1st Qu.: 43.77   1st Qu.: 12.73  
##  Median : 93.40   Median : 30.62  
##  Mean   :110.08   Mean   : 44.69  
##  3rd Qu.:157.18   3rd Qu.: 72.94  
##  Max.   :330.24   Max.   :128.34  
## 
```

对数据框`d`，用`str(d)`可以获得各个变量的类型和取值样例。 如

```
str(d.cancer)
## Classes 'spec_tbl_df', 'tbl_df', 'tbl' and 'data.frame': 34 obs. of  6 variables:
##  $ id  : num  1 2 3 4 5 6 7 8 9 10 ...
##  $ age : num  70 70 69 68 67 75 52 71 68 79 ...
##  $ sex : chr  "F" "F" "F" "M" ...
##  $ type: chr  "腺癌" "腺癌" "腺癌" "腺癌" ...
##  $ v0  : num  26.5 135.5 209.7 61 237.8 ...
##  $ v1  : num  2.91 35.08 74.44 34.97 128.34 ...
##  - attr(*, "spec")=
##   .. cols(
##   ..   id = col_double(),
##   ..   age = col_double(),
##   ..   sex = col_character(),
##   ..   type = col_character(),
##   ..   v0 = col_double(),
##   ..   v1 = col_double()
##   .. )
```

用`head(d)`可以返回数据框（或向量、矩阵）的前几行， 用`tail(d)`可以返回数据框的后几行。

## 28.2 连续型变量概括函数

对连续取值的变量`x`， 可以用`mean`, `std`, `var`, `sum`, `prod`, `min`, `max`等函数获取基本统计量。 加`na.rm=TRUE`选项可以仅对非缺失值计算。

`sort(x)`返回排序后的结果。 `rev(x)`把`x`所有元素次序颠倒后返回。 `quantile(x, c(0.05, 0.95))`可以求`x`的样本分位数。 `rank(x)`对`x`求秩得分（即名次，但从最小到最大排列）。

## 28.3 分类变量概括

分类变量一般输入为因子。 对因子`x`， `table(x)`返回`x`的每个不同值的频率（出现次数）， 结果为一个类（class）为table的一维数组。 每个元素有对应的元素名，为`x`的各水平值。 如

```
res <- table(d.cancer[["sex"]]); res
## 
##  F  M 
## 13 21
res['F']
##  F 
## 13
```

对单个分类变量, `table`结果是一个有元素名的向量。 用`as.data.frame()`函数把`table`的结果转为数据框:

```
as.data.frame(res)
##   Var1 Freq
## 1    F   13
## 2    M   21
```

用`prop.table()`将频数转换成百分比：

```
prop.table(res)
## 
##         F         M 
## 0.3823529 0.6176471
```

`table`作的单变量频数表可以用`barplot`表现为图形，如:

```
barplot(res, main='性别分布')
```

![img](http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/summary-summ_files/figure-html/summ-summ-barplot01-1.png)

对两个分类变量`x1`和`x2`， 其每个组合的出现次数可以用`table(x1,x2)`函数统计， 结果叫做列联表。 如

```
res2 <- with(d.cancer, table(sex, type)); res2
##    type
## sex 鳞癌 腺癌
##   F    4    9
##   M   18    3
```

结果是一个类为table的二维数组（矩阵）， 每行以第一个变量`x1`的各水平值为行名， 每列以第二个变量`x2`的各水平值为列名。 这里用了`with()`函数引入一个数据框， 后续的参数中的表达式可以直接使用数据框的变量。

对两个分类变量, `table`结果是一个矩阵。 用`as.data.frame`函数把`table`的结果转为数据框:

```
as.data.frame(res2)
##   sex type Freq
## 1   F 鳞癌    4
## 2   M 鳞癌   18
## 3   F 腺癌    9
## 4   M 腺癌    3
```

列联表的结果可以用条形图表示。如

```
barplot(res2, legend=TRUE)
```

![img](http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/summary-summ_files/figure-html/summ-summ-table2-barp02-1.png)

或

```
barplot(res2, legend=TRUE, beside=TRUE)
```

![img](http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/summary-summ_files/figure-html/summ-summ-table2-barp03-1.png)

对于`table()`的结果列联表， 可以用`addmargins()`函数增加行和与列和。 如

```
addmargins(res2)
##      type
## sex   鳞癌 腺癌 Sum
##   F      4    9  13
##   M     18    3  21
##   Sum   22   12  34
```

用`margin.table()`可以计算列联表行或列的和并返回，如

```
margin.table(res2, 1)
## sex
##  F  M 
## 13 21
margin.table(res2, 2)
## type
## 鳞癌 腺癌 
##   22   12
```

用`prop.table(r)`把一个列联表`r`转换成百分比表。 如

```
prop.table(res2)
##    type
## sex       鳞癌       腺癌
##   F 0.11764706 0.26470588
##   M 0.52941176 0.08823529
```

用`prop.table(res,1)`把列联表`res`转换成行百分比表。 用`prop.table(res,2)`把列联表`res`转换成列百分比表。 如

```
prop.table(res2, 1)
##    type
## sex      鳞癌      腺癌
##   F 0.3076923 0.6923077
##   M 0.8571429 0.1428571
prop.table(res2, 2)
##    type
## sex      鳞癌      腺癌
##   F 0.1818182 0.7500000
##   M 0.8181818 0.2500000
```

在有多个分类变量时， 用`as.data.frame(table(x1, x2, x3))` 形成多个分类变量交叉分类的频数统计数据框。

dplyr包的`count()`功能与`table()`类似。 如

```
d.cancer %>%
  count(sex)
## # A tibble: 2 x 2
##   sex       n
##   <chr> <int>
## 1 F        13
## 2 M        21
```

又如

```
d.cancer %>%
  count(sex, type)
## # A tibble: 4 x 3
##   sex   type      n
##   <chr> <chr> <int>
## 1 F     鳞癌      4
## 2 F     腺癌      9
## 3 M     鳞癌     18
## 4 M     腺癌      3
```

## 28.4 数据框概括

用`colMeans()`对数据框或矩阵的每列计算均值， 用`colSums()`对数据框或矩阵的每列计算总和。 用`rowMeans()`和`rowSums()`对矩阵的每行计算均值或总和。

数据框与矩阵有区别， 某些适用于矩阵的计算对数据框不适用， 例如矩阵乘法。 用`as.matrix()`把数据框的数值子集转换成矩阵。

对矩阵，用`apply(x, 1, FUN)`对矩阵x的每一行使用函数FUN计算结果， 用`apply(x, 2, FUN)`对矩阵x的每一列使用函数FUN计算结果。

如果`apply(x,1,FUN)`中的FUN对每个行变量得到多个结果， 结果将是一个矩阵，行数为，列数等于nrow(x)。 如果`apply(x,2,FUN)`中的FUN对每个列变量得到多个结果， 结果将是一个矩阵，行数为，列数等于ncol(x)。 例如：

```
apply(as.matrix(iris[,1:4]), 2,
        function(x)
        c(n=sum(!is.na(x)),
          mean=mean(x, na.rm=TRUE),
          sd=sd(x, na.rm=TRUE)))
##      Sepal.Length Sepal.Width Petal.Length Petal.Width
## n     150.0000000 150.0000000   150.000000 150.0000000
## mean    5.8433333   3.0573333     3.758000   1.1993333
## sd      0.8280661   0.4358663     1.765298   0.7622377
```

上面的例子如果改用dplyr包的summarise函数， 需要对每个列分别写出汇总结果， 会比较罗嗦。

## 28.5 分类概括

### 28.5.1 用dplyr包分类概括

用dplyr包的`group_by()`与`summarise()`配合可以比较简单地进行分类概括。 适用于要概括的变量个数比较少的情形。

例如，按性别分组，计算v0的平均值：

```
d.cancer %>%
  group_by(sex) %>%
  summarise(mean.v0=mean(v0, na.rm=TRUE))
## # A tibble: 2 x 2
##   sex   mean.v0
##   <chr>   <dbl>
## 1 F        113.
## 2 M        108.
```

下面的程序按性别分组， 分别计算v0与v1的平均值：

```
d.cancer %>%
  group_by(sex) %>%
  summarise(mean.v0=mean(v0, na.rm=TRUE),
            mean.v1=mean(v1, na.rm=TRUE))
## # A tibble: 2 x 3
##   sex   mean.v0 mean.v1
##   <chr>   <dbl>   <dbl>
## 1 F        113.    42.7
## 2 M        108.    46.0
```

下面的程序按性别分组，计算v0和v1的平均值、标准差：

```
d.cancer %>%
  group_by(sex) %>%
  summarise(mean.v0=mean(v0, na.rm=TRUE),
            mean.v1=mean(v1, na.rm=TRUE),
            sd.v0=sd(v0, na.rm=TRUE),
            sd.v1=sd(v1, na.rm=TRUE))
## # A tibble: 2 x 5
##   sex   mean.v0 mean.v1 sd.v0 sd.v1
##   <chr>   <dbl>   <dbl> <dbl> <dbl>
## 1 F        113.    42.7 100.   41.7
## 2 M        108.    46.0  66.5  37.3
```

以上结果如果每个变量的统计量分别占一行就好了， 否则当需要分析的变量个数和统计量个数较多时结果表格可能过宽。 从上面的例子还可以看出， 当变量比较多、统计量比较多时， 用`summarise()`写出的程序比较冗长。 plyr包功能更强，变量个数多、统计量多的时候能够统一处理， 也能按用户需求排列结果， 但是使用比dplyr包复杂一些。

dplyr包也提供了一部分函数， 可以解决对一批变量计算一批统计量的问题。 `summarse_at()`函数可以指定一批变量名与一批统计函数， 自动命名结果变量，如：

```
d.cancer %>%
  group_by(sex) %>%
  summarise_at(c("v0", "v1"),
               list(avg = ~mean(.), std = ~sd(.)), na.rm=TRUE)
## # A tibble: 2 x 5
##   sex   v0_avg v1_avg v0_std v1_std
##   <chr>  <dbl>  <dbl>  <dbl>  <dbl>
## 1 F       113.   42.7  100.    41.7
## 2 M       108.   46.0   66.5   37.3
```

其中的变量子集也可以用序号范围表示， 或者用`vars()`函数写成不加撇号的格式，如：

```
d.cancer %>%
  group_by(sex) %>%
  summarise_at(vars(v0, v1),
               list(avg = ~mean(.), std = ~sd(.)), na.rm=TRUE)
## # A tibble: 2 x 5
##   sex   v0_avg v1_avg v0_std v1_std
##   <chr>  <dbl>  <dbl>  <dbl>  <dbl>
## 1 F       113.   42.7  100.    41.7
## 2 M       108.   46.0   66.5   37.3
```

如果要对所有数值型变量计算某些统计量， 可以用`summarize_if(is.numeric, 变量名列表, list(变量后缀=~统计函数名<, ...>))`。 如：

```
d.cancer %>%
  group_by(sex) %>%
  summarise_if(is_numeric,
               list(avg = ~mean(.), std = ~sd(.)), na.rm=TRUE)
## Warning: Deprecated

## Warning: Deprecated

## Warning: Deprecated

## Warning: Deprecated

## Warning: Deprecated
## # A tibble: 2 x 9
##   sex   id_avg age_avg v0_avg v1_avg id_std age_std v0_std v1_std
##   <chr>  <dbl>   <dbl>  <dbl>  <dbl>  <dbl>   <dbl>  <dbl>  <dbl>
## 1 F       17.9    66.1   113.   42.7  12.3     6.79  100.    41.7
## 2 M       17.2    63.2   108.   46.0   8.50   10.1    66.5   37.3
```

### 28.5.2 用`tapply()`分组概括向量

用`tapply()`函数进行分组概括, 格式为：

```
  tapply(X, INDEX, FUN)
```

其中`X`是一个向量， `INDEX`是一个分类变量， `FUN`是概括统计函数。

比如，下面的程序分性别组计算疗前体积的均值：

```
with(d.cancer, tapply(v0, sex, mean))
##        F        M 
## 113.2354 108.1214
```

### 28.5.3 用`aggregate()`分组概括数据框

`aggregate`函数对输入的数据框用指定的分组变量（或交叉分组） 分组进行概括统计。 例如，下面的程序按性别分组计算年龄、疗前体积、疗后体积的平均值:

```
aggregate(d.cancer[,c("age", "v0", "v1")],
  list(sex=d.cancer[["sex"]]), mean, na.rm=TRUE)
##   sex      age       v0       v1
## 1   F 66.14286 113.2354 42.65538
## 2   M 63.25000 108.1214 45.95524
```

`aggregate()`第一个参数是数据框， 第二个参数是列表，列表元素是用来分组或交叉分组的变量， 第三个参数是概括用的函数， 概括用的函数的选项可以在后面给出。

可以同时计算多个概括统计量，如：

```
aggregate(d.cancer[,c('age', 'v0', 'v1')],
   list(sex=d.cancer[["sex"]]), summary)
```

上面的结果是两个观测、19个变量的数据框， 作为表格太宽了。 后面讲的plyr包可以做出更合理的表格。

可以交叉分组后概括，如

```
with(d.cancer,
     aggregate(cbind(v0, v1), list(sex=sex, type=type), mean))
##   sex type        v0       v1
## 1   F 鳞癌 126.99250 45.54750
## 2   M 鳞癌 113.55722 49.65556
## 3   F 腺癌 107.12111 41.37000
## 4   M 腺癌  75.50667 23.75333
```

### 28.5.4 用`split()`函数分组后概括

split函数可以把数据框的各行按照一个或几个分组变量分为子集的列表， 然后可以用`sapply()`或`vapply()`对每组进行概括。 如

```
sp <- split(d.cancer[,c('v0','v1')], d.cancer[,'sex'])
sapply(sp, colMeans)
##            F         M
## v0 113.23538 108.12143
## v1  42.65538  45.95524
```

返回矩阵，行为变量v0, v1，列为不同性别， 值为相应的变量在各性别组的平均值。 当`sapply()`对列表每项的操作返回一个向量时， 总是列表每项的输出保存为结果的一列。 `colMeans`函数计算分组后数据框子集每列的平均值。

### 28.5.5 用plyr包进行分类概括

plyr则是一个专注于分组后分别分析然后将分析结果尽可能合理地合并的扩展包, 功能强大， dplyr包仅针对数据框，使用更方便，但是对于复杂情况功能不如plyr包强。

plyr的输入支持数组、数据框、列表， 输出支持数组、数据框、列表或无输出。 分组分析的函数输出格式需要与指定的输出格式一致。

这里主要介绍从数据框分组概括并将结果保存为数据框的方法， 使用plyr包的`ddply()`函数。 实际上，dplyr包的这种功能更方便。 plyr包的优点是可以自定义概括函数， 使得结果表格符合用户的预期， 处理多个变量时程序更简洁。

plyr包与dplyr包的函数名冲突比较大， 所以需要先卸载dplyr包再调用plyr包：

```
if("dplyr" %in% .packages()) detach("package:dplyr")
library(plyr)
## 
## 载入程辑包：'plyr'
## The following object is masked from 'package:purrr':
## 
##     compact
```

`ddply()`函数第一自变量是要分组的数据框， 第二自变量是分组用的变量名， 第三自变量是一个概括函数， 此概括函数以一个数据框子集（数据类型是数据框）为输入， 输出是一个数值、一个数值型向量或者一个数据框, 但最好是数据框。 例如，按性别分组，计算v0的平均值：

```
ddply(d.cancer, 'sex', 
      function(d) c(mean.v0 = mean(d[["v0"]], na.rm=TRUE)))
##   sex  mean.v0
## 1   F 113.2354
## 2   M 108.1214
```

下面的程序按性别分组， 分别计算v0与v1的平均值：

```
ddply(d.cancer, 'sex', 
      function(d) colMeans(d[,c('v0', 'v1')]))
##   sex       v0       v1
## 1   F 113.2354 42.65538
## 2   M 108.1214 45.95524
```

下面的程序按性别分组，计算v0和v1的平均值、标准差：

```
f1 <- function(dsub){
  tab <- tibble(
    '变量'=c('v0', 'v1'),
    '均值'=c(mean(dsub[,'v0'], na.rm=TRUE), 
           mean(dsub[,'v1'], na.rm=TRUE)),
    '标准差'=c(sd(dsub[,'v0'], na.rm=TRUE), 
            sd(dsub[,'v1'], na.rm=TRUE)))
  tab
}
ddply(d.cancer, 'sex', f1)
##   sex 变量      均值    标准差
## 1   F   v0 113.23538 100.06621
## 2   F   v1  42.65538  41.72226
## 3   M   v0 108.12143  66.45374
## 4   M   v1  45.95524  37.27592
```

注意`f1()`结果是一个数据框。 程序有些重复内容，对每个变量和每个统计量都需要分别写出， 如果这样用plyr包就不如直接用`dplyr::summarise()`了。 下面用`vapply()`简化程序。

按性别分组，然后v0、v1各自一行结果， 计算非缺失值个数、均值、标准差、中位数：

```
f2 <- function(d, variables){
  d1 <- d[,variables,drop=FALSE]
  nnotmiss <- vapply(d1, function(x) sum(!is.na(x)), 1L)
  xm <- vapply(d1, mean, 0.0, na.rm=TRUE)
  xsd <- vapply(d1, sd, 1.0, na.rm=TRUE)
  xmed <- vapply(d1, median, 0.0, na.rm=TRUE)
  data.frame(variable=variables,
             n=nnotmiss,
             mean=xm,
             sd=xsd,
             median=xmed)
}
ddply(d.cancer, 'sex', f2, variables = c("v0", "v1"))
##   sex variable  n      mean        sd median
## 1   F       v0 13 113.23538 100.06621  67.37
## 2   F       v1 13  42.65538  41.72226  27.32
## 3   M       v0 21 108.12143  66.45374 101.65
## 4   M       v1 21  45.95524  37.27592  32.10
```

`f2()`函数针对分组后的数据框子集， 这样的函数可以先在一个子集上试验。 在`f2()`函数中， 设输入的数据子集为`d`， 要分析的变量组成的数据框为`d1`， 用`vapply()`函数对`d1`的每一列计算一种统计量， 然后将每种统计量作为结果数据框的一列。 `vapply()`函数类似于`lapply()`和`sapply()`， 但是用第三个自变量表示要应用的变换函数的返回值类型和个数， 用举例的方法给出。

`ddply()`也可以对交叉分类后每个类分别汇总， 例如按照性别与病理类型交叉分组后汇总v0、v1：

```
ddply(d.cancer, c('sex', 'type'), f2, variables=c("v0", "v1"))
##   sex type variable  n      mean        sd  median
## 1   F 鳞癌       v0  4 126.99250  83.82544 119.000
## 2   F 鳞癌       v1  4  45.54750  23.55433  40.920
## 3   F 腺癌       v0  9 107.12111 110.67144  42.700
## 4   F 腺癌       v1  9  41.37000  48.95945   9.450
## 5   M 鳞癌       v0 18 113.55722  68.88281 103.275
## 6   M 鳞癌       v1 18  49.65556  38.96325  33.730
## 7   M 腺癌       v0  3  75.50667  44.36592  61.000
## 8   M 腺癌       v1  3  23.75333  11.32141  23.960
```

上面的程序写法适用于已知要分析的变量名的情况。 如果想对每个数值型变量都分析， 而且想把要计算的统计量用统一的格式调用，可以写成：

```
f3 <- function(d){
  ff <- function(x){
    c(n=sum(!is.na(x)),
      each(mean, sd, median)(x, na.rm=TRUE))
  }
  ldply(Filter(is.numeric, d), ff)
}
ddply(d.cancer, 'sex', f3)
##   sex .id  n      mean         sd median
## 1   F  id 13  17.92308  12.325188  19.00
## 2   F age  7  66.14286   6.792853  69.00
## 3   F  v0 13 113.23538 100.066207  67.37
## 4   F  v1 13  42.65538  41.722263  27.32
## 5   M  id 21  17.23810   8.502381  17.00
## 6   M age 16  63.25000  10.096204  66.50
## 7   M  v0 21 108.12143  66.453742 101.65
## 8   M  v1 21  45.95524  37.275917  32.10
```

`ff()`函数对输入的一个数值型向量计算4种统计量， 返回一个长度为4的数值型向量， 用来对分组后的数据子集中的一列计算4种统计量。 plyr包的`each()`函数接受多个函数， 返回一个函数可以同时得到这几个函数的结果， 结果中各元素用输入的函数名命名。 `f3()`函数中的`Filter`函数用于从列表或数据框中取出满足条件的项， 这里取出输入的数据子集`d`中所有的数值型列。 `f3()`函数中的`ldply()`函数接受一个列表或看成列表的一个数据框， 对数据框的每列应用`ff()`函数计算4种统计量， 然后合并所有各列的统计量为一个数据框， 结果数据框的每行对应于`d`中的一列。 程序中的`ddply()`函数接受一个数据框， 第二自变量指定用来将数据框分组的变量， 第三自变量`f3()`是对分组后的数据框子集进行分析的函数， 此函数接受一个数据框，输出一个数据框。

上面的程序也可以利用无名函数写成：

```
f4 <- function(x){
  c(n=sum(!is.na(x)),
    each(mean, sd, median)(x, na.rm=TRUE))
}
ddply(d.cancer, 'sex', 
      function(d) 
        ldply(Filter(is.numeric, d), f4))
##   sex .id  n      mean         sd median
## 1   F  id 13  17.92308  12.325188  19.00
## 2   F age  7  66.14286   6.792853  69.00
## 3   F  v0 13 113.23538 100.066207  67.37
## 4   F  v1 13  42.65538  41.722263  27.32
## 5   M  id 21  17.23810   8.502381  17.00
## 6   M age 16  63.25000  10.096204  66.50
## 7   M  v0 21 108.12143  66.453742 101.65
## 8   M  v1 21  45.95524  37.275917  32.10
```

## 28.6 练习

- 把[`patients.csv`](http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/patients.csv)读入“d.patients”中， 并计算发病年龄、发病年、发病月、 发病年月（格式如“200702”表示2007年2月份）。
- 把“现住地址国标”作为字符型，去掉最后两位，仅保留前6位数字， 保存到变量“地址编码”中。
- 按照地址编码和发病年月交叉分类汇总发病人数， 保存到数据框d.pas1中， 然后保存为CSV文件“分区分年月统计.csv”中。 要求结果有三列：“地址编码”、“发病年月”、“发病人数”。
- 按照地址编码和发病月分类汇总发病人数， 保存到数据框d.pas2中， 然后保存为CSV文件“分区分月统计.csv”中。 要求每个地址编码占一行， 各列为地址编码以及1、2、…………、12各月份， 每行为同一地址编码各月份的发病数。
- 按发病年月和性别汇总发病人数， 并计算同年月不分性别的发病总人数。 结果保存到数据框d.pas3中， 然后保存到CSV文件“分年月分性别统计.csv”中。 要求每个不同年月占一行， 变量包括年月、男性发病数、女性发病数、总计。
- 分析病人的职业分布，保存到数据框d.pas4中， 然后保存到CSV文件“职业构成.csv”中。 要求各列为职业、发病人数、百分比（结果乘以100并保留一位小数）。
- 把年龄分成0—9, 11—19, ……, 70以上各段， 保存为“年龄段”变量。 用年龄段和性别交叉汇总发病人数和百分比(结果乘以100并保留一位小数)， 保存到“年龄性别分布.csv”中。 要求将每个年龄段的男性发病人数、发病率、女性发病人数、发病率存为一行。