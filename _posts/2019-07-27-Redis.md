

# Redis

[Redis 教程](https://www.runoob.com/redis/redis-tutorial.html)

[Redis 官网](https://redis.io/)

> REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。
>
> Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。
>
> 它通常被称为数据结构服务器，因为值（value）可以是 **字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)**等类型。

## Redis 简介

### 1. 简介

Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。

Redis 与其他 key - value 缓存产品有以下三个特点：

- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
- Redis支持数据的备份，即master-slave模式的数据备份。

### 2. 优势

- 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。
- 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
- 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。
- 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。

## Redis 数据类型

> Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。

### 1.String（字符串）

string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。

string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。

string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。

- **实例**

```
redis 127.0.0.1:6379> SET name "runoob"
OK
redis 127.0.0.1:6379> GET name
"runoob"
```

在以上实例中我们使用了 Redis 的 **SET** 和 **GET** 命令。键为 name，对应的值为 **runoob**。

**注意：**一个键最大能存储512MB。

------

### 2. Hash（哈希）

Redis hash 是一个键值(key=>value)对集合。

Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。

- **实例**

**DEL runoob** 用于删除前面测试用过的 key，不然会报错：**(error) WRONGTYPE Operation against a key holding the wrong kind of value**

```
redis 127.0.0.1:6379> DEL runoob
redis 127.0.0.1:6379> HMSET myhash field1 "Hello" field2 "World"
"OK"
redis 127.0.0.1:6379> HGET myhash field1
"Hello"
redis 127.0.0.1:6379> HGET myhash field2
"World"
```

实例中我们使用了 Redis **HMSET, HGET** 命令，**HMSET** 设置了两个 **field=>value** 对, HGET 获取对应 **field** 对应的 **value**。

每个 hash 可以存储 2

32

 -1 键值对（40多亿）。



------

### 3. List（列表）

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。

- **实例**

```
redis 127.0.0.1:6379> DEL runoob
redis 127.0.0.1:6379> lpush runoob redis
(integer) 1
redis 127.0.0.1:6379> lpush runoob mongodb
(integer) 2
redis 127.0.0.1:6379> lpush runoob rabitmq
(integer) 3
redis 127.0.0.1:6379> lrange runoob 0 10
1) "rabitmq"
2) "mongodb"
3) "redis"
redis 127.0.0.1:6379>
```

列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。

------

### 4. Set（集合）

Redis的Set是string类型的无序集合。

集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

**sadd 命令**

添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。

```
sadd key member
```

**实例**

```
redis 127.0.0.1:6379> DEL runoob
redis 127.0.0.1:6379> sadd runoob redis
(integer) 1
redis 127.0.0.1:6379> sadd runoob mongodb
(integer) 1
redis 127.0.0.1:6379> sadd runoob rabitmq
(integer) 1
redis 127.0.0.1:6379> sadd runoob rabitmq
(integer) 0
redis 127.0.0.1:6379> smembers runoob

1) "redis"
2) "rabitmq"
3) "mongodb"
```

**注意：**以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。

集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。

------

### 5. zset (sorted set：有序集合)

Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。



不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

zset的成员是唯一的,但分数(score)却可以重复。

**zadd 命令**

添加元素到集合，元素在集合中存在则更新对应score

```
zadd key score member 
```

**实例**

```
redis 127.0.0.1:6379> DEL runoob
redis 127.0.0.1:6379> zadd runoob 0 redis
(integer) 1
redis 127.0.0.1:6379> zadd runoob 0 mongodb
(integer) 1
redis 127.0.0.1:6379> zadd runoob 0 rabitmq
(integer) 1
redis 127.0.0.1:6379> zadd runoob 0 rabitmq
(integer) 0
redis 127.0.0.1:6379> > ZRANGEBYSCORE runoob 0 1000
1) "mongodb"
2) "rabitmq"
3) "redis"
```



## Redis 命令

> Redis 命令用于在 redis 服务上执行操作。
>
> 要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。

**语法**

Redis 客户端的基本语法为：

```
$ redis-cli
```

**实例**

以下实例讲解了如何启动 redis 客户端：

启动 redis 客户端，打开终端并输入命令 **redis-cli**。该命令会连接本地的 redis 服务。

```
$redis-cli
redis 127.0.0.1:6379>
redis 127.0.0.1:6379> PING

PONG
```

在以上实例中我们连接到本地的 redis 服务并执行 **PING** 命令，该命令用于检测 redis 服务是否启动。

------

**在远程服务上执行命令**

如果需要在远程 redis 服务上执行命令，同样我们使用的也是 **redis-cli** 命令。

**语法**

```
$ redis-cli -h host -p port -a password
```

**实例**

以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。

```
$redis-cli -h 127.0.0.1 -p 6379 -a "mypass"
redis 127.0.0.1:6379>
redis 127.0.0.1:6379> PING

PONG
```



## Redis 键(key)

> Redis 键命令用于管理 redis 的键。

**语法**

Redis 键命令的基本语法如下：

```
redis 127.0.0.1:6379> COMMAND KEY_NAME
```

**实例**

```
redis 127.0.0.1:6379> SET runoobkey redis
OK
redis 127.0.0.1:6379> DEL runoobkey
(integer) 1
```

在以上实例中 **DEL** 是一个命令， **runoobkey** 是一个键。 如果键被删除成功，命令执行后输出 **(integer) 1**，否则将输出 **(integer) 0**

**Redis keys 命令**

下表给出了与 Redis 键相关的基本命令：

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [DEL key](https://www.runoob.com/redis/keys-del.html) 该命令用于在 key 存在时删除 key。 |
| 2    | [DUMP key](https://www.runoob.com/redis/keys-dump.html)  序列化给定 key ，并返回被序列化的值。 |
| 3    | [EXISTS key](https://www.runoob.com/redis/keys-exists.html)  检查给定 key 是否存在。 |
| 4    | [EXPIRE key](https://www.runoob.com/redis/keys-expire.html) seconds 为给定 key 设置过期时间，以秒计。 |
| 5    | [EXPIREAT key timestamp](https://www.runoob.com/redis/keys-expireat.html)  EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 |
| 6    | [PEXPIRE key milliseconds](https://www.runoob.com/redis/keys-pexpire.html)  设置 key 的过期时间以毫秒计。 |
| 7    | [PEXPIREAT key milliseconds-timestamp](https://www.runoob.com/redis/keys-pexpireat.html)  设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 |
| 8    | [KEYS pattern](https://www.runoob.com/redis/keys-keys.html)  查找所有符合给定模式( pattern)的 key 。 |
| 9    | [MOVE key db](https://www.runoob.com/redis/keys-move.html)  将当前数据库的 key 移动到给定的数据库 db 当中。 |
| 10   | [PERSIST key](https://www.runoob.com/redis/keys-persist.html)  移除 key 的过期时间，key 将持久保持。 |
| 11   | [PTTL key](https://www.runoob.com/redis/keys-pttl.html)  以毫秒为单位返回 key 的剩余的过期时间。 |
| 12   | [TTL key](https://www.runoob.com/redis/keys-ttl.html)  以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 |
| 13   | [RANDOMKEY](https://www.runoob.com/redis/keys-randomkey.html)  从当前数据库中随机返回一个 key 。 |
| 14   | [RENAME key newkey](https://www.runoob.com/redis/keys-rename.html)  修改 key 的名称 |
| 15   | [RENAMENX key newkey](https://www.runoob.com/redis/keys-renamenx.html)  仅当 newkey 不存在时，将 key 改名为 newkey 。 |
| 16   | [TYPE key](https://www.runoob.com/redis/keys-type.html)  返回 key 所储存的值的类型。 |



## Redis 字符串(String)

Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：

**语法**

```
redis 127.0.0.1:6379> COMMAND KEY_NAME
```

**实例**

```
redis 127.0.0.1:6379> SET runoobkey redis
OK
redis 127.0.0.1:6379> GET runoobkey
"redis"
```

在以上实例中我们使用了 **SET** 和 **GET** 命令，键为 **runoobkey**。

**Redis 字符串命令**

下表列出了常用的 redis 字符串命令：

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [SET key value](https://www.runoob.com/redis/strings-set.html)  设置指定 key 的值 |
| 2    | [GET key](https://www.runoob.com/redis/strings-get.html)  获取指定 key 的值。 |
| 3    | [GETRANGE key start end](https://www.runoob.com/redis/strings-getrange.html)  返回 key 中字符串值的子字符 |
| 4    | [GETSET key value](https://www.runoob.com/redis/strings-getset.html) 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 |
| 5    | [GETBIT key offset](https://www.runoob.com/redis/strings-getbit.html) 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 |
| 6    | [MGET key1 [key2..\]](https://www.runoob.com/redis/strings-mget.html) 获取所有(一个或多个)给定 key 的值。 |
| 7    | [SETBIT key offset value](https://www.runoob.com/redis/strings-setbit.html) 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 |
| 8    | [SETEX key seconds value](https://www.runoob.com/redis/strings-setex.html) 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 |
| 9    | [SETNX key value](https://www.runoob.com/redis/strings-setnx.html) 只有在 key 不存在时设置 key 的值。 |
| 10   | [SETRANGE key offset value](https://www.runoob.com/redis/strings-setrange.html) 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 |
| 11   | [STRLEN key](https://www.runoob.com/redis/strings-strlen.html) 返回 key 所储存的字符串值的长度。 |
| 12   | [MSET key value [key value ...\]](https://www.runoob.com/redis/strings-mset.html) 同时设置一个或多个 key-value 对。 |
| 13   | [MSETNX key value [key value ...\]](https://www.runoob.com/redis/strings-msetnx.html)  同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 |
| 14   | [PSETEX key milliseconds value](https://www.runoob.com/redis/strings-psetex.html) 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 |
| 15   | [INCR key](https://www.runoob.com/redis/strings-incr.html) 将 key 中储存的数字值增一。 |
| 16   | [INCRBY key increment](https://www.runoob.com/redis/strings-incrby.html) 将 key 所储存的值加上给定的增量值（increment） 。 |
| 17   | [INCRBYFLOAT key increment](https://www.runoob.com/redis/strings-incrbyfloat.html) 将 key 所储存的值加上给定的浮点增量值（increment） 。 |
| 18   | [DECR key](https://www.runoob.com/redis/strings-decr.html) 将 key 中储存的数字值减一。 |
| 19   | [DECRBY key decrement](https://www.runoob.com/redis/strings-decrby.html) key 所储存的值减去给定的减量值（decrement） 。 |
| 20   | [APPEND key value](https://www.runoob.com/redis/strings-append.html) 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。 |

```
set 命令：设置一个键和值，键存在则只覆盖，返回ok
 > set 键  值    例如： >set name zhangsan

 get 命令：获取一个键的值，返回值
 > get 键        例如：>get name

 setnx命令：设置一个不存在的键和值（防止覆盖），
 > setnx 键 值      若键已存在则返回0表示失败

 setex命令：设置一个指定有效期的键和值（单位秒）
 > setex 键 [有效时间] 值  例如: >setex color 10 red
  不写有效时间则表示永久有效，等价于set

 setrange命令：替换子字符串 (替换长度由子子串长度决定)
 > setrange 键 位置 子字串
 > setrange name 4 aa  将name键对应值的第4个位置开始替换

 mset命令：批量设置键和值,成功则返回ok
 > mset 键1 值1 键2 值2 键3 值3 ....

 msetnx命令：批量设置不存在的键和值,成功则返回ok
 > msetnx 键1 值1 键2 值2 键3 值3 ....

 getset命令：获取原值，并设置新值

 getrange命令：获取指定范围的值
 >getrange 键 0 4     //获取指定0到4位置上的值

 mget命令： 批量获取值
 >mget 键1 键2 键3....

 incr命令： 指定键的值做加加操作，返回加后的结果。
 >  键        例如： >incr kid
 incrby命令： 设置某个键加上指定值
 > incrby 键 m    //其中m可以是正整数或负整数

 decr命令： 指定键的值做减减操作，返回减后的结果。
 > decr 键        例如： >decr kid
 decrby命令： 设置某个键减上指定值
 > decrby 键 m    //其中m可以是正整数或负整数

 append命令：给指定key的字符串追加value，返回新字符串值的长度
 >append 键 追加字串

 strlen求长度 >strlen 键名   //返回对应的值。
```



## Redis 哈希(Hash)

> Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。
>
> Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。

**实例**

```
127.0.0.1:6379>  HMSET runoobkey name "redis tutorial" description "redis basic commands for caching" likes 20 visitors 23000
OK
127.0.0.1:6379>  HGETALL runoobkey
1) "name"
2) "redis tutorial"
3) "description"
4) "redis basic commands for caching"
5) "likes"
6) "20"
7) "visitors"
8) "23000"
```

在以上实例中，我们设置了 redis 的一些描述信息(name, description, likes, visitors) 到哈希表的 **runoobkey** 中。

**Redis hash 命令**

下表列出了 redis hash 基本的相关命令：

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [HDEL key field1 [field2\]](https://www.runoob.com/redis/hashes-hdel.html)  删除一个或多个哈希表字段 |
| 2    | [HEXISTS key field](https://www.runoob.com/redis/hashes-hexists.html)  查看哈希表 key 中，指定的字段是否存在。 |
| 3    | [HGET key field](https://www.runoob.com/redis/hashes-hget.html)  获取存储在哈希表中指定字段的值。 |
| 4    | [HGETALL key](https://www.runoob.com/redis/hashes-hgetall.html)  获取在哈希表中指定 key 的所有字段和值 |
| 5    | [HINCRBY key field increment](https://www.runoob.com/redis/hashes-hincrby.html)  为哈希表 key 中的指定字段的整数值加上增量 increment 。 |
| 6    | [HINCRBYFLOAT key field increment](https://www.runoob.com/redis/hashes-hincrbyfloat.html)  为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 |
| 7    | [HKEYS key](https://www.runoob.com/redis/hashes-hkeys.html)  获取所有哈希表中的字段 |
| 8    | [HLEN key](https://www.runoob.com/redis/hashes-hlen.html)  获取哈希表中字段的数量 |
| 9    | [HMGET key field1 [field2\]](https://www.runoob.com/redis/hashes-hmget.html)  获取所有给定字段的值 |
| 10   | [HMSET key field1 value1 [field2 value2 \]](https://www.runoob.com/redis/hashes-hmset.html)  同时将多个 field-value (域-值)对设置到哈希表 key 中。 |
| 11   | [HSET key field value](https://www.runoob.com/redis/hashes-hset.html)  将哈希表 key 中的字段 field 的值设为 value 。 |
| 12   | [HSETNX key field value](https://www.runoob.com/redis/hashes-hsetnx.html)  只有在字段 field 不存在时，设置哈希表字段的值。 |
| 13   | [HVALS key](https://www.runoob.com/redis/hashes-hvals.html)  获取哈希表中所有值 |
| 14   | HSCAN key cursor [MATCH pattern] [COUNT count]  迭代哈希表中的键值对。 |

```
hset命令：设置一个哈希表的键和值
>hset hash名 键  值
如：>hset user:001 name zhangsan
hget命令： 获取执行哈希名中的键对应值

hsetnx命令：设置一个哈希表中不存在的键和值
>hsetnx hash名 键  值  //成功返回1，失败返回0
如：>hsetnx user:001 name zhangsan

hmset命令:hmset user:001 username zhangsan age 20 sex 1 批量设置
hmget user:001 username age sex:批量获取值

>hexists user:001 name //是否存在， 若存在返回1

>hlen user:001  //获取某哈希user001名中键的数量

>hdel user:001 name //删除哈希user:001 中name键

>hkeys user:002   //返回哈希名为user:002中的所有键。
>hvals user:002   //返回哈希名为user:002中的所有值。
>hgetall user:002 //返回哈希名为user:002中的所有键和值。
```



## Redis 列表(List)

> Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）
>
> 一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。

**实例**

```
redis 127.0.0.1:6379> LPUSH runoobkey redis
(integer) 1
redis 127.0.0.1:6379> LPUSH runoobkey mongodb
(integer) 2
redis 127.0.0.1:6379> LPUSH runoobkey mysql
(integer) 3
redis 127.0.0.1:6379> LRANGE runoobkey 0 10

1) "mysql"
2) "mongodb"
3) "redis"
```

在以上实例中我们使用了 **LPUSH** 将三个值插入了名为 **runoobkey** 的列表当中。

**Redis 列表命令**

下表列出了列表相关的基本命令：

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [BLPOP key1 [key2 \] timeout](https://www.runoob.com/redis/lists-blpop.html)  移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 |
| 2    | [BRPOP key1 [key2 \] timeout](https://www.runoob.com/redis/lists-brpop.html)  移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 |
| 3    | [BRPOPLPUSH source destination timeout](https://www.runoob.com/redis/lists-brpoplpush.html)  从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 |
| 4    | [LINDEX key index](https://www.runoob.com/redis/lists-lindex.html)  通过索引获取列表中的元素 |
| 5    | [LINSERT key BEFORE\|AFTER pivot value](https://www.runoob.com/redis/lists-linsert.html)  在列表的元素前或者后插入元素 |
| 6    | [LLEN key](https://www.runoob.com/redis/lists-llen.html)  获取列表长度 |
| 7    | [LPOP key](https://www.runoob.com/redis/lists-lpop.html)  移出并获取列表的第一个元素 |
| 8    | [LPUSH key value1 [value2\]](https://www.runoob.com/redis/lists-lpush.html)  将一个或多个值插入到列表头部 |
| 9    | [LPUSHX key value](https://www.runoob.com/redis/lists-lpushx.html)  将一个值插入到已存在的列表头部 |
| 10   | [LRANGE key start stop](https://www.runoob.com/redis/lists-lrange.html)  获取列表指定范围内的元素 |
| 11   | [LREM key count value](https://www.runoob.com/redis/lists-lrem.html)  移除列表元素 |
| 12   | [LSET key index value](https://www.runoob.com/redis/lists-lset.html)  通过索引设置列表元素的值 |
| 13   | [LTRIM key start stop](https://www.runoob.com/redis/lists-ltrim.html)  对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 |
| 14   | [RPOP key](https://www.runoob.com/redis/lists-rpop.html)  移除列表的最后一个元素，返回值为移除的元素。 |
| 15   | [RPOPLPUSH source destination](https://www.runoob.com/redis/lists-rpoplpush.html)  移除列表的最后一个元素，并将该元素添加到另一个列表并返回 |
| 16   | [RPUSH key value1 [value2\]](https://www.runoob.com/redis/lists-rpush.html)  在列表中添加一个或多个值 |
| 17   | [RPUSHX key value](https://www.runoob.com/redis/lists-rpushx.html)  为已存在的列表添加值 |

```
list即可以作为“栈”也可以作为"队列"。
操作：
>lpush list1 "world"  //在list1头部压入一个字串
>lpush list1 "hello"  // 在list1头部压入一个字串
>lrange list1 0 -1  //获取list1中内容
    0:表示开头  -1表示结尾。

>rpush list2 "world"  //在list2尾部压入一个字串
>rpush list2 "hello"  // 在list2尾部压入一个字串
>lrange list2 0 -1  //获取list2中内容
    0:表示开头  -1表示结尾。

>linsert list2 before hello there
在key对应list的特定位置前或后添加字符串

>lset list2 1 "four"
修改指定索引位置上的值

>lrem list2 2 "hello"  //删除前两个hello值
>lrem list2 -2 "hello" //删除后两个hello值
>lrem list2 0 "hello"  //删除所有hello值

>ltrim mylist8 1 3    //删除此范围外的值

>lpop list2   //从list2的头部删除元素，并返回删除元素
>rpop list2   //从list2的尾部删除元素，并返回删除元素
>rpoplpush list1 list2    //将list1的尾部一个元素移出到list2头部。并返回

>lindex list2 1 //返回list2中索引位置上的元素
>llen list2 //返回list2上长度
```



## Redis 集合(Set)

> Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。
>
> Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。
>
> 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。

**实例**

```
redis 127.0.0.1:6379> SADD runoobkey redis
(integer) 1
redis 127.0.0.1:6379> SADD runoobkey mongodb
(integer) 1
redis 127.0.0.1:6379> SADD runoobkey mysql
(integer) 1
redis 127.0.0.1:6379> SADD runoobkey mysql
(integer) 0
redis 127.0.0.1:6379> SMEMBERS runoobkey

1) "mysql"
2) "mongodb"
3) "redis"
```

在以上实例中我们通过 **SADD** 命令向名为 **runoobkey** 的集合插入的三个元素。

**Redis 集合命令**

下表列出了 Redis 集合基本命令：

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [SADD key member1 [member2\]](https://www.runoob.com/redis/sets-sadd.html)  向集合添加一个或多个成员 |
| 2    | [SCARD key](https://www.runoob.com/redis/sets-scard.html)  获取集合的成员数 |
| 3    | [SDIFF key1 [key2\]](https://www.runoob.com/redis/sets-sdiff.html)  返回给定所有集合的差集 |
| 4    | [SDIFFSTORE destination key1 [key2\]](https://www.runoob.com/redis/sets-sdiffstore.html)  返回给定所有集合的差集并存储在 destination 中 |
| 5    | [SINTER key1 [key2\]](https://www.runoob.com/redis/sets-sinter.html)  返回给定所有集合的交集 |
| 6    | [SINTERSTORE destination key1 [key2\]](https://www.runoob.com/redis/sets-sinterstore.html)  返回给定所有集合的交集并存储在 destination 中 |
| 7    | [SISMEMBER key member](https://www.runoob.com/redis/sets-sismember.html)  判断 member 元素是否是集合 key 的成员 |
| 8    | [SMEMBERS key](https://www.runoob.com/redis/sets-smembers.html)  返回集合中的所有成员 |
| 9    | [SMOVE source destination member](https://www.runoob.com/redis/sets-smove.html)  将 member 元素从 source 集合移动到 destination 集合 |
| 10   | [SPOP key](https://www.runoob.com/redis/sets-spop.html)  移除并返回集合中的一个随机元素 |
| 11   | [SRANDMEMBER key [count\]](https://www.runoob.com/redis/sets-srandmember.html)  返回集合中一个或多个随机数 |
| 12   | [SREM key member1 [member2\]](https://www.runoob.com/redis/sets-srem.html)  移除集合中一个或多个成员 |
| 13   | [SUNION key1 [key2\]](https://www.runoob.com/redis/sets-sunion.html)  返回所有给定集合的并集 |
| 14   | [SUNIONSTORE destination key1 [key2\]](https://www.runoob.com/redis/sets-sunionstore.html)  所有给定集合的并集存储在 destination 集合中 |
| 15   | [SSCAN key cursor [MATCH pattern\] [COUNT count]](https://www.runoob.com/redis/sets-sscan.html)  迭代集合中的元素 |

```
>sadd myset "hello" //向myset中添加一个元素
 成功返回1，失败(重复)返回0

>smembers myset //获取myset中的所有元素(结果是无序的)

>srem myset "one" //从myset中删除一个one
 成功返回1，失败(不存在)返回0

>spop myset //随机返回并删除myset中的一个元素
>srandmember myset //随机获取myset中的一个元素，但是不删除

> smove myset1 myset2 zhangsan:将myset1中zhangsan移动到myset2中
> scard myset1 返回myset1的个数
> sismember myset zhangsan:判断张三是否在myset中

>sdiff myset1 myset2 //返回两个集合的差集
以myset1为标准，获取myset2中不存在的。
>sdiffstore dstset myset1 myset2 ...// 返回所有集合的差集，并保存到dstset中

>sinter myset1 myset2 myset3... // 返回N个集合中的交集
>sinterstore dstset myset1 myset2 ... // 返回N个集合的交集并存储到dstset中

> sunion myset1 myset2 ...//返回所有集合的并集
> sunionstore dstset myset1 myset2// 返回所有集合的并集，并存储到dstset中
```



## Redis 有序集合(sorted set)

> Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。
>
> 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
>
> 有序集合的成员是唯一的,但分数(score)却可以重复。
>
> 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。

**实例**

```
redis 127.0.0.1:6379> ZADD runoobkey 1 redis
(integer) 1
redis 127.0.0.1:6379> ZADD runoobkey 2 mongodb
(integer) 1
redis 127.0.0.1:6379> ZADD runoobkey 3 mysql
(integer) 1
redis 127.0.0.1:6379> ZADD runoobkey 3 mysql
(integer) 0
redis 127.0.0.1:6379> ZADD runoobkey 4 mysql
(integer) 0
redis 127.0.0.1:6379> ZRANGE runoobkey 0 10 WITHSCORES

1) "redis"
2) "1"
3) "mongodb"
4) "2"
5) "mysql"
6) "4"
```

在以上实例中我们通过命令 **ZADD** 向 redis 的有序集合中添加了三个值并关联上分数。

**Redis 有序集合命令**

下表列出了 redis 有序集合的基本命令:

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [ZADD key score1 member1 [score2 member2\]](https://www.runoob.com/redis/sorted-sets-zadd.html)  向有序集合添加一个或多个成员，或者更新已存在成员的分数 |
| 2    | [ZCARD key](https://www.runoob.com/redis/sorted-sets-zcard.html)  获取有序集合的成员数 |
| 3    | [ZCOUNT key min max](https://www.runoob.com/redis/sorted-sets-zcount.html)  计算在有序集合中指定区间分数的成员数 |
| 4    | [ZINCRBY key increment member](https://www.runoob.com/redis/sorted-sets-zincrby.html)  有序集合中对指定成员的分数加上增量 increment |
| 5    | [ZINTERSTORE destination numkeys key [key ...\]](https://www.runoob.com/redis/sorted-sets-zinterstore.html)  计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 |
| 6    | [ZLEXCOUNT key min max](https://www.runoob.com/redis/sorted-sets-zlexcount.html)  在有序集合中计算指定字典区间内成员数量 |
| 7    | [ZRANGE key start stop [WITHSCORES\]](https://www.runoob.com/redis/sorted-sets-zrange.html)  通过索引区间返回有序集合成指定区间内的成员 |
| 8    | [ZRANGEBYLEX key min max [LIMIT offset count\]](https://www.runoob.com/redis/sorted-sets-zrangebylex.html)  通过字典区间返回有序集合的成员 |
| 9    | [ZRANGEBYSCORE key min max [WITHSCORES\] [LIMIT]](https://www.runoob.com/redis/sorted-sets-zrangebyscore.html)  通过分数返回有序集合指定区间内的成员 |
| 10   | [ZRANK key member](https://www.runoob.com/redis/sorted-sets-zrank.html)  返回有序集合中指定成员的索引 |
| 11   | [ZREM key member [member ...\]](https://www.runoob.com/redis/sorted-sets-zrem.html)  移除有序集合中的一个或多个成员 |
| 12   | [ZREMRANGEBYLEX key min max](https://www.runoob.com/redis/sorted-sets-zremrangebylex.html)  移除有序集合中给定的字典区间的所有成员 |
| 13   | [ZREMRANGEBYRANK key start stop](https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html)  移除有序集合中给定的排名区间的所有成员 |
| 14   | [ZREMRANGEBYSCORE key min max](https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html)  移除有序集合中给定的分数区间的所有成员 |
| 15   | [ZREVRANGE key start stop [WITHSCORES\]](https://www.runoob.com/redis/sorted-sets-zrevrange.html)  返回有序集中指定区间内的成员，通过索引，分数从高到底 |
| 16   | [ZREVRANGEBYSCORE key max min [WITHSCORES\]](https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html)  返回有序集中指定分数区间内的成员，分数从高到低排序 |
| 17   | [ZREVRANK key member](https://www.runoob.com/redis/sorted-sets-zrevrank.html)  返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 |
| 18   | [ZSCORE key member](https://www.runoob.com/redis/sorted-sets-zscore.html)  返回有序集中，成员的分数值 |
| 19   | [ZUNIONSTORE destination numkeys key [key ...\]](https://www.runoob.com/redis/sorted-sets-zunionstore.html)  计算给定的一个或多个有序集的并集，并存储在新的 key 中 |
| 20   | [ZSCAN key cursor [MATCH pattern\] [COUNT count]](https://www.runoob.com/redis/sorted-sets-zscan.html)  迭代有序集合中的元素（包括元素成员和元素分值） |

```
> zadd zset 70 张三向zset中添加zhangsan，分数为70
> zrem zset zhangsan:删除zset中zhangsan

> zincrby zset 60 zhangsan:如果zhangsan存在，则分数增加60，如果zhangsan不存在，那么分数就是60

> zrange zset 0 -1 withscores:根据score排序（根据score从小到大排序）
> zrevrange zset 0 -1 withscores:根据score排序（根据score从大到小排序）

> zrank zset zhangsan:返回zhangsan在zset中排名(从小到大的排序)
> zrevrank zset zhangsan:返回zhangsan在zset中排名(从大到小的排序)

> zrangebyscore zset 60 80 withscores:返回集合中score在给定区间的元素（包含60和80）
> zcount zset 60 80:返回集合中给定区间的数量
> zcard zset:返回集合中元素的个数
> zscore zset zhangsan:返回zhangsan元素的score
> zremrangebyrank zset 3 3:删除集合中排名在给定区间的元素 (从小到大)
> zremrangebyscore zset 10 20:删除 zset中 分数在 指定区间的元素
```



## Redis 安全

我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。

**实例**

我们可以通过以下命令查看是否设置了密码验证：

```
127.0.0.1:6379> CONFIG get requirepass
1) "requirepass"
2) ""
```

默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。

你可以通过以下命令来修改该参数：

```
127.0.0.1:6379> CONFIG set requirepass "runoob"
OK
127.0.0.1:6379> CONFIG get requirepass
1) "requirepass"
2) "runoob"
```

设置密码后，客户端连接 redis 服务就需要密码验证，否则无法执行命令。

**语法**

**AUTH** 命令基本语法格式如下：

```
127.0.0.1:6379> AUTH password
```

**实例**

```
127.0.0.1:6379> AUTH "runoob"
OK
127.0.0.1:6379> SET mykey "Test value"
OK
127.0.0.1:6379> GET mykey
"Test value"
```

**配置文件为Redis的添加密码**

```
修改配置文件
sudo vim /etc/redis/redis.conf

设置：requirepass redis的密码

# requirepass foobared

requirepass abc123

重启服务
sudo service redis restart

登录（两种）
1.# ./redis-cli -a  密码 //连接时指定密码来进行授权
2.redis-cli 进入后发现操作不了时
  auth 密码
  OK
---------------------
windows 下设置密码生效

修改配置文件

启动服务 加载配置文件redis-server redis.conf  \(加载一次即可\)

启动客户端
```









## Redis 事务

Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：

- 批量操作在发送 EXEC 命令前被放入队列缓存。
- 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
- 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。

一个事务从开始到执行会经历以下三个阶段：

- 开始事务。
- 命令入队。
- 执行事务。

------

**实例**

以下是一个事务的例子， 它先以 **MULTI** 开始一个事务， 然后将多个命令入队到事务中， 最后由 **EXEC** 命令触发事务， 一并执行事务中的所有命令：

```
redis 127.0.0.1:6379> MULTI
OK

redis 127.0.0.1:6379> SET book-name "Mastering C++ in 21 days"
QUEUED

redis 127.0.0.1:6379> GET book-name
QUEUED

redis 127.0.0.1:6379> SADD tag "C++" "Programming" "Mastering Series"
QUEUED

redis 127.0.0.1:6379> SMEMBERS tag
QUEUED

redis 127.0.0.1:6379> EXEC
1) OK
2) "Mastering C++ in 21 days"
3) (integer) 3
4) 1) "Mastering Series"
   2) "C++"
   3) "Programming"
```

单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。

事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。

```
>multi   //开启一个事务
>set age 10 //暂存指令队列
>set age 20
>exec    //开始执行（提交事务）
或>discard //清空指令队列（事务回滚）
```



## Redis 乐观锁

```
Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断
在事务前对被操作的属性做一个：
> watch age
>multi   //开启一个事务(在此期间有其他修改，则此处会失败)
>set age 10 //暂存指令队列
>set age 20
>exec    //开始执行（提交事务）
或>discard //清空指令队列（事务回滚）
```



## Redis 持久化机制

**（通过修改配置文件做设置）**

```
1.snapshotting(快照)默认方式
   配置    save
   save 900 1 #900秒内如果超过1个key被修改，则发起快照保存
   save 300 10 #300秒内容如超过10个key被修改，则发起快照保存
   save 60 10000
2.Append-only file（aof方式）
   配置 appendonly on 改为yes
   会在bin目录下产生一个.aof的文件
   关于aof的配置
   appendonly yes //启用aof 持久化方式

   # appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化
     appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中
   # appendfsync no //完全依赖os，性能最好,持久化没保证
```



## Redis 发布订阅

> Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。
>
> Redis 客户端可以订阅任意数量的频道。

```
我们创建了订阅频道名为 redisChat:
redis 127.0.0.1:6379> SUBSCRIBE redisChat

Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "redisChat"
3) (integer) 1

现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。
redis 127.0.0.1:6379> PUBLISH redisChat "Redis is a great caching technique"
(integer) 1

redis 127.0.0.1:6379> PUBLISH redisChat "Learn redis by runoob.com"
(integer) 1

# 订阅者的客户端会显示如下消息
1) "message"
2) "redisChat"
3) "Redis is a great caching technique"
1) "message"
2) "redisChat"
3) "Learn redis by runoob.com"


----------------------------

序号    命令及描述
1    PSUBSCRIBE pattern [pattern ...] 订阅一个或多个符合给定模式的频道。
2    PUBSUB subcommand [argument [argument ...]] 查看订阅与发布系统状态。
3    PUBLISH channel message 将信息发送到指定的频道。
4    PUNSUBSCRIBE [pattern [pattern ...]] 退订所有给定模式的频道。
5    SUBSCRIBE channel [channel ...] 订阅给定的一个或多个频道的信息。
6    UNSUBSCRIBE [channel [channel ...]] 指退订给定的频道。
```



## Python 操作 Redis 

##### 1、redis连接

> redis提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。

> redis连接实例是线程安全的，可以直接将redis连接实例设置为一个全局变量，直接使用。如果需要另一个Redis实例（or Redis数据库）时，就需要重新创建redis连接实例来获取一个新的连接。同理，python的redis没有实现select命令。

安装redis

```
pip install redis
```

连接redis，加上decode_responses=True，写入的键值对中的value为str类型，不加这个参数写入的则为字节类型。

```
import redis   # 导入redis模块，通过python操作redis 也可以直接在redis主机的服务端操作缓存数据库

r = redis.Redis(host='localhost', port=6379, decode_responses=True)   # host是redis主机，需要redis服务端和客户端都启动 redis默认端口是6379
r.set('name', 'junxi')  # key是"foo" value是"bar" 将键值对存入redis缓存
print(r['name'])
print(r.get('name'))  # 取出键name对应的值
print(type(r.get('name')))
```

##### 2、连接池

> redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。
> 可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池

连接池

```
import redis    # 导入redis模块，通过python操作redis 也可以直接在redis主机的服务端操作缓存数据库

pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)   # host是redis主机，需要redis服务端和客户端都起着 redis默认端口是6379
r = redis.Redis(connection_pool=pool)
r.set('gender', 'male')     # key是"gender" value是"male" 将键值对存入redis缓存
print(r.get('gender'))      # gender 取出键male对应的值
```

##### 3、String 基本命令

set(name, value, ex=None, px=None, nx=False, xx=False)

在Redis中设置值，默认，不存在则创建，存在则修改
 参数：
 ex，过期时间（秒）
 px，过期时间（毫秒）
 nx，如果设置为True，则只有name不存在时，当前set操作才执行
 xx，如果设置为True，则只有name存在时，当前set操作才执行

1.ex，过期时间（秒） 这里过期时间是3秒，3秒后p，键food的值就变成None

```
import redis

pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)
r = redis.Redis(connection_pool=pool)
r.set('food', 'mutton', ex=3)    # key是"food" value是"mutton" 将键值对存入redis缓存
print(r.get('food'))  # mutton 取出键food对应的值
```

2.px，过期时间（豪秒） 这里过期时间是3豪秒，3毫秒后，键foo的值就变成None

```
import redis

pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)
r = redis.Redis(connection_pool=pool)
r.set('food', 'beef', px=3)
print(r.get('food'))
```

3.nx，如果设置为True，则只有name不存在时，当前set操作才执行 （新建）

```
import redis

pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)
r = redis.Redis(connection_pool=pool)
print(r.set('fruit', 'watermelon', nx=True))    # True--不存在
# 如果键fruit不存在，那么输出是True；如果键fruit已经存在，输出是None
```

4.xx，如果设置为True，则只有name存在时，当前set操作才执行 （修改）

```
print((r.set('fruit', 'watermelon', xx=True)))   # True--已经存在
# 如果键fruit已经存在，那么输出是True；如果键fruit不存在，输出是None
```

5.setnx(name, value)
 设置值，只有name不存在时，执行设置操作（添加）

```
print(r.setnx('fruit1', 'banana'))  # fruit1不存在，输出为True
```

6.setex(name, value, time)
 设置值
 参数：
 time，过期时间（数字秒 或 timedelta对象）

```
import redis
import time

pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)
r = redis.Redis(connection_pool=pool)
r.setex("fruit2", "orange", 5)
time.sleep(5)
print(r.get('fruit2'))  # 5秒后，取值就从orange变成None
```

7.psetex(name, time_ms, value)
 设置值
 参数：
 time_ms，过期时间（数字毫秒 或 timedelta对象）

```
r.psetex("fruit3", 5000, "apple")
time.sleep(5)
print(r.get('fruit3'))  # 5000毫秒后，取值就从apple变成None
```

8.mset(*args, **kwargs)
 批量设置值
 如：

```
r.mget({'k1': 'v1', 'k2': 'v2'})
r.mset(k1="v1", k2="v2") # 这里k1 和k2 不能带引号 一次设置对个键值对
print(r.mget("k1", "k2"))   # 一次取出多个键对应的值
print(r.mget("k1"))
```

9.mget(keys, *args)
 批量获取
 如：

```
print(r.mget('k1', 'k2'))
print(r.mget(['k1', 'k2']))
print(r.mget("fruit", "fruit1", "fruit2", "k1", "k2"))  # 将目前redis缓存中的键对应的值批量取出来
```

10.getset(name, value)
 设置新值并获取原来的值

```
print(r.getset("food", "barbecue"))  # 设置的新值是barbecue 设置前的值是beef
```

11.getrange(key, start, end)
 获取子序列（根据字节获取，非字符）
 参数：
 name，Redis 的 name
 start，起始位置（字节）
 end，结束位置（字节）
 如： "君惜大大" ，0-3表示 "君"

```
r.set("cn_name", "君惜大大") # 汉字
print(r.getrange("cn_name", 0, 2))   # 取索引号是0-2 前3位的字节 君 切片操作 （一个汉字3个字节 1个字母一个字节 每个字节8bit）
print(r.getrange("cn_name", 0, -1))  # 取所有的字节 君惜大大 切片操作
r.set("en_name","junxi") # 字母
print(r.getrange("en_name", 0, 2))  # 取索引号是0-2 前3位的字节 jun 切片操作 （一个汉字3个字节 1个字母一个字节 每个字节8bit）
print(r.getrange("en_name", 0, -1)) # 取所有的字节 junxi 切片操作
```

12.setrange(name, offset, value)
 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）
 参数：
 offset，字符串的索引，字节（一个汉字三个字节）
 value，要设置的值

```
r.setrange("en_name", 1, "ccc")
print(r.get("en_name"))    # jccci 原始值是junxi 从索引号是1开始替换成ccc 变成 jccci
```

13.setbit(name, offset, value)
 对name对应值的二进制表示的位进行操作
 参数：
 name，redis的name
 offset，位的索引（将值变换成二进制后再进行索引）
 value，值只能是 1 或 0

```
注：如果在Redis中有一个对应： n1 = "foo"，
那么字符串foo的二进制表示为：01100110 01101111 01101111
所以，如果执行 setbit('n1', 7, 1)，则就会将第7位设置为1，
那么最终二进制则变成 01100111 01101111 01101111，即："goo"

扩展，转换二进制表示：
source = "陈思维"
source = "foo"
for i in source:
num = ord(i)
print bin(num).replace('b','')
特别的，如果source是汉字 "陈思维"怎么办？
答：对于utf-8，每一个汉字占 3 个字节，那么 "陈思维" 则有 9个字节
对于汉字，for循环时候会按照 字节 迭代，那么在迭代时，将每一个字节转换 十进制数，然后再将十进制数转换成二进制
11100110 10101101 10100110 11100110 10110010 10011011 11101001 10111101 10010000
```

14.getbit(name, offset)
 获取name对应的值的二进制表示中的某位的值 （0或1）

```
print(r.getbit("foo1", 0)) # 0 foo1 对应的二进制 4个字节 32位 第0位是0还是1
```

15.bitcount(key, start=None, end=None)
 获取name对应的值的二进制表示中 1 的个数
 参数：
 key，Redis的name
 start 字节起始位置
 end，字节结束位置

```
print(r.get("foo"))  # goo1 01100111
print(r.bitcount("foo",0,1))  # 11 表示前2个字节中，1出现的个数
```

16.bitop(operation, dest, *keys)
 获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值

参数：
 operation,AND（并） 、 OR（或） 、 NOT（非） 、 XOR（异或）
 dest, 新的Redis的name
 *keys,要查找的Redis的name

如：

```
bitop("AND", 'new_name', 'n1', 'n2', 'n3')
获取Redis中n1,n2,n3对应的值，然后讲所有的值做位运算（求并集），然后将结果保存 new_name 对应的值中
r.set("foo","1")  # 0110001
r.set("foo1","2")  # 0110010
print(r.mget("foo","foo1"))  # ['goo1', 'baaanew']
print(r.bitop("AND","new","foo","foo1"))  # "new" 0 0110000
print(r.mget("foo","foo1","new"))

source = "12"
for i in source:
num = ord(i)
print(num)  # 打印每个字母字符或者汉字字符对应的ascii码值 f-102-0b100111-01100111
print(bin(num))  # 打印每个10进制ascii码值转换成二进制的值 0b1100110（0b表示二进制）
print bin(num).replace('b','')  # 将二进制0b1100110替换成01100110
```

17.strlen(name)
 返回name对应值的字节长度（一个汉字3个字节）

```
print(r.strlen("foo"))  # 4 'goo1'的长度是4
```

18.incr(self, name, amount=1)
 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。
 参数：
 name,Redis的name
 amount,自增数（必须是整数）
 注：同incrby

```
r.set("foo", 123)
print(r.mget("foo", "foo1", "foo2", "k1", "k2"))
r.incr("foo", amount=1)
print(r.mget("foo", "foo1", "foo2", "k1", "k2"))
```

应用场景 – 页面点击数
 假定我们对一系列页面需要记录点击次数。例如论坛的每个帖子都要记录点击次数，而点击次数比回帖的次数的多得多。如果使用关系数据库来存储点击，可能存在大量的行级锁争用。所以，点击数的增加使用redis的INCR命令最好不过了。
 当redis服务器启动时，可以从关系数据库读入点击数的初始值（12306这个页面被访问了34634次）

```
r.set("visit:12306:totals", 34634)
print(r.get("visit:12306:totals"))
```

每当有一个页面点击，则使用INCR增加点击数即可。

```
r.incr("visit:12306:totals")
r.incr("visit:12306:totals")
```

页面载入的时候则可直接获取这个值

```
print(r.get("visit:12306:totals"))
```

19.incrbyfloat(self, name, amount=1.0)
 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。
 参数：
 name,Redis的name
 amount,自增数（浮点型）

```
r.set("foo1", "123.0")
r.set("foo2", "221.0")
print(r.mget("foo1", "foo2"))
r.incrbyfloat("foo1", amount=2.0)
r.incrbyfloat("foo2", amount=3.0)
print(r.mget("foo1", "foo2"))
```

20.decr(self, name, amount=1)
 自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。
 参数：
 name,Redis的name
 amount,自减数（整数)

```
r.decr("foo4", amount=3) # 递减3
r.decr("foo1", amount=1) # 递减1
print(r.mget("foo1", "foo4"))
```

21.append(key, value)
 在redis name对应的值后面追加内容
 参数：
 key, redis的name
 value, 要追加的字符串

```
r.append("name", "haha")    # 在name对应的值junxi后面追加字符串haha
print(r.mget("name"))
```

##### 4、hash 基本命令

1.单个增加--修改(单个取出)--没有就新增，有的话就修改
 hset(name, key, value)
 name对应的hash中设置一个键值对（不存在，则创建；否则，修改）
 参数：
 name，redis的name
 key，name对应的hash中的key
 value，name对应的hash中的value
 注：
 hsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）

```
import redis
import time

pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)
r = redis.Redis(connection_pool=pool)

r.hset("hash1", "k1", "v1")
r.hset("hash1", "k2", "v2")
print(r.hkeys("hash1")) # 取hash中所有的key
print(r.hget("hash1", "k1"))    # 单个取hash的key对应的值
print(r.hmget("hash1", "k1", "k2")) # 多个取hash的key对应的值
r.hsetnx("hash1", "k2", "v3") # 只能新建
print(r.hget("hash1", "k2"))
```

2 批量增加（取出）
 hmset(name, mapping)
 在name对应的hash中批量设置键值对
 参数：
 name，redis的name
 mapping，字典，如：{'k1':'v1', 'k2': 'v2'}
 如：

```
r.hmset("hash2", {"k2": "v2", "k3": "v3"})
```

hget(name,key)
 在name对应的hash中获取根据key获取value
 hmget(name, keys, *args)
 在name对应的hash中获取多个key的值
 参数：
 name，reids对应的name
 keys，要获取key集合，如：['k1', 'k2', 'k3']
 *args，要获取的key，如：k1,k2,k3
 如：

```
print(r.hget("hash2", "k2"))  # 单个取出"hash2"的key-k2对应的value
print(r.hmget("hash2", "k2", "k3"))  # 批量取出"hash2"的key-k2 k3对应的value --方式1
print(r.hmget("hash2", ["k2", "k3"]))  # 批量取出"hash2"的key-k2 k3对应的value --方式2
```

3.取出所有的键值对
 hgetall(name)
 获取name对应hash的所有键值

```
print(r.hgetall("hash1"))
```

4.得到所有键值对的格式 hash长度
 hlen(name)
 获取name对应的hash中键值对的个数

```
print(r.hlen("hash1"))
```

5.得到所有的keys（类似字典的取所有keys）
 hkeys(name)
 获取name对应的hash中所有的key的值

```
print(r.hkeys("hash1"))
```

6.得到所有的value（类似字典的取所有value）
 hvals(name)
 获取name对应的hash中所有的value的值

```
print(r.hvals("hash1"))
```

7.判断成员是否存在（类似字典的in）
 hexists(name, key)
 检查name对应的hash是否存在当前传入的key

```
print(r.hexists("hash1", "k4"))  # False 不存在
print(r.hexists("hash1", "k1"))  # True 存在
```

8.删除键值对
 hdel(name,*keys)
 将name对应的hash中指定key的键值对删除

```
print(r.hgetall("hash1"))
r.hset("hash1", "k2", "v222")   # 修改已有的key k2
r.hset("hash1", "k11", "v1")   # 新增键值对 k11
r.hdel("hash1", "k1")    # 删除一个键值对
print(r.hgetall("hash1"))
```

9.自增自减整数(将key对应的value--整数 自增1或者2，或者别的整数 负数就是自减)
 hincrby(name, key, amount=1)
 自增name对应的hash中的指定key的值，不存在则创建key=amount
 参数：
 name，redis中的name
 key， hash对应的key
 amount，自增数（整数）

```
r.hset("hash1", "k3", 123)
r.hincrby("hash1", "k3", amount=-1)
print(r.hgetall("hash1"))
r.hincrby("hash1", "k4", amount=1)  # 不存在的话，value默认就是1
print(r.hgetall("hash1"))
```

10.自增自减浮点数(将key对应的value--浮点数 自增1.0或者2.0，或者别的浮点数 负数就是自减)
 hincrbyfloat(name, key, amount=1.0)
 自增name对应的hash中的指定key的值，不存在则创建key=amount
 参数：
 name，redis中的name
 key， hash对应的key
 amount，自增数（浮点数）
 自增name对应的hash中的指定key的值，不存在则创建key=amount

```
r.hset("hash1", "k5", "1.0")
r.hincrbyfloat("hash1", "k5", amount=-1.0)    # 已经存在，递减-1.0
print(r.hgetall("hash1"))
r.hincrbyfloat("hash1", "k6", amount=-1.0)    # 不存在，value初始值是-1.0 每次递减1.0
print(r.hgetall("hash1"))
```

11.取值查看--分片读取
 hscan(name, cursor=0, match=None, count=None)
 增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆
 参数：
 name，redis的name
 cursor，游标（基于游标分批取获取数据）
 match，匹配指定key，默认None 表示所有的key
 count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数
 如：
 第一次：cursor1, data1 = r.hscan('xx', cursor=0, match=None, count=None)
 第二次：cursor2, data1 = r.hscan('xx', cursor=cursor1, match=None, count=None)
 ...
 直到返回值cursor的值为0时，表示数据已经通过分片获取完毕

```
print(r.hscan("hash1"))
```

12.hscan_iter(name, match=None, count=None)
 利用yield封装hscan创建生成器，实现分批去redis中获取数据
 参数：
 match，匹配指定key，默认None 表示所有的key
 count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数
 如：

```
for item in r.hscan_iter('hash1'):
    print(item)
print(r.hscan_iter("hash1"))    # 生成器内存地址
```

##### 5、list 基本命令

1.增加（类似于list的append，只是这里是从左边新增加）--没有就新建
 lpush(name,values)
 在name对应的list中添加元素，每个新的元素都添加到列表的最左边
 如：

```
import redis
import time

pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)
r = redis.Redis(connection_pool=pool)

r.lpush("list1", 11, 22, 33)
print(r.lrange('list1', 0, -1))
```

保存顺序为: 33,22,11

扩展：

```
r.rpush("list2", 11, 22, 33)  # 表示从右向左操作
print(r.llen("list2"))  # 列表长度
print(r.lrange("list2", 0, 3))  # 切片取出值，范围是索引号0-3
```

2.增加（从右边增加）--没有就新建

```
r.rpush("list2", 44, 55, 66)    # 在列表的右边，依次添加44,55,66
print(r.llen("list2"))  # 列表长度
print(r.lrange("list2", 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素)
```

3.往已经有的name的列表的左边添加元素，没有的话无法创建
 lpushx(name,value)
 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边
 更多：

```
r.lpushx("list10", 10)   # 这里list10不存在
print(r.llen("list10"))  # 0
print(r.lrange("list10", 0, -1))  # []
r.lpushx("list2", 77)   # 这里"list2"之前已经存在，往列表最左边添加一个元素，一次只能添加一个
print(r.llen("list2"))  # 列表长度
print(r.lrange("list2", 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素
```

4.往已经有的name的列表的右边添加元素，没有的话无法创建

```
r.rpushx("list2", 99)   # 这里"foo_list1"之前已经存在，往列表最右边添加一个元素，一次只能添加一个
print(r.llen("list2"))  # 列表长度
print(r.lrange("list2", 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素)
```

5.新增（固定索引号位置插入元素）
 linsert(name, where, refvalue, value))
 在name对应的列表的某一个值前或后插入一个新值
 参数：
 name，redis的name
 where，BEFORE或AFTER
 refvalue，标杆值，即：在它前后插入数据
 value，要插入的数据

```
r.linsert("list2", "before", "11", "00")   # 往列表中左边第一个出现的元素"11"前插入元素"00"
print(r.lrange("list2", 0, -1))   # 切片取出值，范围是索引号0-最后一个元素
```

6.修改（指定索引号进行修改）
 r.lset(name, index, value)
 对name对应的list中的某一个索引位置重新赋值
 参数：
 name，redis的name
 index，list的索引位置
 value，要设置的值

```
r.lset("list2", 0, -11)    # 把索引号是0的元素修改成-11
print(r.lrange("list2", 0, -1))
```

7.删除（指定值进行删除）
 r.lrem(name, value, num)
 在name对应的list中删除指定的值
 参数：
 name，redis的name
 value，要删除的值
 num， num=0，删除列表中所有的指定值；
 num=2,从前到后，删除2个； num=1,从前到后，删除左边第1个
 num=-2,从后向前，删除2个

```
r.lrem("list2", "11", 1)    # 将列表中左边第一次出现的"11"删除
print(r.lrange("list2", 0, -1))
r.lrem("list2", "99", -1)    # 将列表中右边第一次出现的"99"删除
print(r.lrange("list2", 0, -1))
r.lrem("list2", "22", 0)    # 将列表中所有的"22"删除
print(r.lrange("list2", 0, -1))
```

8.删除并返回
 lpop(name)
 在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素
 更多：
 rpop(name) 表示从右向左操作

```
r.lpop("list2")    # 删除列表最左边的元素，并且返回删除的元素
print(r.lrange("list2", 0, -1))
r.rpop("list2")    # 删除列表最右边的元素，并且返回删除的元素
print(r.lrange("list2", 0, -1))
```

9.删除索引之外的值
 ltrim(name, start, end)
 在name对应的列表中移除没有在start-end索引之间的值
 参数：
 name，redis的name
 start，索引的起始位置
 end，索引结束位置

```
r.ltrim("list2", 0, 2)    # 删除索引号是0-2之外的元素，值保留索引号是0-2的元素
print(r.lrange("list2", 0, -1))
```

10.取值（根据索引号取值）
 lindex(name, index)
 在name对应的列表中根据索引获取列表元素

```
print(r.lindex("list2", 0))  # 取出索引号是0的值
```

11.移动  元素从一个列表移动到另外一个列表
 rpoplpush(src, dst)
 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边
 参数：
 src，要取数据的列表的name
 dst，要添加数据的列表的name

```
r.rpoplpush("list1", "list2")
print(r.lrange("list2", 0, -1))
```

12.移动  元素从一个列表移动到另外一个列表 可以设置超时
 brpoplpush(src, dst, timeout=0)
 从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧
 参数：
 src，取出并要移除元素的列表对应的name
 dst，要插入元素的列表对应的name
 timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞

```
r.brpoplpush("list1", "list2", timeout=2)
print(r.lrange("list2", 0, -1))
```

13.一次移除多个列表
 blpop(keys, timeout)
 将多个列表排列，按照从左到右去pop对应列表的元素
 参数：
 keys，redis的name的集合
 timeout，超时时间，当元素所有列表的元素获取完之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞
 更多：
 r.brpop(keys, timeout)  同blpop，将多个列表排列,按照从右像左去移除各个列表内的元素

```
r.lpush("list10", 3, 4, 5)
r.lpush("list11", 3, 4, 5)
while True:
    r.blpop(["list10", "list11"], timeout=2)
    print(r.lrange("list10", 0, -1), r.lrange("list11", 0, -1))
```

14.自定义增量迭代
 由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：

1. 获取name对应的所有列表
2. 循环列表

但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：

```
def list_iter(name):
    """
    自定义redis列表增量迭代
    :param name: redis中的name，即：迭代name对应的列表
    :return: yield 返回 列表元素
    """
    list_count = r.llen(name)
    for index in range(list_count):
        yield r.lindex(name, index)

# 使用
for item in list_iter('list2'): # 遍历这个列表
    print(item)
```

##### 6、set 基本命令

1.新增
 sadd(name,values)
 name对应的集合中添加元素

```
r.sadd("set1", 33, 44, 55, 66)  # 往集合中添加元素
print(r.scard("set1"))  # 集合的长度是4
print(r.smembers("set1"))   # 获取集合中所有的成员
```

2.获取元素个数 类似于len
 scard(name)
 获取name对应的集合中元素个数

```
print(r.scard("set1"))  # 集合的长度是4
```

3.获取集合中所有的成员
 smembers(name)
 获取name对应的集合的所有成员

```
print(r.smembers("set1"))   # 获取集合中所有的成员
```

获取集合中所有的成员--元组形式
 sscan(name, cursor=0, match=None, count=None)

```
print(r.sscan("set1"))
```

获取集合中所有的成员--迭代器的方式
 sscan_iter(name, match=None, count=None)
 同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大

```
for i in r.sscan_iter("set1"):
    print(i)
```

4.差集
 sdiff(keys, *args)
 在第一个name对应的集合中且不在其他name对应的集合的元素集合

```
r.sadd("set2", 11, 22, 33)
print(r.smembers("set1"))   # 获取集合中所有的成员
print(r.smembers("set2"))
print(r.sdiff("set1", "set2"))   # 在集合set1但是不在集合set2中
print(r.sdiff("set2", "set1"))   # 在集合set2但是不在集合set1中
```

5.差集--差集存在一个新的集合中
 sdiffstore(dest, keys, *args)
 获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中

```
r.sdiffstore("set3", "set1", "set2")    # 在集合set1但是不在集合set2中
print(r.smembers("set3"))   # 获取集合3中所有的成员
```

6.交集
 sinter(keys, *args)
 获取多一个name对应集合的交集

```
print(r.sinter("set1", "set2")) # 取2个集合的交集
```

7.交集--交集存在一个新的集合中
 sinterstore(dest, keys, *args)
 获取多一个name对应集合的并集，再将其加入到dest对应的集合中

```
print(r.sinterstore("set3", "set1", "set2")) # 取2个集合的交集
print(r.smembers("set3"))
```

并集
 sunion(keys, *args)
 获取多个name对应的集合的并集

```
print(r.sunion("set1", "set2")) # 取2个集合的并集
```

并集--并集存在一个新的集合
 sunionstore(dest,keys, *args)
 获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中

```
print(r.sunionstore("set3", "set1", "set2")) # 取2个集合的并集
print(r.smembers("set3"))
```

8.判断是否是集合的成员 类似in
 sismember(name, value)
 检查value是否是name对应的集合的成员，结果为True和False

```
print(r.sismember("set1", 33))  # 33是集合的成员
print(r.sismember("set1", 23))  # 23不是集合的成员
```

9.移动
 smove(src, dst, value)
 将某个成员从一个集合中移动到另外一个集合

```
r.smove("set1", "set2", 44)
print(r.smembers("set1"))
print(r.smembers("set2"))
```

10.删除--随机删除并且返回被删除值
 spop(name)
 从集合移除一个成员，并将其返回,说明一下，集合是无序的，所有是随机删除的

```
print(r.spop("set2"))   # 这个删除的值是随机删除的，集合是无序的
print(r.smembers("set2"))
```

11.删除--指定值删除
 srem(name, values)
 在name对应的集合中删除某些值

```
print(r.srem("set2", 11))   # 从集合中删除指定值 11
print(r.smembers("set2"))
```

##### 7、 有序set 基本命令

Set操作，Set集合就是不允许重复的列表，本身是无序的
 有序集合，在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，
 所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序。

1.新增
 zadd(name, *args, **kwargs)
 在name对应的有序集合中添加元素
 如：

```
import redis
import time

pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)
r = redis.Redis(connection_pool=pool)

r.zadd("zset1", n1=11, n2=22)
r.zadd("zset2", 'm1', 22, 'm2', 44)
print(r.zcard("zset1")) # 集合长度
print(r.zcard("zset2")) # 集合长度
print(r.zrange("zset1", 0, -1))   # 获取有序集合中所有元素
print(r.zrange("zset2", 0, -1, withscores=True))   # 获取有序集合中所有元素和分数
```

2.获取有序集合元素个数 类似于len
 zcard(name)
 获取name对应的有序集合元素的数量

```
print(r.zcard("zset1")) # 集合长度
```

3.获取有序集合的所有元素
 r.zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)
 按照索引范围获取name对应的有序集合的元素
 参数：
 name，redis的name
 start，有序集合索引起始位置（非分数）
 end，有序集合索引结束位置（非分数）
 desc，排序规则，默认按照分数从小到大排序
 withscores，是否获取元素的分数，默认只获取元素的值
 score_cast_func，对分数进行数据转换的函数

3-1 从大到小排序(同zrange，集合是从大到小排序的)
 zrevrange(name, start, end, withscores=False, score_cast_func=float)

```
print(r.zrevrange("zset1", 0, -1))    # 只获取元素，不显示分数
print(r.zrevrange("zset1", 0, -1, withscores=True)) # 获取有序集合中所有元素和分数,分数倒序
```

3-2 按照分数范围获取name对应的有序集合的元素
 zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)

```
for i in range(1, 30):
   element = 'n' + str(i)
   r.zadd("zset3", element, i)
print(r.zrangebyscore("zset3", 15, 25)) # # 在分数是15-25之间，取出符合条件的元素
print(r.zrangebyscore("zset3", 12, 22, withscores=True))    # 在分数是12-22之间，取出符合条件的元素（带分数）
```

3-3 按照分数范围获取有序集合的元素并排序（默认从大到小排序）
 zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=float)

```
print(r.zrevrangebyscore("zset3", 22, 11, withscores=True)) # 在分数是22-11之间，取出符合条件的元素 按照分数倒序
```

3-4 获取所有元素--默认按照分数顺序排序
 zscan(name, cursor=0, match=None, count=None, score_cast_func=float)

```
print(r.zscan("zset3"))
```

3-5 获取所有元素--迭代器
 zscan_iter(name, match=None, count=None,score_cast_func=float)

```
for i in r.zscan_iter("zset3"): # 遍历迭代器
    print(i)
```

4.zcount(name, min, max)
 获取name对应的有序集合中分数 在 [min,max] 之间的个数

```
print(r.zrange("zset3", 0, -1, withscores=True))
print(r.zcount("zset3", 11, 22))
```

5.自增
 zincrby(name, value, amount)
 自增name对应的有序集合的 name 对应的分数

```
r.zincrby("zset3", "n2", amount=2)    # 每次将n2的分数自增2
print(r.zrange("zset3", 0, -1, withscores=True))
```

6.获取值的索引号
 zrank(name, value)
 获取某个值在 name对应的有序集合中的索引（从 0 开始）
 更多：
 zrevrank(name, value)，从大到小排序

```
print(r.zrank("zset3", "n1"))   # n1的索引号是0 这里按照分数顺序（从小到大）
print(r.zrank("zset3", "n6"))   # n6的索引号是1

print(r.zrevrank("zset3", "n1"))    # n1的索引号是29 这里安照分数倒序（从大到小）
```

7.删除--指定值删除
 zrem(name, values)
 删除name对应的有序集合中值是values的成员

```
r.zrem("zset3", "n3")   # 删除有序集合中的元素n3 删除单个
print(r.zrange("zset3", 0, -1))
```

8.删除--根据排行范围删除，按照索引号来删除
 zremrangebyrank(name, min, max)
 根据排行范围删除

```
r.zremrangebyrank("zset3", 0, 1)  # 删除有序集合中的索引号是0, 1的元素
print(r.zrange("zset3", 0, -1))
```

9.删除--根据分数范围删除
 zremrangebyscore(name, min, max)
 根据分数范围删除

```
r.zremrangebyscore("zset3", 11, 22)   # 删除有序集合中的分数是11-22的元素
print(r.zrange("zset3", 0, -1))
```

10.获取值对应的分数
 zscore(name, value)
 获取name对应有序集合中 value 对应的分数

```
print(r.zscore("zset3", "n27"))   # 获取元素n27对应的分数27
```

##### 8、其他常用操作

1.删除
 delete(*names)
 根据删除redis中的任意数据类型（string、hash、list、set、有序set）

```
r.delete("gender")  # 删除key为gender的键值对
```

2.检查名字是否存在
 exists(name)
 检测redis的name是否存在，存在就是True，False 不存在

```
print(r.exists("zset1"))
```

3.模糊匹配
 keys(pattern='*') 根据模型获取redis的name 更多： KEYS \* 匹配数据库中所有 key 。 KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。 KEYS h*llo 匹配 hllo 和 heeeeello 等。
 KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo

```
print(r.keys("foo*"))
```

4.设置超时时间
 expire(name ,time)
 为某个redis的某个name设置超时时间

```
r.lpush("list5", 11, 22)
r.expire("list5", time=3)
print(r.lrange("list5", 0, -1))
time.sleep(3)
print(r.lrange("list5", 0, -1))
```

5.重命名
 rename(src, dst)
 对redis的name重命名

```
r.lpush("list5", 11, 22)
r.rename("list5", "list5-1")
```

6.随机获取name
 randomkey()
 随机获取一个redis的name（不删除）

```
print(r.randomkey())
```

7.获取类型
 type(name)
 获取name对应值的类型

```
print(r.type("set1"))
print(r.type("hash2"))
```

8.查看所有元素
 scan(cursor=0, match=None, count=None)

```
print(r.hscan("hash2"))
print(r.sscan("set3"))
print(r.zscan("zset2"))
print(r.getrange("foo1", 0, -1))
print(r.lrange("list2", 0, -1))
print(r.smembers("set3"))
print(r.zrange("zset3", 0, -1))
print(r.hgetall("hash1"))
```

9.查看所有元素--迭代器
 scan_iter(match=None, count=None)

```
for i in r.hscan_iter("hash1"):
    print(i)

for i in r.sscan_iter("set3"):
    print(i)

for i in r.zscan_iter("zset3"):
    print(i)
```

**other 方法**

```
print(r.get('name'))    # 查询key为name的值
r.delete("gender")  # 删除key为gender的键值对
print(r.keys()) # 查询所有的Key
print(r.dbsize())   # 当前redis包含多少条数据
r.save()    # 执行"检查点"操作，将数据写回磁盘。保存时阻塞
# r.flushdb()        # 清空r中的所有数据
```

**管道（pipeline）**
 redis默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，
 如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。

管道（pipeline）是redis在提供单个请求中缓冲多条服务器命令的基类的子类。它通过减少服务器-客户端之间反复的TCP数据库包，从而大大提高了执行批量命令的功能。

```
import redis
import time

pool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)
r = redis.Redis(connection_pool=pool)

# pipe = r.pipeline(transaction=False)    # 默认的情况下，管道里执行的命令可以保证执行的原子性，执行pipe = r.pipeline(transaction=False)可以禁用这一特性。
# pipe = r.pipeline(transaction=True)
pipe = r.pipeline() # 创建一个管道

pipe.set('name', 'jack')
pipe.set('role', 'sb')
pipe.sadd('faz', 'baz')
pipe.incr('num')    # 如果num不存在则vaule为1，如果存在，则value自增1
pipe.execute()

print(r.get("name"))
print(r.get("role"))
print(r.get("num"))
```

管道的命令可以写在一起，如：

```
pipe.set('hello', 'redis').sadd('faz', 'baz').incr('num').execute()
print(r.get("name"))
print(r.get("role"))
print(r.get("num"))
```

