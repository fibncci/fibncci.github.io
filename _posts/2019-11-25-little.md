---
layout: post
title: "the little sas book学习笔记"
date: 2019-11-29
tag: sas
---









## The Little SAS Book 学习笔记

目录

[The Little SAS Book 学习笔记... 1](#_Toc368324236)

[第一章 SAS软件入门... 5](#_Toc368324237)

[1.1 SAS语言... 5](#_Toc368324238)

[1.2 SAS数据集... 6](#_Toc368324239)

[1.3 SAS程序的两个过程... 7](#_Toc368324240)

[1.4 数据步的内置循环... 8](#_Toc368324241)

[1.5 选择一个提交程序的方式... 9](#_Toc368324242)

[1.6 SAS视窗环境中的视窗和命令... 10](#_Toc368324243)

[1.7 在SAS视窗环境中提交程序... 11](#_Toc368324244)

[1.8 阅读SAS日志... 13](#_Toc368324245)

[1.9 输出窗口中浏览结果... 15](#_Toc368324246)

[1.10 创建HTML输出... 17](#_Toc368324247)

[1.11 SAS数据的逻辑库... 19](#_Toc368324248)

[1.12 用SAS资源管理器访问SAS数据集... 21](#_Toc368324249)

[1.13 使用SAS系统选项... 23](#_Toc368324250)

[第二章 将你的数据放入SAS. 25](#_Toc368324251)

[2.1 将你的数据放入SAS的方法... 25](#_Toc368324252)

[2.2 用View table窗口输入数据... 25](#_Toc368324253)

[2.3 用导入向导（Import Wizard）读取文件... 27](#_Toc368324254)

[2.4 告诉SAS你的原始数据在哪... 29](#_Toc368324255)

[2.5 list input读取空格分开的原始数据... 31](#_Toc368324256)

[2.6 column input读取按固定列排列的原始数据... 32](#_Toc368324257)

[2.7 informats读取非标准格式的原始数据... 33](#_Toc368324258)

[2.8 可选择变量形式... 34](#_Toc368324259)

[2.9 混合读取方式... 36](#_Toc368324260)

[2.10 读取凌乱的原始数据... 38](#_Toc368324261)

[2.11 跨行观测值的读取方式... 39](#_Toc368324262)

[2.12 一行有多个观测值的原始文件读取... 40](#_Toc368324263)

[2.13 读取原始数据的部分观测值... 41](#_Toc368324264)

[2.14 用infile语句中的选项控制输入... 42](#_Toc368324265)

[2.15 用数据步读取分隔符文件（delimited files）... 44](#_Toc368324266)

[2.16 用导入过程（IMPORT procedure）读取分隔符文件... 45](#_Toc368324267)

[2.17 用导入过程（IMPORT procedure）读取PC文件... 46](#_Toc368324268)

[2.18 用DDE读取PC文件... 48](#_Toc368324269)

[2.19 临时和永久数据集... 49](#_Toc368324270)

[2.20 用LIBNAME语句使用永久数据集... 50](#_Toc368324271)

[2.21 通过直接指代使用永久数据集... 51](#_Toc368324272)

[2.22 列出SAS数据集目录... 52](#_Toc368324273)

[第三章 开发你的数据... 54](#_Toc368324274)

[3.1 创建并重新定义变量... 54](#_Toc368324275)

[3.2 使用SAS函数... 55](#_Toc368324276)

[3.3 选出的SAS字符函数... 56](#_Toc368324277)

[3.4 选出的SAS数值函数... 56](#_Toc368324278)

[3.5 使用IF-THEN语句... 56](#_Toc368324279)

[3.6 用IF-THEN语句将观测值分组... 57](#_Toc368324280)

[3.7 构造子集... 58](#_Toc368324281)

[3.8 处理SAS的日期数据... 59](#_Toc368324282)

[3.9 可选择的Date Informats、Functions和Formats. 60](#_Toc368324283)

[3.11 使用retain和sum语句... 61](#_Toc368324284)

[3.12 用数组简化程序... 62](#_Toc368324285)

[3.11 列出变量名的快捷方式... 63](#_Toc368324286)

[第四章 排序、打印并描述你的数据... 65](#_Toc368324287)

[4.1 使用SAS过程步... 65](#_Toc368324288)

[4.2 用where语句在过程中构造子集... 66](#_Toc368324289)

[4.3 用proc sort为数据排序... 67](#_Toc368324290)

[4.4 用proc print打印你的数据... 68](#_Toc368324291)

[4.5 用formats改变打印外观... 69](#_Toc368324292)

[4.6 可供选择的formats. 71](#_Toc368324293)

[4.7 使用proc format创建自己的格式... 72](#_Toc368324294)

[4.8 定制一个简单的报告... 74](#_Toc368324295)

[4.9 使用proc means描述数据... 75](#_Toc368324296)

[4.10 将描述性统计写入SAS数据集中... 76](#_Toc368324297)

[4.11 用proc freq为数据计数... 77](#_Toc368324298)

[4.12 用proc tabulate产生一个表格报告... 79](#_Toc368324299)

[4.13 为proc tabulate输出增加统计量... 80](#_Toc368324300)

[4.14 提升proc tabulate的输出外观... 81](#_Toc368324301)

[4.15 改变proc tabulate输出的表头... 83](#_Toc368324302)

[4.16 为proc tabulate输出的数据方格指定多种格式... 84](#_Toc368324303)

[4.17 用proc report产生一个简单的输出... 85](#_Toc368324304)

[4.18 在proc report中使用define语句... 87](#_Toc368324305)

[4.19 用proc report创建简易报告... 88](#_Toc368324306)

[4.20 给proc report输出增加summary break.. 90](#_Toc368324307)

[4.21 为proc report输出增加统计量... 91](#_Toc368324308)

[第五章 用ODS增强你的输出结果... 93](#_Toc368324309)

[5.1 ODS（Output Delivery System）的概念... 93](#_Toc368324310)

[5.2 追踪选择过程的输出... 94](#_Toc368324311)

[5.3 从过程输出中创建SAS数据集... 96](#_Toc368324312)

[5.4 使用ODS语句创建HTML输出... 97](#_Toc368324313)

[5.5 使用ODS语句创建RTF输出... 99](#_Toc368324314)

[5.6 使用ODS创建printer输出... 101](#_Toc368324315)

[5.7 定制标题和注脚... 102](#_Toc368324316)

[5.8 用style=option定制proc print输出... 103](#_Toc368324317)

[5.9 用style=option定制proc report输出... 105](#_Toc368324318)

[5.10 使用style=option定制proc tabulate输出... 108](#_Toc368324319)

[5.11 为你的输出增加交通信号灯... 110](#_Toc368324320)

[5.12 选择风格属性... 112](#_Toc368324321)

[第六章 修改组合SAS数据集... 114](#_Toc368324322)

[6.1 使用SET语句修改数据集... 114](#_Toc368324323)

[6.2 使用set语句堆叠数据... 115](#_Toc368324324)

[6.3 使用SET语句插入数据集... 116](#_Toc368324325)

[6.4 一对一匹配合并数据集... 118](#_Toc368324326)

[6.5 一对多匹配合并数据... 120](#_Toc368324327)

[6.6合并统计量与原始数据... 121](#_Toc368324328)

[6.7 合并total和原始数据... 122](#_Toc368324329)

[6.8 用交易数据（transactions）更新主数据集（master）... 123](#_Toc368324330)

[6.9 使用SAS数据集选项... 125](#_Toc368324331)

[6.10 用in=option追踪并选择观测值... 126](#_Toc368324332)

[6.11 使用output语句写多维数据集... 127](#_Toc368324333)

[6.12 使用output将一个观测值变成多个观测值... 129](#_Toc368324334)

[6.13 使用proc transpose将观测值转变为变量... 130](#_Toc368324335)

[6.14 使用SAS自动变量... 132](#_Toc368324336)

[第七章 使用SAS宏功能灵活写代码... 134](#_Toc368324337)

[7.1 宏概述... 134](#_Toc368324338)

[7.2 用宏变量提交文本... 134](#_Toc368324339)

[7.3 用宏创建一个模块化的代码... 135](#_Toc368324340)

[7.4 给宏增加参数... 136](#_Toc368324341)

[7.5 使用条件逻辑写宏代码... 138](#_Toc368324342)

[7.6 用call symput编写数据驱动的程序... 140](#_Toc368324343)

[7.7 排除宏错误的bug. 141](#_Toc368324344)

[第八章 使用基本统计过程... 143](#_Toc368324345)

[8.1 用PROC UNIVARIATE检验数据分布... 143](#_Toc368324346)

[8.2 用proc means产生统计量... 144](#_Toc368324347)

[8.3 用proc freq检验分类数据... 145](#_Toc368324348)

[8.4 用proc corr检测相关性... 147](#_Toc368324349)

[8.5 使用proc reg做简单的回归分析... 149](#_Toc368324350)

[8.6 读取proc reg的输出... 149](#_Toc368324351)

[8.7 使用proc anova做单因素方差分析... 151](#_Toc368324352)

[8.8 读取proc anova的输出... 152](#_Toc368324353)

[8.9 统计分析的图形界面... 153](#_Toc368324354)

[第九章 导出数据... 154](#_Toc368324355)

[9.1 导出数据的方法... 154](#_Toc368324356)

[9.2 用导出向导写文件... 154](#_Toc368324357)

[9.3 用EXPORT Procedure写分隔的文件... 157](#_Toc368324358)

[9.4 用EXPORT Procedure写PC文件... 158](#_Toc368324359)

[9.5 用数据步写原始文件... 160](#_Toc368324360)

[9.6 用ODS写分隔和HTML文件... 161](#_Toc368324361)

[9.7 和其他类型电脑分享SAS数据集... 163](#_Toc368324362)






## 第一章 SAS软件入门

### 1.1 SAS语言

许多软件要么是菜单驱动，要么是命令驱动（输入命令——看结果）。SAS两者都不是，在SAS中，你用一个叫做SAS程序的一系列指令语句，这些程序可以表达出你想做的事情，并用SAS语言写下来。SAS有菜单驱动栏，比如SAS企业向导模块，它使SAS看起来像一个点击的软件，但这些模块仍然使用SAS语言为你写程序。如果你试图用SAS写下你自己的程序，那就要具备一定的灵活性。

 

**SAS** **程序** 一个SAS程序就是一个按顺序执行的语句序列，一个语句给SAS下达信息和指令，且必须要正确的安放。一个常用来与SAS程序做类比的例子是去银行取款，你进入银行、排队、轮到你，那么你会对柜台谁你想做的事，叙述语句可能会是这样：

I would like to make a withdrawal.

My account number is 0937.

I would like$200.

Give me five 20s and two 50s.

注意第一句话说了你想做的事情，之后把相关信息传递给柜台并帮你完成要求。这里信息传递的顺序不重要，重要的是在你的叙述中，首先要说明你要做什么。你不能先说：“Give me five 20s and two 50s.”这会使柜台小姐一头雾水。此外，你必须确保后面的语句都围绕第一句展开。

 

**SAS****语句** 像任何语言一样，SAS语句的编写也需要遵守一些语法规则。幸运的是，相比英语来说，SAS语句的规则不仅少，而且简单。

最重要的规则是：

每一个**SAS****语句都由一个分号结尾**

听起来很简单，但即使最富有经验的SAS程序员也会偶然忘记分号。如果你能记住这个规则，再来看看另外两个规则吧。

 

SAS**程序布局** 让每一条语句看起来整洁、用缩进来表现语句的各个部分，这是很有用的，但不是必须的：

l  SAS语句不区分大小写。

l  一条语句可以持续到第二行（只要不把一个单词分开）。

l  几条语句可以用一行。

l  可以在任何一列中开始一条语句

 

**注释** 可以在你的程序中插入一些注释，让它更容易明白。即使你插入一些你喜欢的食物品名也不会对程序有所影响，因为SAS不会读取注释。但不要忘记注释是为了让某人更轻松地学习你的程序，并明白你为什么这么做。

*Read animals’ weights from file;

DATA animals;

INFILE ’c:\MyRawData\Zoo.dat’;

INPUT Lions Tigers;

PROC PRINT DATA=animals; /*Print the results*/

RUN;

有两种注释方法，一种是‘*’和‘；’一起使用；一种是用/* */表示，由于某些操作环境解释第一列中的斜线星号（/ *）作为工作结束的标志，使用这种风格的注释时要小心不要把它放在第一列。出于这个原因，我们选择了星号分号的风格为这本书的注释。

**错误** SAS程序通常将执行的错误标注为醒目的红色字母，你可能忘了分号，拼错了字母，按错了键盘，一个小错误会使得整个程序无法运行。当你看到红色部分多余黑色部分的时候，不要灰心。

 

### 1.2 SAS数据集

在你进行分析、撰写报告，对你的数据进行任何处理之前，SAS必须能够处理你的数据，你的数据必须是一种叫SAS数据集的特殊形式。因为SAS非常灵活，能够读取任何形式的数据，所以将你的数据变成SAS数据集是一件非常简单的事。

 

**变量和观测值** 在传统的SAS术语中，数据包括变量和观测值。采用相关的数据库的术语，SAS数据集也被叫做表、观测值也被叫做行、变量也被叫做列，你可以看到下面这个包含一些数据的表。

​                                                  

 

**数据类型** 未加工的数据有多种形式，但SAS将其简单化。在SAS中只有两种数据类型——数值型和字符型。数值型完全是数据，可以被加减乘除、可以是正负且是小数。字符变量是除数值之外的类型，可以是数值、字母、和一些特殊的字符（￥、！），最多可以占用32767个字节长度。

如果一个变量既包括数字又包括字符，那么它一定是字符变量。如果只包括数字，可能是字符变量也可能是数值变量。在上面这个表中，姓名是字符变量，身高和体重是数值变量，ID，既可能是数值有可能是字符，依据你的选择。

 

**缺失**值 数据有时会有些不完美，某些变量的个别观测值会缺失。字符变量的缺失值用空格表示，数值变量的缺失值用句号（.）表示。上表中，体重的第五个观测值缺失，用.表示。姓名的第六个观测值缺失，用空格表示。

 

**SAS****数据集的大小** 在SAS 9.1之前（prior to SAS 9.1），SAS数据集可以包含32767个变量，从SAS 9.1开始（beginning with SAS 9.1），SAS可包含的最多变量数由你的电脑可用资源决定（内存，CUP？）。但是超过32767个变量的SAS数据集不能用在早期的SAS版本上。

 

**SAS****命名规则** 为你的变量和数据集命名，使它们容易被辨别。A,B,C这样的名字可能看起来很完美，写程序的时候也很方便，但当你6个月后再使用这些数据时，你会发现name，height，weight这样的名字更有用。为变量和数据集命名时要遵守如下规则：

l  名字的长度要小于等于32个字节。（一个字母1个字节，一个汉字2个字节）

l  以字母或下划线开头。

l  可以包含字母、数字、或者是下划线，不能是%$!*&#@。

l  可以是小写或大写字母，且不区分大小写。

 

**SAS****数据集储存的文件** SAS数据集包含了一些类似名称、创建日期、创建用的SAS版本等信息。SAS也储存了每个变量的信息，包括名称、类型、长度、数据集中的位置。这些信息叫做数据集的描述部分，它使得数据集可以自我编制（self-documenting）。

 

### 1.3 SAS程序的两个过程

​     SAS程序有两个基本模块：数据步和过程步。一个典型的SAS程序，由数据步创建SAS数据集开始，再由过程步分析数据。这里有一个例子：数据步中将米转化成千米，过程步中输出结果

   

数据步和过程步由语句组成（废话），一个过程少至1条语句、多至几百条。新手常犯的错误是将两种过程语句用混，只要记住数据步负责读取、修改数据，过程步负责分析数据、输出报告和效用函数，就不会犯错。

数据步由DATA语句开始：data+数据名。上例中数据步处理了名为distance的数据。为了读取外部数据、未加工的数据，数据步提供了DO LOOPS,IF-THEN/ELSE，以及一些数值和字符函数。数据步也可以按照你想要的方式合并数据集，包括联接（concatenation）和合并（match-merge）。

过程步由proc语句开始：proc+过程名（print、sort、means…），SAS过程步可以处理从数据储存、输出到方差分析、3D图表的一切操作。

当程序遭遇DATA\PROC等标志着新程序开始的语句时，程序结束。如果运行的是批处理，则run代表语句的结束。Run告诉SAS去执行所有之前的程序行，全局变量不是DATA或PROC过程的部分。上图的那个程序，当proc出现时，代表data过程结束。

典型的程序是以DATA语句开头，输入或修改数据，然后将数据传递给PROC语句。但并不一定非要用这种模式来混合data和proc语句，你可以用任何顺序来排列data和proc两者的顺序，一个程序甚至可以仅有data语句或proc语句。

下表是data语句和proc语句的一些基本不同点:

   

这只是一个简化表，SAS软件非常灵活，所以data语句和proc语句之间真正的区别也是很模糊的。记住，这个表并不是说proc语句永远不能创建SAS数据集，或者DATA语句永远不能够分析生成报告。

 

### 1.4 数据步的内置循环

Data步读取并修改数据，让你以灵活的方式控制处理数据。Data步也有一个潜在的、内置的循环语句。你不用告诉SAS去执行这个循环，SAS会自动执行。

**数据步按照一行一行、一个观测值一个观测值的顺序执行**

这句话的表意并不明确，许多新手直到成了老手都没明白这句话的含义。

数据步“一行一行的执行”，这句话很好理解。但很多新手还是容易在这里出错，例如在没有创建一个变量之前就使用它，如果Z变量是X、Y两个变量组合的新变量，那么必须确定创建Z变量的语句在创建X、Y变量语句之后。

而“一个观测值一个观测值的执行”就不是那么容易理解。这意味着SAS先读取一个观测值，然后对这个观测值进行数据步的所有语句（当然也是一行一行的），然后再读取第二个观测值执行。每次执行SAS只有一个观测值。

我们将SAS执行的图景放慢：SAS从你的数据集中读取一个观测值。SAS对你的这个观测值执行数据步，如果数据步一直运行到结束而没有错误，SAS会把当前的观测值写入一个新的、输出数据集中，并返回到数据步开头，读取第二个观测值进行执行。当最后一个观测值都被写入输出数据集中之后，SAS结束数据步，进入下一个步。

   

有一个类比，数据步就像是一个投票程序。当你来到投票的地点，你会站在别人后面进行排队，排到你时，你会被问到：你叫什么名字，住在哪里。当你回答之后，你可以投票。在这里，排队的人就像是观测值，投票的程序就像是数据步。一次只能让一个人投票，每个人都相互独立。并且投票的程序是一步一步来的，你不能没说明自己的姓名和住址之前就投票。

 

### 1.5 选择一个提交程序的方式

目前为止我们讨论了写SAS程序，但仅仅写不能带给你任何结果，你必须要提交并执行。有数种方法可以执行SAS程序，但不是任何方法都适合于你的操作环境。查找一下SAS帮助文档，或者咨询下你的SAS顾问，看看哪种方法适合你的操作环境。

 

SAS**视窗环境**      如果你使用SAS是按照系统提示，或者是点击SAS的图标，那么你适合使用SAS视窗环境。在这种交互式的环境中，你可以写入、编辑SAS程序，提交处理、浏览、输出结果的SAS程序。此外，视窗有许多功能可以处理不同的任务，如管理SAS文件、定制界面、访问SAS帮助文档、导入和导出数据。你的视窗环境的界面取决于你电脑的的类型、使用的终端、电脑操作系统和启动SAS时实际的选择。如果你使用的是个人电脑，那么SAS视窗环境的感觉和其他软件类似。

 

SAS**企业向导** 如果你有SAS企业向导软件，这个软件在windows下即可运行。你可以用这个软件提交程序：使用插入菜单打开代码窗口，输入序或打开现有SAS程。之后你可以用本地电脑、或者在远程服务器上（需要安装）运行SAS程序。

 

 

 

 

​     **非交互式模式** 非交互式模式是SAS程序语句已先存于你系统的文件中，直接执行那个文件。非交互式模式可以让SAS立即执行程序，通过某个指令开始（$），后接文件名，如：

$ SAS Myfile.sas

 

​        
 **批处理或后台模式** 在批处理或后台模式下，你的程序存于一个文件中，SAS会自动执行，你不需要在电脑旁，如果程序多，SAS会将这个程序进行排队等待。这种模式通常用在大型电脑中，因此通常可以一次性处理多个任务。批处理或后台模式的成本比较低，适合于大型工作，工作完成后，结果会存于文件夹中，你可以任何时候输出查看。批处理未必适合你的操作环境，另外提交方式也会有不同，最好查看SAS帮助文档，或咨询SAS顾问。

 

​             
 **远程提交** 如果你安装了CONNECT模块，可以进行远程提交，即在一台电脑上（本地）编写程序，在另一台电脑上（远程）处理，结果会返回本地电脑。当你处理大型任务，而你的电脑性能又不够时，可以连接到远程的高性能电脑上，也可访问远程电脑的分享文件。

**交互行模式** 交互行模式下，SAS每次提示用户输入一个语句，想改正输入的语句不是那么容易的。因此除非你足够优秀和熟练，否则最好不要用这个模式。你可以用endsas并回车来退出这个模式：

Endsas；

如果你想知道为什么会进入这个模式，并且在以后避免进入，你需要咨询SAS顾问。

### 1.6 SAS视窗环境中的视窗和命令

SAS**视窗** SAS有五种基本的视窗（窗口）：结果视窗、资源管理器视窗、和三种程序视窗：程序编辑、日志、输出。除此之外，在获得SAS帮助、改变SAS系统选项、定制SAS人机会话等情况时，可能还会用到其他的视窗，下图显示了Microsoft Windows SAS会话中默认的视图：

   

 

**编辑窗口** 编辑窗口中你可以输入、编辑、提交SAS程序。Windows操作环境默认的是增强型编辑窗口，它对语法更敏感，并用颜色标注程序，使得更容易理解和发现错误。其他操作环境默认的是程序编辑窗口，并随操作环境和SAS版本的不同，界面特征也不同。

 

**日志窗口** 日志窗口是关于SAS会话的说明。在提交SAS程序之后，任何的说明、错误、警告和程序语句都会显示在日志窗口上。

 

**输出窗口** 如果程序产生需输出的结果，那么会反映在在输出窗口中。

 

**结果窗口** 结果窗口就像输出窗口的一个目录表，以提纲形式列出了输出的每一个部分。

 

SAS**命令**SAS命令是为了不同的任务，你有三种方式发出命令：菜单、工具栏、SAS命令栏，如下图：

   

**菜单** （大部分操作环境都会有一个下拉菜单要么在窗口上方要么在屏幕上方…..oh my god!略）

 

**工具栏**（不是所有的操作环境都有工具栏…略！）

 

**SAS****命令栏** 可以在这里输入SAS命令，一些操作环境中，命令栏坐落在工具栏中，另一些操作环境中，每个SAS窗口都有一个命令行（command line），通过语句command=>激活。大部分命令是可以直接用菜单进行选择的。

 

**控制你的视窗** 你可以通过菜单、命令栏、点击的方式激活任何一种程序窗口。

 

### 1.7 在SAS视窗环境中提交程序

**将你的程序放入编辑窗口中** 你可以通过输入，或者打开现有程序文件的方式将程序放入编辑窗口中。打开现有的程序文件，可以通过菜单-打开，也可以通过工具栏的图表，或者直接将文件拖放到编辑窗口中。

 

**提交你的程序** 你有几种方式来提交程序：

​     使用工具栏的提交图表

 

​     激活命令栏，输入submit命令回车。

 

从run运行的下拉菜单中选择submit提交

​        


左图显示了如何在windows视窗中提交增强型编辑窗口的程序。

​        
 **访问****SAS****日志和输出** 提交程序后，日志窗口和输出窗口会有相应的日志和结果显示，如果你使用的是增强型编辑窗口，之前的程序会保留，如果使用的是程序编辑窗口，之前的程序不会保留。如果你的程序产生了输出，那么结果窗口会显示这些输出的目录，下图是一个例子，显示了提交程序之后，增强型编辑窗口、日志窗口、结果窗口、输出窗口的样式。

   

取回你的程序 如果不幸你的程序出现了问题，你需要再次运行，对于程序编辑窗口，由于之前的程序不在保留，因此需要调回命令（recall），有两种方法：

​     

命令窗口中输入recall

 

​     

 

 

激活编辑窗口，从运行（run）下拉菜单中选择

 

 

如果不停的使用recall命令，SAS可以一直往前调回程序，知道所有提交的程序都被调回。

 

### 1.8 阅读SAS日志

**在哪找到****SAS****日志** SAS日志窗口的位置随着你使用的操作环境、选择的模式（视窗、非交互、批处理）、个人的设置的不同而不同。在视窗模式下，提交程序之后，日志窗口默认的位置如下图：

   

对于批处理和非交互模式的日志则会被写入一个文件中，你需要使用操作环境的命令来查看，一般日志文件的名字与对应的SAS程序名一直，如你的SAS程序命为abc.sas，那么日志文件的命则为abc.log

日志包含的内容 日志中虽然有很多琐碎，但也包含了重要的信息。这里有一个将英里转换为千米的程序：

*Create a SAS data set named distance;                                                                                                  

*Convert miles to kilometers;                                                                                                           

DATA distance;                                                                                                                          

Miles=26.22;                                                                                                                            

Kilometers=1.61*Miles;                                                                                                                  

*Print the results;                                                                                                                     

PROC PRINT DATA=distance;                                                                                                               

RUN;

运行之后，SAS的日志窗口会产生一个类似这样的日志：

   

① 说明了你使用的SAS版本和site。

② 是原始的SAS程序语句

③ 说明了数据步为你创建的数据集名称，观测值数和变量数。它可以帮助你确认你的程序没有丢失观测值，也没有创建你不需要的变量。

④ 这部分显示了数据步和过程步占用的电脑资源。当你使用的是多用户系统，或者处理大型数据而使得SAS运行占用大量时间时，这部分信息可以帮助你检查哪一步比较耗时。

如果SAS程序出现错误，错误信息也会反馈在日志窗口中，说明哪里出错及出错表现。

 

### 1.9 输出窗口中浏览结果

你使用的模式不同，产看输出结果的方法也会不同。如果是在视窗模式下提交SAS程序，那么直接在输出窗口查看，如果是批处理和非交互模式下，那么结果就会保存在一个文件里，需要用命令查看。比如使用UNIX系统下的非交互模式，结果会存在一个后缀为.lst的文件里，使用cat或其他更多命令来查看。

 

**输出窗口** 提交程序后，结果会出现在输出窗口中，下图是一个输出窗口的例子

   

**打印或保存输出窗口的目录** 激活输出窗口的目录，在菜单栏文件（file）下拉菜单中选择打印（print）或保存（save）即可。

 

**结果窗口** 结果窗口起到输出窗口的目录作用，当你的输出结果非常多时，结果窗口很有用。它可以让你很清楚的看到输出结果的每一部分。下图是一个方差分析（ANOVA）过程的结果。在这个图中，左边是输出结果的目录，点击+号将其展开，可以看见ANOVA结果的各个部分，双击某一部分，则该部分结果就会位于输出窗口顶部。

   

 

**打印或保存部分输出** 如果要打印结果窗口中显示的某一部分的输出，则需将鼠标移到该部分上，右击，选择打印或保存即可。或者点击一下，使其黑亮，再从菜单栏文件（file）的下拉菜单中选择输出或保存。

   

 

### 1.10 创建HTML输出

如果使用的是SAS视窗环境，那么可以为结果创建超文本标记语言（HTML）格式。

**参数选择窗口** 选择菜单栏中工具（tools）下拉菜单的选项（options）-参数选择（preferences）。选择结果（result）选项卡，如下图所示：

   

这个参数选择窗口上，有一个“创建列表（create listing）”选项，默认的输出就是列表输出。下面还有“创建HTML”选项，用来创建HTML。样式（style）选项用来为HTML选择一个风格样式。选择之后，点击OK。

 

**结果浏览窗口和结果窗口** （注意下面提到的三种窗口：结果浏览窗口result viewer，结果窗口results window，输出窗口output window）

一旦选择了HTML输出，每次运行程序的时候都会自动出现一个结果浏览窗口（result viewer），下图显示了在运行了一个均值和输出的程序后，出现两个窗口：结果浏览窗口——显示HTML输出，结果窗口——显示输出的目录。

   

结果浏览窗口一次只显示输出结果的一个部分，通过选择结果窗口的目录，可以查看其他的部分。值得注意的是，结果窗口给出的目录中，每一个部分都给出了两种相同的目录，一个是链接到输出窗口，一个是链接到结果浏览窗口

保存结果浏览窗口的输出（output of result viewer）的方法：激活结果浏览窗口，选择菜单栏文件（file）下拉菜单的保存（save as）、输出（print）。

可以在style中为输出选择不同的风格，如下图就是D3D的风格：

   

 

### 1.11 SAS数据的逻辑库

SAS逻辑库库只是数据集文件存放的地点。打开SAS视窗模式后，会看到SAS资源管理器窗口（explore），双击逻辑库图标，资源管理器窗口会显示出所有已定义的图标。要返回前一级窗口，选择查看（view）-向上一级（up one level），或者在工具栏中直接点击向上一级图标   。

 

**逻辑库窗口** 打开逻辑库窗口后，除了自己创建的库外，至少会呈现三个逻辑库：sashelp，sasuser，和work，如果安装了某些SAS模块，还有一些特别的逻辑库，比如SAS/GRAPH模块的Maps逻辑库。Sashelp包含了控制SAS会话以及样本数据集的一些信息。WORK是sas数据集的临时储存地点，创建的数据集如果没有指定库，则默认储存在这里，关闭程序时则自动删除数据集。也可以更改默认的库，从而不是临时库。

   

​     

**创建新逻辑库** 创建新逻辑库有两种方法：在逻辑库窗口中选择文件（file）下拉菜单的新建（new）；或者直接右键——新建。

 

 

 

 

 

 

在新建逻辑库（new library）窗口中，为你的逻辑库起一个名字，这里叫做Mylib,指定库的存放路径。如果不想每次启动SAS都要调用这个库，则勾选启动时启用（enable at startup）即可。

   

​     

这是一个新建的Mylib逻辑库的视图。

 

 

 

 

 

 

 

 

 

 

 

 

### 1.12 用SAS资源管理器访问SAS数据集

可以利用SAS资源管理器打开数据集、浏览、编辑，也可以列出数据集的信息，如创建时间和变量名。

​     

**目录窗口** 打开一个逻辑库，进入一个目录窗口，显示这个库中所有的文件和文件夹。右图的目录窗口中显示Mylib逻辑库有三个文件：Customers，Models，orders。双击某文件，则可以打开这个文件的可视视图。     

 

**可视视图** 这个窗口允许你创建、浏览、编辑数据集。

​     

**列出****SAS****数据集的属性** 用资源管理器还可以列出SAS数据集的一些属性情况，右击某文件，选择下拉菜单的属性（properties），属性窗口显示了SAS数据集的属性信息，如创建时间、行列数等。

 

 

 

 

 

 

 

 

 

 

 

 

​     

 

 

 

如果选择列（columns）选项卡，则出现数据的列信息

 

 

 

 

 

 

​     

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

### 1.13 使用SAS系统选项

SAS系统选项是影响SAS运行的一些参数，比如输出的显示、内存的占用、错误的处理等问题。这些小问题由SAS为你设定好，你也可以改变它。

SAS系统选项的参数不是所有都适合你的操作环境，适合于你的再SAS的帮助文档中给出。可以通过打开SAS系统选项窗口或使用option程序来查看你的SAS系统参数。Option程序的语句如下：

Proc options；

Run；

有四种方法可以指定系统选项的参数，SAS帮助文档会告诉你哪种适合你的操作系统：

\1. 系统管理员会创建一个包含了系统选项设定的配置文件，每次SAS启动时都会访问这个文件。

\2. 在启动SAS之后，根据系统提示指定系统选项。

\3. 如果使用SAS视窗环境，可以从SAS系统选项中改变已选择的选项。

\4. 使用OPTIONS语句。

这四种方法按照优先性排列，方法2优先于方法1，方法3优先于方法2，方法4优先于3。如果使用SAS视窗环境，方法3,4最好。

 

**OPTIONS****语句** OPTIONS语句是SAS程序的一部分，并可影响之后的所有语句。由OPTIONS关键词开头，后面是相关选项。比如：

OPTIONS LINESIZE=80 NODATE;

OPTIONS语句既不属于数据步也不属于过程步，这个全局变量可以出现在程序的任何部分，但放在开头最有意义，你可以很容易看到哪些选项在发挥作用。如果OPTIONS语句只出现在数据步或者过程步中，那么它会影响那个过程，和下面的过程（If the OPTIONS statement is in a DATA or PROC step,then it affects that stepand the following steps.）。注意，后面的OPTIONS语句会覆盖前面的，即以后面的OPTIONS为主。     

 

**SAS****系统选项窗口** 通过这个窗口也可以改变系统选项。可以通过在命令栏中输入“OPTIONS”，或从工具（tools）下拉菜单中选择. 

窗口出来后，找到要修改的部分，右击——修改值（modify the value）即可。

 

 

**一般选项** 下面是一些可能用到的一般系统选项

| CENTER\|NOCENTER                                            | 输出是否居中，还是左对齐。默认居中                           |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| DATE\|NODATE                                                | 今天的日期是否出现在输出的顶部。默认输出                     |
| LINESEZE=n                                                  | 控制输出行的最大长度，n可能的值为64到256                     |
| NUMBER\|NONUMBER                                            | 输出的页面页码是否需要。默认需要。                           |
| ORIENTATION=PORTRAIT；   ORIENTATION=LANDSCAPE；            | 指定打印输出的方向。默认竖向（portrait）                     |
| PAGENO=n                                                    | 输出页开始的页面。默认为1                                    |
| PAGESIZE=n                                                  | 每个页面输出的最大行数。可能的值为15到32767                  |
| RIGHTMARGIN=n   LEFTMARGIN=n   TOPMARGIN=n   BOTTOMMARGIN=n | 指定打印输出的边缘大小。默认0.00英寸（Specifies size of   margin(such as 0.75in or 2cm)to be used for printing output.Default:0.00in.） |
| YEARCUTOFF=yyyy                                             | 设定起始年份                                                 |




## 第二章 将你的数据放入SAS

### 2.1 将你的数据放入SAS的方法

你可能有各种形式的数据，包括手写在纸上、存放在电脑上、或是在数据库管理系统里，不论如何，总有一种方法可以让SAS来读取。

SAS读取的数据的方法主要有以下几种类型：

l  直接输入；

l  从原始数据文件中创建一个SAS数据集（creating SAS data sets from raw data files）；

l  将其他软件中的数据文件转换成SAS数据集；

l  直接读取其他软件的数据集；

 

**直接输入** 

l  View table窗口可以让你以表格形式输入数据，可以定义变量、设置属性，如name、length和 type(character or numeric).

l  SAS 企业向导模块，a Windows only application, has a data entry window that is very similar to the View table window. As with View table, you can define variables and give them attributes.

l  SAS/FSP 模块，是Full Screen Product的简称，可以设计定制的数据输入窗口，也有检测数据输入错误的功能（The SAS/FSP product is licensed separately from Base SAS software.）。

 

**从原始数据文件中创建一个****SAS****数据集** 你有两种方法读取原始数据文件：

l  数据步可以读取任何形式的原始数据文件，这种方法还将在2.4中详解。

l  导入向导（Import Wizard）、导入过程（IMPORT procedure）适用于UNIX、OpenVMS和 Windows操作环境的简单方法，可以读取CSV（comma-separated values）和其他一些限定的文件类型。

 

**将其他软件中的数据文件转换成****SAS****数据集** 如果数据在一个软件中以某种格式存放，但需要用另一种软件分析时，就会很麻烦。有几种方法可以将某种软件中的数据转换成SAS数据集：

l  如果安装SAS/ACCESS模块，可以用导入过程（import procedure）和导入向导（Import Wizard）将Excel、Lotus、dBase和Access文件导入SAS数据集，见2.3和2.17（？）。

l  如果没有安装，可以用存放数据的软件创建一个原始文件，并用数据步或导入过程（import procedure）读取。很多软件都可以创建CSV文件。

l  Windows操作环境下也可以用动态数据交换技术（Dynamic Data Exchange，DDE），见2.18。前提是必须有一个其他的Windows程序与SAS同时运行，再使用DDE和数据步。

 

**直接读取其他软件的数据集** 

l  SAS/ACCESS产品可以不用转换数据格式读取数据，并适用于大部分数据库管理系统，包括ORACLE,DB2,INGRES和 SYBASE（但使用方法本书没有介绍）。

l  使用Excel engine和Access engine来读取这两种类型的数据。（SAS帮助文档）

l  还有其他的一些数据引擎（data engines）来读取数据，如SPSS engine（附录D），查找帮助文档找到适合你操作环境的所有有效engine。

 

### 2.2 用View table窗口输入数据

调用View table窗口，在工具栏的下拉菜单中选择表编辑器（Table Editor）。

   

**列属性窗口** 每一列顶部的字母是默认的变量名，右击变量名，即可打开列属性（column attributes）窗口，设置属性之后，点击应用（apply），设置完后关闭即可。

   

**输入数据** 

   

**保存表** 选择文件（file）——另存为（save as），选择一个逻辑库保存，如果想保存在新的逻辑库，点击创建新逻辑库图表（New Library），输入逻辑库的名字和保存路径。

 

**打开一个已有的表** 首先打开表编辑器，选择文件（file）——打开（open）。打开之后，SAS默认的是浏览模式，如果要对数据进行编辑，则要在编辑（edit）菜单中选择编辑模式。也可以在资源管理器窗口中双击打开一个已有的表。

 

**其他功能** 其他一些功能包括排序、打印（printing）、增加和删除行、一次浏览一行（表单视图Form View）、一次浏览多行（表视图 Table View）。图标和菜单都可以选择这些功能。

 

**在****SAS****程序中使用表** 如下程序语句可以将表内容输出打印：

PROC PRINT DATA=Sasuser.coffee;

RUN；

### 2.3 用导入向导（Import Wizard）读取文件

导入向导会浏览你的文件以决定变量的类型，并默认数据表的第一行存放变量名。

第一步，从文件（file）下拉菜单中选择导入数据（import data）导入向导（Import Wizard）

   

第二步，从standard data sources中选择要导入的数据类型。以comma separated values（*.csv）为例。点击下一步

第三步，指定要导入的文件位置，SAS默认第一行存放变量名，从第二行开始存放数据。Options可以改变这种默认选择。

   

第四步，选择数据集要存放的逻辑库，并为数据集取一个名字（member）

   

最后，导入向导创造一个proc import语句，可以是SAS再次导入这个数据。

   

另外，对于一些类型的数据文件还有额外的步骤，比如Microsoft Access文件，你需要输入数据库名和药导入的表名，有时甚至还要输入user的ID号和密码。

 

**在****SAS****程序中使用导入数据** 比如你将数据存放在work逻辑库，并署名为flowers，那么你可以这样来输入它：

PROC PRINT DATA=WORK.flowers;

RUN;

由于work是默认的逻辑库，所以也可以直接这样：

PROC PRINT DATA=flowers;

RUN;

 

### 2.4 告诉SAS你的原始数据在哪

如果数据是原始数据（比如text, ASCII, sequential, flat files），那么用数据步来读取能带给你最大的灵活性。但首先你要告诉SAS你的原始数据在哪。

原始数据可以通过文本编辑器（text editors）或系统命令。对PC使用者来说，原始数据没有相关联的应用程序（就像doc文件与word相关联，双击doc程序就默认调用word程序以打开），有时他们会与像Microsoft Notepad这样的简单编辑器相关联。

**内部原始数据** 如果直接将数据输入SAS程序中，那么数据就是SAS内部数据。DATALINES是一个指示，告诉SAS下面跟着是数据行，直到分号结尾，这个分号可以另起一行，也可以接在数据的后面。也可以用card代替DATALINES。下面是一个程序，这个程序创建了一个USPRESIDENTS数据集。（Input语句还将在2.5和2.15中讨论）

   

**外部原始数据** 数据外SAS程序外部时，使用INFILE语句告诉SAS外部数据的文件名和存放路径，它在data语句之后，在INPUT语句之前。INFILE后面的文件名和路径要用引号，各种系统的引用方式各不同：

   

假设有一个President.dat数据在你的C盘的MyRawData目录中，

   

那么可以用如下方式引用这个外部数据：

   

**SAS****日志** 读取外部数据时，SAS日志会给一些很有用的信息，检查这些信息可以解决一些问题，比如对比INFILE语句读取的记录数和数据集中实际观测值，可以确定SAS是否正确的读取了数据。上面程序的日志如下图所示，

   

**过长记录** 在一些操作环境中，SAS假定外部数据文件的记录长度为256或更少（记录长度是指某行中的字符数，包括空格），如果长度过长，SAS不能读取全部，此时需要在INFILE语句中使用LRECL=来指定长度，这个长度必须是数据中最长行的长度，如：

INFILE ’c:\MyRawData\President.dat’ LRECL=2000;

可以通过SAS日志来查看最大记录长度。

### 2.5 list input读取空格分开的原始数据

如果原始数据都至少被一个空格分开，那么用list input读取数据可能是正确的。List input是一个很简单的读取数据的方式，但是会受到很多限制。你必须读取所有的数据记录，不能跳过某些值、缺失值必须用句号“.”代替。字符串数据不能包含空格、长度不能超过8个字符。而且如果数据文件包含日期变量或者其他需要特别处理的变量，list input将不再适用。虽然很多限制，但仍有大量的文件可以用这种方式读取。

INPUT语句是数据步的一部分，它告诉SAS如何读取原始数据。使用List input来写input语句：在INPUT关键词之后列出变量名（按照变量在文件中出现的顺序），变量名长度在32个字节（含）以下，只能包含字母、下划线和数据，并必须以字母或者下划线开头。如果变量是字符串，后面要价“$”号，值与值之间至少有一个空格，语句要以分号结束。如：

   

这表明输入三个变量，其中name是字符串，age和height是数值变量。

**例子** 你想组织一次青蛙跳跃比赛，现在你记录了每只参赛青蛙的名字、体重、和三次跳跃的距离，如果某次的跳跃距离不合格，那么就用“.”代替，数据文件ToadJump.dat形式如下：

   

虽然不是很整洁、但满足list input的所有要求（字符串长度小于8个字节、不包含空格、值之间都有至少一个空格，缺失数据也用句号代替）。Nosiy的数据溢出到第二行了，但这不影响，SAS会按照变量顺序自动跳到下一行读取。如下是读取这个数据的SAS程序：

   

Input后面是变量名，ToadName是字符串变量，其他是数值变量；proc print过程用来输出数据集中所有的变量和观测值；title语句用告诉SAS输出顶部的标题，如果不指定标题，SAS将以“the SAS system”作为标题在每一页的顶部。输出的形式如下：

   

由于Noisy的数据溢出到下一行，因此下面的说明会出现在SAS日志上：

   

 

### 2.6 column input读取按固定列排列的原始数据

当一些原始数据的值之间没有空格分开，或者没用用句号代替缺失值时，list input就不能用。但当每个变量的值都出现在数据行的相同位置时，并且变量值是字符串或者标准数值（只包含数据、小数点、正负号、和科学标注的E。逗号和日期都不能算）时，可以使用column input来读取。

相比list input，column input有如下优势：

l  不要求变量值之间的空格；

l  缺失值可以直接用空格代替；

l  字符串中可以包含空格；

l  可以跳过不需要的变量。

调查数据使用column input，因为调查答案的记录都是用单个数字（0-9），如果每个答案之间再用空格分开，就会使整个文件会扩大两倍。有地址的数据文件也使用 column input，因为地址之中常常包含空格，比如街道Martin Luther King Jr.Boulevard在column input中就可以当成一个变量而不是五个。可能用column input读取的数据也可以用formatted input读取或者几种方式组合。

Column input的input语句格式如下：input关键字后接变量名、再接变量的列位置（列位置是字符或者数值在一行中的位置）。字符串变量名后仍要用“空格+$”，变量名之间仍要用空格隔开。示例如下：

   

这个语句表明，Name变量，在行中占据第1列第10列，为字符串变量，age占据第11-13列，为数值变量，height占据第14-18列，数值变量。

**例子** 原始数据记录如下：

   

读取这个数据的column input程序如下：

   

第一个变量visitingteam占据第1-20列，为字符变量；concessionsales占据第21-24列，为数值变量，下面几个变量均占据固定的列。输出结果如下：

   

 

### 2.7 informats读取非标准格式的原始数据

有时候原始数据不全是字符串或者数值，比如类似1,00,001这样包括逗号的字符串值，电脑就不能读取，其他诸如包含美元符号、十六进制、压缩十进制的数据都是非标准数据。SAS中，informats可以用来告诉电脑如何读取这样的数值。

日期是最普通的非标准数据，SAS informats会把类似10-31-2003或者31OCT03转换成数字，日期的起点为1960年1月1日，即这一天的数字为0。

Informats的三种普遍格式为：字符串、数值、日期。这三种格式的形式如下：

   

$代表是字符串、informats代表形式（比如日期的MMDDYY）、w是宽度、d是小数点的位数、最后是句号“.”，缺少句号会使得SAS把形式（如MMDDYY）当做变量名。一个简单formatted input的简单INPUT语句如下：

   

Name为字符串变量，占据10个宽度，即列位置从1-10；age为数值变量，占据3个宽度，列位置从11到13；height也为数值变量，占据5个宽度，包括了1位小数点和小数点本身，列位置从14-18（如150.3）；最后是日期变量，从第19列开始，形式为MMDDYY。

**例子** 原始数据如下：

   

读取这个数据的informat程序如下：

   

年龄后面的+1代表跳过一列，即原始数据中年龄后面有一个空格。最后的5个变量score1-score5，都要求有同样的形式，4.1。将变量名和形式分别放在两个括号集中，可以一次性定义很多变量。输出结果如下：

   

 

### 2.8 可选择变量形式

一般使用的变量形式的定义，以及它们的宽度范围和默认宽度如下：

   

   

 

### 2.9 混合读取方式

每种数据读取方式都有其优势，list最简单，column和formatted虽然复杂但是不要求变量之间的空格，并且变量名中可以包含变量，而且formatted可以读取特殊的数据比如日期。SAS可以灵活的让你搭配不同的读取方式，以达到最大的方便。 

例子 如下的原始数据记录了美国国家公园的信息：姓名（name）、所属州（state）、建立时间（year established）、占地面积（size in acreage）：

   

有多种方式进行数据读取，下面的程序是方式之一：

   

其中ParkName是column方式读取，State和Year是list方式读取，Acreage是formatted方式读取，输出结果如下所示：

   

混合读取方式有时会遇到问题：SAS通过一个指示器标注位置，来读取原始数据的一行，但每种读取方式对指示器的使用稍有不同。List方式下，SAS自动找到非空格区域并开始读取；column方式下，SAS读取你所指定的特定位置；informatted方式下，SAS不理会指示器的标准，只是依次的读取。这时，就会需要列指示器@n，来人为的让SAS的读取直接跳至某列。

在上面的程序中，列指示器@40告诉SAS在读取Acerage变量之前，移动到第40列去，如果移去指示器，程序为：

   

输出结果如下图所示：

   

之所以出现这样的结果，要看原始文件的列坐标排列：

   

Comma9告诉SAS读取9列，SAS就会读取包括空格在内的9列，这便会导致输出结果的问题。

 

### 2.10 读取凌乱的原始数据

有的数据排列混乱，长度不一。这样的数据需要新的工具处理：@’character’ 列指示器和colon modifier。

**@’character’** **列指示器** 2.9中提到@column列指示器可以让SAS直接从某列开始读取数据。但有时候你不知道要读取的数据是从哪列开始，此时你只要知道要读取的数据的前面那个字符或单词即可。比如有一个关于狗的原始文件，你想要读取狗的品种号，但文件排列很凌乱，只知道品种号跟随在单词breed后面，那么可以用如下方式读取：

Input @’Breed:’ DogBreed $;

**colon modifier** 由于input读取字符串变量默认为8个字符，因此在上例中如果狗的品种名（dogbreed）超过8个字符，则需要定义长度，定义为$length，在该长度中，空格也算在内。如果要使SAS读取过程中遇到空格则不再继续读取，则要在$length.前面加冒号“:”。比如原始数据中有这么一行：

My dog Sam Breed:Rottweiler Vet Bills:$478

如果用上述不同方法读取，会有不同结果：

   

例子 web日志是凌乱数据的一个很好例子，下面是一个网站的web日志，数据开始于访问IP，后面有访问日期、访问文件名等信息。

   

现在想要读取访问日期和访问的文件名，但是它们每行中所占据的列的位置都不同，而且文件名的长度每行都不一样，那么SAS读取这种文件通过如下方式：

   

@’[’作为列指示器，告诉SAS读取[之后的内容，@’GET’告诉SAS读取GET之后的内容，由于文件名作为字符串变量，这里基本都会超过8个字节，因此后面附加:$20。输出结果如下：

   

 

### 2.11 跨行观测值的读取方式

一般原始文件中一行代表一个观测值，有时会出现一个观测值跨行的情况。由于SAS会自动转到下一行读取数据，直到读取这个观测的所有变量（input语句中给出），所以你需要告诉SAS什么时候不要换行，以便在日志中不出现SAS-went-to-a-new-line的暂停说明，此时需要在INPUT语句中加行指示器。

行指示器，斜线/：告诉SAS跳至原始数据的第二行；#n：跳至第n行，n代表原始数据中某观测值的行数（#2则让SAS跳至某观测值的第二行），#n不能用来回跳。

**例子** 有一组关于温度的数据，temperature.dat第一行代表城市和州，第二行代表本日最高温和最低温，第三行代表史上最高温和最低温。

   

用如下的程度来读取这份数据：

   

Input后面告诉SAS读取第一行的city变量和state变量，斜线/告诉SAS移动到下一行的第一列，以便读取normalhigh和normallow。#3告诉SAS移动到第三行的第一列以便继续读取观测值的recordhigh变量和recordlow变量。这里/可以用#2代替，也可以用/代替#3。

日志记录如下：

   

从日志中可以看出，虽然原始原件占了9行，但只有三个观测值。

输出结果如下：

   

 

### 2.12 一行有多个观测值的原始文件读取

​     

当一行出现多个观测值时，可以在input语句结尾加一个停止符号@@

**例子** 有一个关于降水量的数据，precipitation.dat，文件包含城市名、州名、月平均降水量、月平均降水天数：

   

这个数据文件中，第一行包含了两个观测值，可以用@@的程序读取：

   

 

日志记录如下：

   

中间的说明，SAS went to a new line when INPUT statement reached past the end of a line.是指读取第二个值时达到第一行末尾，并转到下一行继续读取。通常这些信息会预示一个问题出现，但在这里它们都是你所想要的（为什么？）

输出结果如下：

   

 

### 2.13 读取原始数据的部分观测值

​     

有时候只需要读取原始数据的部分观测值，比如只需要年鉴中的女性数据、收入超过10万的人口数据等。

此时的数据读取方式如下：在SAS读取某一行观测值时，首先读取足够的变量以便决定是否需要保留此行的观测值。然后在input语句结尾加符号@，叫做a trailing at（called a trailing at），这告诉SAS先停在（hold）此行，同时用IF语句检测此观测值是否满足需要，如果是，那么可以再用一个input语句来读取现有的变量。

例子 有一个关于当地交通的数据，traffic.dat数据包含街道的类型（freeways和surface）、街道名称、早晨每小时的机动车流动量、晚上每小时机动车流动量。

   

如果现在你只需要freeway的数据，可以用下述程序：

   

第一个input读取字符串变量，@是SAS停留在观测值上并用IF检测，第二个input读取input后面的变量值。

程序执行后日志包括两部分说明，一个说明读取了8个记录，另一个说明新数据集中只包含三个观测值。

   

输入结果如下所示：

   

 

**@ vs @@** @的作用类似于@@，都是行停留指示符（line-hold specifiers），不同地方在于停留多久，@能使SAS停留到下一个input语句（也不换行），@@能使停留的时间到下一个data步（也不换行）。

比如这段代码：

data test;                                                                                                                              

​    infile cards ;                                                                                                                      

​    input x @; 

​    input y; 

​    input z @@; 

cards;                                                                                                                                  

1 2 3 4 5 6                                                                                                                             

7 8 9 10 11 12                                                                                                                          

13 14 15 16 17                                                                                                                          

;                                                                                                                                       

run;

test输出结果就是：

​     

 

 

 

### 2.14 用infile语句中的选项控制输入

读取原始(raw)数据时，SAS做了某些假设，比如从第一行开始读取数据，对于跨行观测值，会自动转到下一行继续读取。但有的特殊数据不满足这些假设，infile语句的选项可以让SAS读取这些特殊数据。

**FIRSTOBS=** FIRSTOBS= 选项告诉SAS从哪一行开始读取数据，当数据开头有些说明信息，或者想要跳过某些行时，这个选项很有用。例如，如下原始数据文件中，开头两行是关于数据的描述：

   

那么用如下程序可以让SAS从第三行开始读取数据：

   

**OBS=** OBS=告诉SAS一直读取到哪一行位置，注意是行而不是观测值（有的观测值占据多行）比如，如下的原始数据文件中，结尾处还有一句不需要的数据说明时。就需要这个选项：

   

用FIRSTOBS=3和OBS=5就可以读取第三行到第五行的数据：

   

**MISSOVER** 在input语句中输入的几个变量，SAS在观测值中就读取几个变量，如果一行未读完，则进入下一行直到输入的变量都读取了变量值。missover可以让SAS不进入下一行读取，未赋值的变量就使其成为缺失值。当如下这种数据，就需要missover选项，一个学生应该有5门课的成绩，但由于最后两门是自学课程，不是所有学生都完成，故而缺失：

   

如下的程序可以让SAS将Nguyen第五门课的成绩设为缺失值，从而不牵扯到下一行：

   

**Truncover** 使用column input或formatted input输入时可能会需要这个选项，因为这时有的数据行比其他的短。如下的原始数据中，由于三行的长度都不一样，input中只能指定最长的一行：

   

程序如下：

   

这里指定了第二行的长度street $ 22-37，但是第一行maple ave.并没占够至第37列（注意后面是没有空格的），故而必须用truncover，否则会转到下一行继续读取，第三行情况也是。

 

### 2.15 用数据步读取分隔符文件（delimited files）

分隔符文件中，变量值之间会用一些特殊的字符隔开，比如逗号或制表符。DLM=和DSD选项可以让SAS容易地读取这些分隔符文件。

**DLM=**  用list input读取文件时，变量值之间应该用空格隔开。对于其他的分隔符，可以用DLM=/DELIMITER=选项来指定，从而可以读取文件。

**例子** 如下的数据中，学生姓名、每周读书数目是用逗号隔开的：

   

用选项来指定分隔符即可：

   

如果原始数据是用制表符隔开的，那么可以使用DLM=’09’X来指定，因为制表符的十六进制值是09，如果你电脑使用EBCDIC（扩充的二进制编码的十进制交换码），那么应该用DLM=’05’X。

```
DSD选项 DSD (Delimiter-Sensitive Data)有三个作用：忽略引号中数据的分隔符，例如一个观测Joseph,76,"Red Racers, Washington"非引号中的逗号能识别成分隔符，而引号中的逗号不能识别；自动将字符串中的引号去掉；将两个相邻的分隔符当作缺失值来处理。并且，DSD默认分隔符为逗号，如果数据中的分隔符不是逗号，那么要用DLM来指定。比如，读取一个制表符为分隔符、并且用两个制表符代表缺失值的数据文件，则要用下面的语句：
```

INFILE ’file-specification’ DLM=’09’X DSD;

**CSV****文件** CSV文件，Comma-separated values files(逗号分隔的文件)，是可以用DSD选项的文件类型。Excel可以储存CSV格式的文件。

**例子** 某咖啡馆，老板每晚请不同的乐队表演来吸引顾客，他记录了乐队名称、演出日期、晚上8点、9点、10点、11点的顾客数量：

   

注意，其中有一个乐队的名字中用逗号来分隔，并且使用了引号。最后一条记录中还有一个缺失值，用两个连续的逗号表示。INFILE语句中的DSD选项可以用来读取这个文件，并且，由于每个记录长度不一样，还需要用missover：

   

注意bandname和GigDate两个变量使用了**冒号修改器**，冒号修改器告诉SAS读取信息的长度（BandName为30，GigDate为10）。如果不加冒号修改器，将会默认每个变量的长度为该变量取值最长的那个值的长度，输出结果如下：

   

 

### 2.16 用导入过程（IMPORT procedure）读取分隔符文件

Proc import会浏览你的数据文件，自动决定变量类型（字符串或数值），为字符串变量分配正确的长度，辨认出日期变量。Proc import会将两个连续的分隔符视为缺失值，会读取引号中的变量值。一行读完后，会自动分配缺失值给未赋值的变量。此外，如果你愿意，你可以使用你的数据文件中的第一行作为变量名。导入过程（IMPORT procedure）自动为你写下数据步，这可以在提交之后的日志窗口中查看。

一个导入过程（IMPORT procedure）的最简单形式：

PROC IMPORT DATAFILE=’filename’ OUT=data-set;

用语句DATAFILE=’filename’读取文件名，用OUT=data-set创建SAS数据集。SAS会通过文件的扩展名来检测文件的类型：

   

如果文件没有正确的扩展名，或者是DLM格式的，必须在proc import语句中用DBMS=option。如果想要创建的数据集名字已经存在，那么要用replace选项代替。一个使用replace和dbms的例子。

PROC IMPORT DATAFILE=’filename’ OUT=data-set DBMS=identifier REPLACE;

导入过程（IMPORT procedure）从数据文件中的第一行获取变量名，可以通过在PROC IMPORT后面增加GETNAMES=NO语句来改变这种默认，PROC IMPORT会分配给变量名字：VAR1，VAR2，VAR3等。如果你的数据文件是DLM类型的，PROC IMPORT会假定分隔符为空格，用DELIMITER=可以改变默认（空格）的分隔符。

DATAROWS = n;  Start reading data in row n. Default is 1. 

GUESSINGROWS = n; Use nrows to determine variable types. Default is 20.

如下是一段有上述代码的程序：

   

**例子** 下面还是使用咖啡馆中，乐队表演的例子（2.15），注意其中有一个乐队的名字中用逗号来分隔，并且使用了引号：

   

用proc import读取数据的代码如下：

   

输出结果如下，注意GigDate的日期格式能够被proc import辨认出来：

   

 

### 2.17 用导入过程（IMPORT procedure）读取PC文件

如果安装了SAS/ACCESS模块，导入过程（IMPORT procedure）可以导入一些PC文件类型。它会浏览你的文件以决定变量类型，并默认使用数据的第一行来分配变量名。Windows操作环境中可以导入excel、Lotus、dBase、和Access文件。Unix系统中可以导入dBase文件，并且从SAS9.1开始，Unix系统也可以导入excel和access文件。在windows环境中有一个不需要SAS/ACCESS模块的方法——Dynamic Data Exchange(DDE)，将在2.18中讲解。

**Microsoft Excel****，****Lotus****，和****dBase****文件** 下面是用导入过程（IMPORT procedure）读取PC文件的一般过程：

PROC IMPORT DATAFILE=’filename’ OUT=data-set DBMS=identifier REPLACE;

如果读取的文件是如下类型，就不用DBMS=OPTION。

   

在读取excel时，有时需要指定要读取的是哪一个工作薄——sheet

SHEET=name-of-sheet;

默认情况下，导入过程（IMPORT procedure）会从工作薄的第一行中读取变量名。如果不需要，可以用如下代码使得SAS给变量赋名为F1，F2等。

GETNAMES=NO;

**Microsoft Access Files** 读取这种文件需要用DATABASE=和DATATABLE=，而不是DATAFILE=option。

   

下面的是DBMS可以辨认的Access文件

   

**例子** 有如下的EXCEL数据：

   

读取的proc import程序：

   

输出结果如下：

   

### 2.18 用DDE读取PC文件

DDE，动态数据交换（Dynamic Data Exchange），读取PC文件的优点为：可以直接访问存于PC文件中的数据，不要求购买其他SAS产品；缺点为：只能用在windows环境下，只能在程序运行时（比如excel），SAS才能进行读取。

有几种方式可以用DDE访问数据：

l  复制数据到剪贴板

l  指定DDE三元组

l  从SAS中启动PC程序，然后读取数据。

**复制数据到剪贴板** 可以直接复制数据至剪贴板，然后在SAS程序的DDE FILENAME 语句中是使用CLIPBOARD关键字。比如，excel中有如下的工作薄：

   

复制A2到G5，然后在不关闭excel的状态下，提交如下SAS程序：

   

FILENAME语句将指代的文件（BASEBALL）定义成DDE类型，并指定从剪贴板（CLIPBOARD）中去读取它。DDE默认空格为分隔符，如果变量值之间有空格，则要在INFILE语句中用NOTAB选项和DLM=’09’X选项，前者告诉SAS在变量值之间放置制表符，后者告诉SAS将制表符定义为分隔符。如果数据中有缺失值，则要在INFILE中加入DSD和MISSOVER选项，前者将两个连续的分隔符视为缺失值，后者告诉SAS如果此行读完，不要进入下一行给未赋值的变量赋值。

**指定****DDE****三元组** 这种方法可以不用复制数据，直接指定出文件的DDE三元组。DDE三元组的形式为：**application|topic!item****。**

有一种方法可以在SAS中直接查看文件的DDE三元组，方法为：复制数据至剪贴板里，触发SAS会话，从解决方案（Solution）菜单中选择附件（Accessories）——DDE三元组。一个窗口会出现你复制文件的DDE三元组。比如，一个工作薄的DDE三元组为：

Excel|C:\MyFiles\[BaseBall.xls]sheet1!R2C1:R5C7

读取这个文件的FILENAME语句为：

FILENAME baseball DDE 'Excel|C:\MyFiles\[BaseBall.xls]sheet1!R2C1:R5C7';

**从****SAS****中启动应用程序** 这种方法可以不用在运行SAS之前启动数据程序。想要从SAS中启动程序，然后读取数据，则首先需要NOXWAIT和NOXSYNC系统选项，然后使用X语句，一个例子：

   

NOXSYNC和NOXWAIT语句告诉SAS不要等待用户输入。X语句告诉windows执行或打开引号中路径的文件，注意这里路径设置了两个引号，如果路径中有空格，则要设置两个引号。使用这种方法，必须要在FILENAME语句中指定DDE三元组。

### 2.19 临时和永久数据集

SAS临时数据集只在目前工作或会话中存在，关闭SAS或结束工作时则删除；永久数据集当关闭SAS或结束工作时仍然存在。

**SAS****数据集名** 所有的SAS数据集都有用句号分开的两层数据集名，如work.a。第一层前缀work是逻辑库名，第二层是在逻辑库中用于辨别自己的成员名。

名字的规则是，以字母或下划线开头，并且名字中只能包含字母、数字和下划线。而且，库名不能超过8个字节，而成员名却可以达到32个字节。

大部分数据集通过数据步创建，过程步也可以创建。如果指定了一个前缀不为work的两层数据集名，则这个数据集就是永久的。如果不指定前缀，则默认数据集是临时的，自动分配到work逻辑库中。下面是一些数据集名对应的逻辑库，成员名，类型：

   

**临时数据集** 如下的程序创建并打印了一个名为DISTANCE的临时数据集：

   

这里，只指定了成员名distance，自动分配到work库中，日志窗口中有说明：

NOTE: The data set **WORK.DISTANCE** has 1 observations and 2 variables.

**永久数据集** 可以在资源管理器窗口中定义一个新库使用：

   

也可以通过如下程序：

   

那么日志窗口就会出现如下说明：

NOTE: The data set **MYLIB.DISTANCE** has 1 observations and 2 variables.

这是一个永久数据集，因为前缀不是work。

### 2.20 用LIBNAME语句使用永久数据集

LIBNAME语句的基本形式为：LIBNAME libref ’your-SAS-data-library’;

LIBNAME的后面，需要指定库名和存放的路径，在个人操作环境下LIBNAME语句的基本形式为：

   

**创建永久数据集** 如下的例子创建了一个永久SAS数据集，包含了magnolia trees的一些信息。每一种树，原始文件都包含它的科学名、普通名、最大高度、第一次开花的年龄、是evergreen还是deciduous、以及花的颜色。

   

下面的代码将会创建一个PLANTS的逻辑库，路径为C盘下的MySASLib。然后从原始文件Mag.dat中读取数据，并创建一个名为MAGNOLIA的永久数据集，存在PLANTS库中。

   

日志窗口会出现如下说明：

NOTE: The data set **PLANTS.MAGNOLIA** has 5 observations and 6 variables.

如果在电脑中打印文件的地址目录，会发现文件名不是PLANTS.MAGNOLIA。这是因为操作系统有自己对文件命名的方式，这个文件，在Windows, UNIX和OpenVMS操作环境中名字为magnolia.sas7bdat，在OS/390或者z/OS环境中，文件名就会如LIBNAME语句中定义的data-set-name形式。

**读取永久数据集** 如果你想打印出上例中创建的数据集，可以用如下语句：

   

这次LIBNAME语句中的库名为example，但却是同样的路径，逻辑库名可以改变，但成员名MAGNOLIA却一样。输出如下：

   

 

### 2.21 通过直接指代使用永久数据集

可以通过直接指代来使用SAS数据集，且不需要自己定义，SAS为你做好。

直接指代，依据系统不同，使用方法也不同，如下：

   

可以看到，一些系统的语句中需要指出路径，但如果遗漏了路径，SAS自动使用当前路径，比如这样一个创建名为trees的永久数据集的代码：

DATA ‘trees’;

UNIX和OPENVMS操作环境下，当前的路径默认为启动SAS的路径，可以通过工具（TOOLS）下拉菜单的选项（OPTIOPN）菜单来改变这种默认，windows环境下当前路径会显示在SAS窗口底部。可以通过双击这个路径来改变默认。

**例子** 如下还是关于magnolia trees的这个例子，

   

下面的代码将从原始文件mag.dat中读取数据，创建一个名为MAGNOLIA的永久数据集，存放在C盘的Mysaslib路径中：

​        

相应的输出窗口显示如下：

NOTE: The data set c:\MySASLib\magnolia has 5 observations and 6 variables.

如果打开MySASLib文件夹，会发现一个名为magnolia.sas7bdat的文件。在没指定库的情况下，SAS会自动为你创建一个库，在资源管理器窗口中可以看到，右图是SAS为magnolia创建的库。

用直接指代读取SAS数据集可以直接用引号+路径的方式读取永久数据集，比如打印magnolia数据集可以：

 

 

   

输出窗口如下：

   

 

### 2.22 列出SAS数据集目录

由于SAS是自文档化，即在自动储存了数据集的信息，因此可以通过contents过程来查看SAS数据集的描述。

Proc contents data=data-set

如果遗漏了data=的语句，SAS自动列出最近创建的数据集。

**例子** 如下的程序创建了一个数据集，并且使用proc contents。数据步中使用了label语句，label语句为变量打上标签，并储存在数据集中，在打印时会显示。过程步中也可以使用label，但只在proc contents中有效，不会储存在数据集中。Informat和format可以指定信息和格式，储存在数据集中，也可以在过程步中使用，但不储存在数据集中。

   

输出如下：

   

输出先显示了数据集的信息，然后介绍了每个变量。

   




## 第三章 开发你的数据

### 3.1 创建并重新定义变量

可以通过分配语句来创建并重新定义变量，基本形式为：

Variable=expression

Variable是变量名，expression可以是常量、其他变量、或者数学表达式。分配语句的基本类型有：

   

Expression是数学表达式时，需要遵循运算法则，先算指数、再算乘除、之后是加减。可以用括号改变运算等级。

**例子** 如下是一个农产品估重数据，每位农民要求对他们的番茄、南瓜、豌豆、葡萄进行估重：

   

下面代码从garden.dat原始文件中读取数据，并进行修改：

   

这个程序包含了5句分配语句，第一个将14赋值给zone，第二个使type等于一个字符串常量……打印出的结果中，既包括旧变量，又包括新变量：

   

由于观测值susan的peas变量出现了缺失值，因此这个观测值的total和pertom变量也出现了缺失值。日志窗口的说明如下：

NOTE:Missing values were generated as a result of performing an operation on missing values.

### 3.2 使用SAS函数

SAS有400多个函数，主要涵盖如下领域:

   

函数基本形式：function-name(argument,argument,…)，所有的函数都需要括号，即使没有参数。下面的程序计算使用MDY函数，MDY函数需要三个参数：月、日、年。

Birthday=MDY(MonthBorn,DayBorn,YearBorn);

函数可以嵌套，即一个函数可以是另一个函数的参数。比如：NewValue=INT(LOG(10));

**例子** 有一个南瓜雕刻比赛的数据，pumpkin.dat数据包含了参赛者的名字、年龄、雕刻的南瓜类型、报名日期、五位裁判给出的分数。

   

下面的代码读取了数据、创建了两个新变量、转换了一个大小写：

   

AvgScore 使用均值函数创建的变量，计算参数的均值，这与直接相加再除以5不同的地方在于，当参数中出现缺失值时，直接相加再除的方法返回缺失值，而均值函数计算非缺失参数的均值。

DayEntered变量使用DAY函数，返回日期在一个月里的天数。

Type用大写转换函数将原来的字母转换成大写字母。

结果是：

   

 

### 3.3 选出的SAS字符函数

### 3.4 选出的SAS数值函数

### 3.5 使用IF-THEN语句

条件语句IF-THEN的基本形式为：IF 条件 THEN 执行;

比如：IF Model='Mustang' THEN Make='Ford';

条件语句中的一些基本比较符号：

   

还有IN比较符，比如这句中IF Model IN('Corvette','Camaro') THEN Make='Chevrolet';代表当Model为Corvette或Camaro的时候，将Chevrolet赋给Make。

一个条件只能有一个执行，如果要多个执行，则需要DO和END关键字。

   

可以用AND和OR来定义多个条件：IF Model='Mustang' AND Year<1975 THEN Status='classic';

   

**例子** 如下的数据包含了模型的名字、年份、制造商和颜色：

   

下面的代码从cars.dat的原始文件中读取数据，使用IF-THEN语句填满缺失值，并创建一个新变量Status

   

输出结果如下：

   

 

### 3.6 用IF-THEN语句将观测值分组

IF THEN/ELSE的一般形式为：

IF condition THEN action;

ELSE IF condition THEN action;

ELSE IF condition THEN action;

用else语句与直接用多个IF-THEN语句比起来，有两个优势，第一是更有效率，电脑将占用更少的时间；第二是else可以确保你的两个condition之间互斥。

有时候最后一个ELSE只有action，没有IF-THEN：

   

**例子** 有一个住房改善的数据，home.dat，包括了姓名、改善工作、改善成本：

   

下面的代码读取数据，并新建了一个CostGroup的变量。根据Cost的值将数据分成high、medium、low和missing三类：

   

输出结果是：

   

 

### 3.7 构造子集

IF语句可以构造子集，取数据集中的部分数据。

基本形式为：IF+expression;  比如：IF Sex='f';

如果IF条件中的数据是真，则数据步将继续执行。

还可以使用DELETE语句，来删除哪些不要的数据： IF expression THEN DELETE;

这两句话是等价的：IF Sex='f'; IF Sex='m' THEN DELETE;

**例子** 有关于莎士比亚歌剧的清单，Shakespeare.dat，包含歌剧名、首次表演年份、类型：

   

下面的代码读取数据，并且用IF语句构造一个只包含喜剧（comedies）的子集：

   

输出结果如下：

   

观察日志有时能很好的保证我们截取了我们要的数据：

   

在这个例子中，用DELETE等价的语句为：

IF Type='tragedy' OR Type='romance' OR Type='history' THEN DELETE;

### 3.8 处理SAS的日期数据

日期数据的处理很棘手，有的月份有31天、有的30天、有的28天。SAS简化的日期数据，将所有的日期转化成一个以1960年1月1日为起点的数。比如：

   

SAS处理日期数据的三个工具为：读取数据的informats，使用数据的函数（functions），打印数据的formats。

**Informats** 读取日期数据需要用formatted input。比如，如何告诉SAS用MMDDYY10. informats读取名为BirthDate的变量：

INPUT BirthDate MMDDYY10.;

**设定默认的百年** 07/04/76这样的数据可能是1976，也可能是2076、1776。因此需要YEARCUTOFF=来指定一个一百年的第一年，默认的是1920年。下面的语句就是告诉SAS将一个两位年份的日期解释为1960年到2049年之间：

OPTIONS YEARCUTOFF=1950;

**SAS****表达式中的日期** 一旦被以SAS日期格式读取之后，可以将此数据想其他数值数据一样用在表达式中。比如像为图书馆的书设定21天的还书日期，只需要在结束日期上加上21：

DueDate = CheckDate + 21;

通过在表达式中加入引号和字母D，可以将一个日期当做常数来使用，如下的代码创建了一个EarthDay05的变量，并且等于April 22,2005

EarthDay05='22APR2005'D;

函数 SAS日期函数使得操作大大简便，比如today（）返回今天的日期。

语句DaysOverDue=TODAY()-DateDue;可以计算一本书应归还的剩余期限。

**Formats**打印日期数据时，还需要将数值换成日期，下面的FORMAT语句告诉SAS用WORDATE18.格式打印变量BirthDate。

FORMAT BirthDate WORDATE18.;

**例子** 图书馆有借书卡数据，Dates.dat，包含持卡人姓名、出生日期、卡办理日期。

   

下面的代码读取数据，计算变量使用期限（expiredate），使用期限为3年；变量expirequarter计算使用期限的四分之一，使用函数QTR（）。接着用IF语句来判断一个卡是否为新卡，在2003年1月1日之后办理的，为新卡：

   

输出结果为：

   

注意BirthDate没有用日期格式。

### 3.9 可选择的Date Informats、Functions和Formats

   

   

   

 

下面是例子：

   

   

   

 

### 3.11 使用retain和sum语句

当开始数据步的每一个观测值迭代时，SAS会先将所有变量值设为缺失，再通过input和分配语句改变。Ratain和sum语句可以改变这种方式。

**Retain****语句** retain语句可以让SAS保存前一次变量的值。它可以出现在数据步的任何位置，基本形式为： 

RETAIN variable-list;

也可以指定一个初始值，而不是用缺失值或前一次的值代替初始值

RETAIN variable-list initial-value;

**Sum****语句** SUM语句用于你想将一个表达式的值累加到一个变量上去时，基本形式为：

variable+expression;

这个语句将表达式的值赋给变量，同时将变量的值保留到下一次迭代。这个变量必须是数值型，且初始值为0。因此，语句等价于如下形式：

RETAIN variable 0;

variable=SUM(variable,expression);

例子 有一个关于本赛季棒球比赛的数据，games.dat，包含比赛日期、参赛队伍、hit数据、runs数据

   

现在需要增加两个变量，一个反应本赛季的总runs数，一个反应一场比赛中最大的runs数。下面的代码用sum语句实现总run数，用retain和max函数实现最大runs数：

   

变量maxruns取前面迭代的maxruns和runs中最大值；变量runstodate将每一场比赛的runs都加到自己身上。结果如下：

   

 

### 3.12 用数组简化程序

对于太多变量要处理的程序，数组将大大简化程序。

SAS中，数组是一组变量，变量可以是已存在的，也可以是新创建的。

数组在数据步中用ARRAY来定义，基本形式为：

ARRAY name(n) $ variable-list;

Name是数组名，n是变量数，()也可以用[]和{}代替。如果变量是字符串，则需要$，且变量是新创建的字符串时，$是必须的。变量名依照顺序排列，如数组：

ARRAY store(4) Macys Penneys Sears Target;

则store(1)是Macys，store(2)是Penneys，store(3)是Sear，store(4)是Target。

数组本身不储存在数据集中，只有在数据步中才被定义。命名规则与变量一样（不超过32字节，以字母、下划线开头，只能包含字母、数字、下划线）

**例子** 广播电台wbrk做了一份关于歌曲的听众调查，对10首歌进行打分，分值在1-5，如果没听过则填9。数据文件wbrk.dat包括了被访者姓名、年龄、以及十首歌的打分。

   

下面的代码将所有打分为9的改为缺失值：

   

十首歌被放入song的数组中。输出结果如下：

   

注意这里数组没有被保存到数据集中，而i被保存了。

 

### 3.11 列出变量名的快捷方式

如果想把100个变量放入数组，并不需要一个一个变量名的输入，有快捷方式可以列出变量名。

**Number range lists** 开始于同一个单词，结尾于连续的数字的，可以使用Number range list。比如：

   

**Name range lists** 这种列表是依据变量在数据集中的排列顺序来的，比如，创建如下数据步：

   

则变量的排列顺序就为：Y A C H R

那么可以依照这个顺序用“put 第一个变量--最后一个变量”来简化：

   

如果不能确定数据集中变量的顺序，可以用proc contents的postion选项来查看。下面的代码列出了永久数据集distance的变量顺序：

   

**Special sas name list** 特别的名字列表，_ALL_、_CHARACTER_、_NUMERIC_可以用于任何你想使用的地方，所有的变量，所有的字符变量，或所有的数值变量。当你想要做某些事的时候，例如计算一个观测的数值型变量的平均值（MEAN（of _NUMERIC_）），或列出的所有观测中的变量值（PUT_ALL_;)，这些名单是有用的。

 

**例子** 广播电台WBRK想要修改前面的代码（将9改为缺失值），使用mean函数计算平均分数：

   

程序中，当原始变量（domk-ttr）值为9时，song变量值为缺失值，否则就把原始变量的值赋给song变量。另外avgscore计算平均值：

   




## 第四章 排序、打印并描述你的数据

### 4.1 使用SAS过程步

​     使用过程步就像填写一个如左图的表格，当然每个过程步都有独特的地方，本部分主要讨论各过程步相同的地方。

大部分过程步都有一个必须的语句，也有可选的语句，比如打印语句：proc print，这两个词是必须的，但可选的语句也有很多。

 

**Proc****语句** 所有的语句的必须部分为proc+过程名，比如print、contents等。后面接一些可选项。比如proc print data=banana；

data=banana选项告诉SAS打印哪个文件，如果不加，则SAS默认打印最近使用的数据。前面还可以加libname语句，建立一个对本地文件的链接（2.20），比如：

LIBNAME tropical 'c:\MySASLib';

​       PROC CONTENTS DATA=tropical.banana;

或者直接引用（2.21）：PROC CONTENTS DATA='c:\MySASLib\banana';

 

**BY****语句** BY语句只在过程proc sort中是必须的，它用来对观测值排序。其他过程BY告诉过程对变量进行分别分析，且是可选的。比如要对每个州进行分别分析，则为：BY State

另外，除了proc sort，其他过程都假设了数据已经进行了排序，所以如果数据还没有排序，那么在分析之前要用proc sort排序。

 

**TITLE** **和****FOOTNOTE****语句** 这是为输出加上标题和脚注。最基本的title语句为：title ‘标题’，双引号、单引号皆可，比如：

TITLE 'This is a title';

如果标题中带有撇号，则需用双引号，或者将撇号换为双撇号：

TITLE ”Here’s another title”;

TITLE ’Here’’s another title’;

可以通过在title、footnote后面加上数字来添加多个标题和脚注：

FOOTNOTE3 ’This is the third footnote’;

但是小数字的标题会代替大数字的标题，如title2会代替title3。

标题的去除可以用title+空值：TITLE; footnote+空值：footnote;

 

**Label****语句** 它可以为输出的变量加上标签，一个标签最大256字节，下面的代码为receivedate和shipdate创建了标签：

LABEL ReceiveDate=’Date order was received’

ShipDate=’Date merchandise was shipped’;

注意的是，在数据步中使用label语句，则标签会保存在数据集中；在过程步中使用，标签只在这个过程中有效。

 

**定制输出** 使用系统选项，可以为输出设置诸如居中、日期、单行长度、页长度等。使用Output Delivery System，还可以改变输出的风格，以不同的格式输出（HTML、RTF），甚至改变输出的任何细节。

 

**输出数据集** 可以用ODS OUTPUT语句为输出结果创立一个数据集（5.3），一些过程中也可以用out=option。

 

### 4.2 用where语句在过程中构造子集

也可以用where构造子集，它方便快捷，因为他不创建新的数据集。且能够用在过程步中。

Where语句的基本形式为：

WHERE condition;

只有满足条件的观测值才进行proc过程。

一些使用最多的操作符及例子：

   

**例子** 有一份关于画家的数据，artists.dat，包含画家的姓名、主要风格、国籍：

   

第一步首先是数据步，读取数据、使用直接指代在C盘mysaslib目录下创建一个名为style的数据集。

   

某天如果想打印出印象派impressionism画家的情况，那么可以使用where语句

   

输出结果为：

   

 

### 4.3 用proc sort为数据排序

基本形式为：

PROC SORT;

​           BY variable-1...variable-n;

SAS首先会按照第一个变量排序，再对后面的排序。

Data=，out=用来指定输入和输出数据，如果缺失out=，则SAS会将排序后的数据集代替原来的数据集。下面的代码告诉SAS对数据messy排序，并将排序后的数据存在neat中：

PROC SORT DATA=messy OUT=neat;

选项nodupkey告诉SAS排序时删除重复值，比如：

PROC SORT DATA=messy OUT=neat NODUPKEY;

SAS默认是升序，可以用选项DESCENDING来变成降序，将DESCENDING加在要降序的变量前面：

BY State DESCENDING City;

**例子** 下面的数据显示了一些鲸鱼和鲨鱼品种的平均长度：

   

下面的代码读取并排序数据

   

输出结果为：

   

因为SAS认为缺失值是比字符串和数值都小，所以排在了第一位。另外，由于whale shark 40的数据有两个，故因为nodupkey选项而被删除一个。说明可见日志：

   

 

### 4.4 用proc print打印你的数据

基本形式：PROC PRINT;

SAS默认打印最近使用的数据集，DATA=可以指定数据集：

PROC PRINT DATA=data-set;

SAS默认打印观测值数，noobs选项可以取消。SAS默认打印时用变量标签代替变量，用label可以改变取消：

PROC PRINT DATA=data-set NOOBS LABEL;

还有下面的选项：

BY variable-list; 前提是数据必须进行排序

ID variable-list; 指定观测变量

SUM variable-list; 打印变量总数

VAR variable-list; 指定打印哪部分变量以及打印顺序，默认打印全部。

 

**例子** 有学生卖糖果的数据，Candy.dat，记录学生名、所属班级、销售日期、卖的糖果类型、卖出的糖果数。

   

下面的程序读取数据、计算每个学生赚得的利润（每买一块赚1.25美元），并用proc sort按班级排序。接着在proc print语句中加入by，以分班级打印，加入sum，计算每个班级总利润：

   

输出结果为：

   

 

### 4.5 用formats改变打印外观

打印数据时，SAS会自动为你安排最好的格式，小数点位数、空格等。

当不需要默认格式时，可以用SAS formats改变打印的外观。

对于字符串、数值、日期变量，SAS有很多格式。比如可以用commaw.d格式打印有逗号的数字，用$w.格式控制打印的字符数，用MMDDYYw.格式将日期（以1960.1.1为基点的数字）打印成12/03/2003这样的格式。甚至可以将格式打印成十六进制、区位十进制、压缩十进制等。

SAS格式的普通形式为：

   

符号说明：$说明了是字符串、format是格式名、w是包括在小数点在内的长度、d是小数位数。句号非常重要，它用来区分格式名和变量名。

 

**Format****语句** 可以用format语句同时将格式和变量联系起来，用format+变量名+格式名，比如想要将格式DOLLAR8.2和变量profit、loss联系起来，把格式MMDDYY8.和格变量saledate联系起来：

FORMAT Profit Loss DOLLAR8.2 SaleDate MMDDYY8.;

Format可以用在数据步和过程步中，前者将把格式永久储存，后者只是临时储存。

注：DOLLAR8.2表示打印的结果字符数不超过8（数值+$）。

 

**Put****语句** 当写原始数据或者报告时，也可以在put语句中使用formats，在每个变量后面加上格式：

PUT Profit DOLLAR8.2 Loss DOLLAR8.2 SaleDate MMDDYY8.;

 

**例子** 在上面的学生卖糖果的案例中，可以看到输出的日期是SAS日期值，这里用format变换成日期格式，并且用DOLLAR6.2将利润换成货币格式，

   

输出结果为：

   

 

### 4.6 可供选择的formats

   

   

下面是

​      

 

### 4.7 使用proc format创建自己的格式

有时候用数字代表实际的变量值，比如1代表男性，2代表女性，这种代码在打印的时候不好解读，可以用proc format使得打印出想要的值。

基本形式为：

   

Value语句中的name是格式的名字，如果格式是位字符串设计，则必须以$开头，长度不能超过32个字节（包括$），不能以数字结尾，除了下划线不能包含其他任何特殊符号。且名字不能与已有的格式名冲突。Range是分配给等号右边文本的变量值，文本可以达到32767个字节，有的过程只会打印前面8或16个字节。下面是一个例子：

   

变量值是字符串时要加上引号，range不止一个值要用逗号隔开，连续的range要用-，关键字low和high可以用来指代变量中最小和最大的非缺失值。也可以用<来排除或指代某些范围，但"<"来表示不包括范围的结尾值。other可以给任何没有列在value语句中的变量分配格式。

 

**例子** 有一份关于汽车公司客户的调查信息。包括客户年龄、性别（1为男性，2为女性）、每年收入、偏爱的汽车颜色（yellow,gray,blue,or white）：

   

下面的代码读取数据，并使用format过程为颜色、性别和汽车创建格式，并在打印数据时用format为变量指定这些输出格式：

   

输出结果为：

   

 

### 4.8 定制一个简单的报告

数据步可以帮助在报告中完成一些个性的需求，比如一页打印一个观测值等。

用file语句和put语句 ，基本形式为：

FILE‘file-specification’PRINT;

如input，put语句也有list，column，formatted方式，但因为SAS已经知道变量类型，因此不用符号$。且如果使用list，SAS会自动在两个变量之间加上空格；使用column或者formatted，SAS将会把变量放在任何你指定的地方。使用指示器@n指定移动到第n列，+n指定移动n列，/跳动到下一行，#n跳动到第n行。用@hold住当前行。

 

**例子** 再一次使用学生卖糖果的案例，Candy.dat，记录学生名、所属班级、销售日期、卖的糖果类型、卖出的糖果数。

   

老师想看每位学生的销售情况，故要每页分别打印一位学生的情况，代码如下：

   

   

Data _null_是告诉SAS不要写数据集名，以便使得程序更快。File语句创建了一个输出文件，空标题title语句告诉SAS去除所有的自动标题。

第一个put语句以一个指示器开头，@5，告诉SAS移动到第5列，接着打印出“candy sales report for”，后面是姓名name。变量name、class和quantity都是以list方式打印，而profit是使用formatted方式打印，并给定格式dollar6.2。一个斜杠是指跳到下一行，两个斜杠是跳到下两行。最后，语句put_page_是在每个学生报告下面插上页码，程序运行后，日志说明如下：

   

前三页报告如下：

   

   

   

 

### 4.9 使用proc means描述数据

可以用proc means查看一些简单的统计量，Means过程开始于关键词proc means，后面接需要打印的统计量，基本形式：

PROC MEANS options;

如果不加选项，则默认打印出非缺失值个数、均值、标准差、以及最大最小值，下面是用选项可以查看的统计量：

   

如果没有其他语句，proc means语句会给你数据集中所有观测值和所有数值变量的统计量，这里是一些可以用到的语句：

l  BY variable-list; 分变量单独分析，但数据必须先按照variable-list的变量顺序排序（proc sort）。

l  CLASS variable-list; 也是分变量单独分析，看起来会更集中一些，且不需要排序。

l  VAR variable-list; 指定分析中使用哪种数值变量，默认则使用所有的数值变量。

 

**例子** 有一个花朵销售的数据，Flowers.dat，包括顾客ID，销售日期，petunias，snapdragons，marigolds三种花的销售量：

   

下面的代码读取数据，计算新变量销售月份month，并使用proc sort按照月份排序，并使用proc means的by语句来按照月份描述数据：

   

输出结果为：

   

 

### 4.10 将描述性统计写入SAS数据集中

有两种方法可以在SAS数据集中储存描述性统计量，Output Delivery System(ODS)，或者output语句。前者在5.3，后者的基本形式为：

OUTPUT OUT=data-set output-statistic-list;

Data-set是要储存结果的数据集名，output-statistic-list则界定需要保存哪些统计量和名称，可能的形式为：

statistic(variable-list)=name-list

statistic可能是proc means语句中的任何一种统计量（sum，n，mean…），variable-list则界定VAR语句中哪些变量需要输出，name-list则定义统计量的新名字。比如，proc means语句产生了一个数据集ZOOSUM，包括一个观测值和变量lionweight（the mean of the lions’ weights），BearWeight（the mean of the bears’ weights）。

   

Noprint是告诉SAS不需要产生任何打印结果，因为已经将结果存入数据集中。

 

**例子** 仍然是花朵销售的数据

   

要描述数据，每个顾客只有一个观测值，包括SUM和MEAN，并且将结果储存到数据集中以便日后分析。下面的程序读取程序，按照CustomerID排序，使用means过程，结果存在totals数据集中。以原始名Petunia,SnapDragon,Marigold给出sum，以新变量名MeanPetunia,

MeanSnapDragon,and MeanMarigold给出mean。

   

结果如下：

   

 

### 4.11 用proc freq为数据计数

对一个变量计算频数叫做one-way，两个叫做two-way，多个叫做交叉表。使用proc freq最明显的目的是现实分类数据的分布情况，基本形式为：

PROC FREQ;

​      TABLES variable-combinations;

产生一维频率表，只要列出变量名。下面的语句列出了变量yearseducation的每一个值的个数。

TABLES YearsEducation;

建立两个变量的交叉表需要一个*号，下面的语句显示变量Sex by YearsEducation的频数情况：

TABLES Sex*YearsEducation;

这个语句之后可以用/option的形式添加选项，主要下面几个：

LIST：用list形式打印交叉表（而不是网格）

MISSING：频率统计量中包含缺失值

NOCOL：强制在交叉表中不打印列百分比

NOROW：强制在交叉表中不打印行百分比

OUT=data-set：输出数据集

比如说，使用第二个选项：TABLES Sex*YearsEducation/MISSING;

 

**例子** 有一家咖啡店的销售数据，记录了销售的咖啡种类（cappuccino,espresso,kona,or iced coffee），以及每次购买的顾客是打包还是原地就饮：

   

下面的代码就产生了一个one-way和two-way的频率表：

   

代码告诉SAS打印两个表，一个是one-way的频率表，一个是交叉表。交叉表的每个小方格内，SAS打印了频数、百分比、行百分比和列百分比。左边和右边是累积百分比。注意计算频数时没有考虑缺失值。

   

 

### 4.12 用proc tabulate产生一个表格报告

比起print means和print freq，Proc tabulate过程产生的报告更耐看。

Proc tabulate的基本形式为：

PROC TABULATE;

CLASS classification-variable-list;

TABLE page-dimension,row-dimension,column-dimension;

Class语句告诉SAS哪些变量将数据分成不同部分。

Table语句可以定义一个表，可以用多个table语句定义多个表，

 

**维度** table语句可以在报告中指定三个维度：页、行、列。如果只指定一个维度，则默认是列维度；如果指定两个，则是行和列。

 

**缺失数据** 默认下不考虑缺失数据，在proc语句后面增加missing选项可以改变这种默认：

PROC TABULATE MISSING;

 

**例子** 有关于船的一些数据，Boats.dat，记录了每艘船的姓名、港口、移动方式（sailing或者power vesse），类型（schooner,catamaran,or yacht），使用它远行的价格

   

你想得到一份报告，包含了每一个港口的、sailing或者power vessel的、每一种类型的、船的数量，下面的代码用proc tabulate创建了一个三维报告：港口作为页、移动方式作为行、类型作为列：

   

报告分两页，港口的每个值情况为一页：

   

 

### 4.13 为proc tabulate输出增加统计量

Class语句列出分类变量，而VAR语句告诉SAS那些变量包含连续数据。基本形式为：

PROC TABULATE;

VAR analysis-variable-list;

CLASS classification-variable-list;

TABLE page-dimension row-dimension column-dimension;

 

**关键词** 下面是tabulate可以计算的值：

ALL:增加行、列或页，显示总数

Max：最高值

Min：最低值

Mean：算术均值

Median：中位数

N：非缺失值个数

Nmiss：缺失值数

P90：90th分位数

Pctn：某类的观测值百分数

Pctsum：某类值总和的百分数

STDDEV：标准差

SUM：求和

 

**Concatenating,crossing,and grouping** 一个维度中，变量或关键词可以被连接、交叉、分组。连接变量或关键词，只需用空格分开列出即可；变量或关键字交叉只需要用*分开列出即可；分组只需要用括号括住变量或关键词。

Concatenating:                          TABLE Locomotion Type ALL;

Crossing:                               TABLE MEAN*Price;

Crossing,grouping,and concatenating:        TABLE PCTN*(Locomotion Type);

 

**例子** 仍然是船的例子，

   

下面的代码类似4.12，但多了VAR语句，table只包括两维，但使用了Concatenate,cross,and group：

   

输出结果如下：

   

 

### 4.14 提升proc tabulate的输出外观

三种方式可以提升输出的外观：

**Format=** **选项** 可以改变数据的格式，比如，在表中使得数字有逗号，并不含小数，则使用：

PROC TABULATE FORMAT=COMMA10.0;

**Box=****和****misstext=** **选项** format只能用在proc语句中，而box=和misstext=只能用在table语句中。box=的作用是在tabulete报告的左上角的空格中写下一句简洁的语句（作用类似标题）。Misstext则是为空数据格指定一个值，默认是一个句号，比如下句：

TABLE Region,MEAN*Sales/BOX='Mean Sales by Region' MISSTEXT='No Sales';

这是告诉SAS在左上角打印“Mean Sales by Region”，并且在没有数据的方格内打印“No Sales”

 

**例子** 仍然是船的数：

   

如下代码比前面多了format、box、misstext语句。注意format要出现在proc语句中，而box和misstext语句则出现在table语句中。

   

这是“被提升了的”外观，由于format指定dollar9.2，因此都用货币格式输出。左上角的full day excursions是由于box语句，空方格内的none是由于misstext语句。

   

 

### 4.15 改变proc tabulate输出的表头

有两种方法可以改变顶部信息

**Class** **变量** **变量值** 要改变class语句列出的变量值的表头，使用format创建一个用户定义的格式，然后用format语句将格式赋给变量。

**变量名和关键字** 改变变量名和关键字的表头，用=’text’赋值即可，可以用等号加空值的方法去除表头，即=’’，语句为：

TABLE Region='',MEAN=''*Sales='Mean Sales by Region';

这是告诉SAS移去region和mean的顶部，并且将sale的表头换为“Mean Sales by Region”

有时候当行顶部被赋为空格时，会留下一个空白空格，可以用row=float强制去除这种空白空格：TABLE MEAN=''*Sales='Mean Sales by Region',Region=''/ROW=FLOAT;

 

**例子** 仍然是船的数据：

   

下面的代码和以前一样，多了对表头的改变，format语句创建了一个用户定义的格式$typ，并用format语句把这个格式赋给变量type，table语句中locomotion、mean、type的表头被赋为空格，price的表头被赋值“Mean Price by Type of Boat.”

   

输出结果为：

   

这样的结果看起来清晰且紧凑。

 

### 4.16 为proc tabulate输出的数据方格指定多种格式

可以为不同变量指定不同格式，基本形式为：

variable-name*FORMAT=formatw.d

比如在table语句中插入这个复杂的语句：

TABLE Region,MEAN*(Sales*FORMAT=COMMA8.0 Profit*FORMAT=DOLLAR10.2);

这是给变量sales指定格式comma8.0，给变量profit指定格式dollar0.2。

 

**例子** 仍然是船的数据，新增加了一个变量，以显示船的长度：

   

假如你想在报告中同时show出平均价格和平均长度，仅为价格指定货币格式。下面的代码这样实现，为变量price指定格式dollar6.2，为length指定格式6.0：

   

输出结果如下，注意价格和长度的格式不一样：

   

 

### 4.17 用proc report产生一个简单的输出

Report包含print、means和tabulate、sort的所有功能，可以用一本书来介绍，基本形式为：

​      PROC REPORT NOWINDOWS;

COLUMN variable-list;

Column语句类似于proc print的var语句，告诉SAS哪些变量该包括并以何种顺序，如果遗漏语句column，SAS默认在数据集中包括所有变量，如果遗漏选项NOWINDOWS，SAS默认启用交互report窗口。

默认情况下，PROC报告立即在列标题下方打印数据。为使数据和顶部能很好的区分开来，可以使用headline和headskip：

PROC REPORT NOWINDOWS HEADLINE HEADSKIP;

Headline在顶部下面拉了一条线，headskip在顶部下面留了一段空白。

 

**数值变量****VS****字符串变量** 从proc report得到的报告类型，部分依据于使用的数值类型。只要报告中起码有一个字符串变量，默认的报告就是每个观测值一行。但如果报告全是数值变量，默认proc report将会加总这些变量，即使是日期变量也会被加总。

 

**例子** 有一份关于美国国家公园（national parks）和国家纪念碑（monuments）的数据，Parks.dat，变量包括名字、类型（NP for national park or NM for national monument），地区（East or West），博物馆的数量，野营地的数量：

   

下面的代码形成了两份报告，第一份没有column语句，SAS使用所有变量，第二份使用column语句，选择部分变量：

   

第一份报告与proc print相似，第二份报告，由于只选择museum变量和camping两个数值型变量，默认直接显示加总情况：

   

 

### 4.18 在proc report中使用define语句

Define用来为单个变量指定一些选项，基本形式为：

DEFINE variable/options’column-header’;

 

**Usage****选项** 这个选项告诉SAS如何使用这个变量，可能的usage选项包括：

Across：为变量的每一个变量值都创建一个列

Analysis：为变量创建统计量，数值变量默认有这个usage选项，且统计量默认为sum。

Display：为数据集中的每一个观测值都创建一行，对于字符串变量，这个选项是默认的。

Group：为每个变量的变量值都创建一行。

Order：为每个观测值都创建一行，且行值的排列是按照指定的变量来顺序。

 

**改变列表头** proc report中几种方法可以改变列表头，4.1中的label语句，或者用define语句指定列表头，下面的代码使得SAS的report按照age排序，并且以“Age at Admission”作为列顶部：

DEFINE Age / ORDER 'Age at/Admission' WIDTH=9;

您可能需要指定的width选项，使您的列表头适合它。在这个例子中，Admission这个词有9个字符，所以宽度必须至少为9。

 

**缺失数据** 默认在order，group，和across variables中不考虑缺失值，用missing选项可以改变这种默认：

PROC REPORT NOWINDOWS MISSING;

 

**例子** 仍然是关于国家公园和纪念碑的数据：

   

下面的代码包含两个define语句，第一个用order选项来定义region，第二个为变量camping定义列表头。Camping是一个数值变量，默认有analysis选项。Missing选项也出现在了proc语句中，因此缺失值也会被考虑在报告中：

   

输出结果为：

   

Region有三个变量值，第一个是missing缺失值。

 

### 4.19 用proc report创建简易报告

Group创建简易行，across创建简易列。

 

**Group** **变量** 下面的代码告诉SAS创建一个显示每个部门工资总和、奖金总和（数值变量将默认被加总）的报告：

   

 

**Across****变量** 为了定义acorss变量，也需要define语句，不同的是，SAS默认不是对变量值求和，而是计数。如果要加总，则需要在across变量和analysis变量之间加逗号，告诉SAS哪个变量要加总，下面的代码告诉SAS用列来显示出每个部门工资和奖金的总和：

   

 

**例子** 仍然是国家公园和纪念碑的例子，

   

下面的代码包含两个proc report，第一个中，region和type都被定义成group变量，第二个中，region仍然是个group变量，但type是across变量。注意两个column语句基本一样，除了第二个中增加了逗号将across变量和analysis 变量交叉。

   

输出结果为

   

 

### 4.20 给proc report输出增加summary break

Break语句可以为报告增加停顿，为每个指定的变量的变量值增加停顿。基本形式如下：

​     BREAK location variable/options;

RBREAK location/options;

Location有两种可能值——before和after，决定是之前停顿还是之后停顿。斜杠之后的选项告诉SAS插入哪种停顿，主要类型有：

OL        停顿的地方加入横线

Page       开始一个新的页面

Skip       插入一个空行

Summarize  插入数值变量之和

UL         在停顿下面划线

需要注意的是，break要求指定一个变量，而rbreak不需要。因为rbreak只产生一个停顿（开始或结尾），而break语句为指定的变量的每一个变量值都产生停顿。这个变量必须是group变量或order变量，并且要在define语句中定义过。可以在任何报告中使用rbreak语句，但只能在有最起码一个group或者order变量的报告中使用break语句。

 

**例子** 仍然是国家公园和纪念碑的例子：

   

下面的代码将region定义为order变量，使用break和rbreak语句和after选项，summarize加总数值变量的和：

   

输出结果为：

   

 

### 4.21 为proc report输出增加统计量

简单的方法是在column语句中加入统计量的关键字，常用的有：

Max、min、mean、median、n、nmiss、p90、pctn、pctsum、std、sum

 

**给变量应用统计量** 给变量应用统计量，在变量和统计量之间插入逗号即可，统计量N不需要逗号。如：

COLUMN Age, MEDIAN N;

为多个变量应用多个统计量，需要括号，如下面代码要求一个变量age应用两个统计量min和max；两个变量height和weight应用一个统计量mean：

COLUMN Age, (MIN MAX); (Height Weight),MEAN;

**例子** 仍然是国家公园和纪念碑的数据：

   

下面的代码包括了两个proc report，都应用了统计量N和mean，但第一个定义type为group变量，第二个定义type为across变量。

   

输出结果为：

   




## 第五章 用ODS增强你的输出结果

### 5.1 ODS（Output Delivery System）的概念

过程步不会产生输出，它只会产生数据，然后把数据发送给ODS，以决定输出的样式等。所以，不要考虑是否使用ODS，而考虑怎么使用，是接受默认输出还是改变设置。

ODS就像一家商务飞机，游客乘坐car和bus赶来，在机场确认行李、安检、最终登机，飞往目的地。ODS中，数据就像游客，通过各种过程步而来，ODS处理每一个数据集并发送到目的地。实际上，不同的ODS类型就是目的地，当达到目的地时，数据的样式是由模板决定。模板是一个告诉ODS如何格式化您的数据的指令集。目的地和模板这两个概念的是你了解可以用ODS做什么的基础。

 

**目的地** 如果没有指定目的地，那么你的数据默认发往“列表listing”，这里有几种可选的目的地：

LISTING   标准SAS输出

Output     SAS输出数据集

Html      超文本标记语言

RTF       富文本格式

PRINTER  高分辨率的打印机输出（PS, PCL, and PD）

PS        附言

PCL       Printer Control Language 打印机控制语言

PDF       Portable Document Format

MARKUP  markup languages including XML

DOCUMENT output document

 

**风格和表模板** 模板描述ODS如何制定数据格式并呈现数据。最普通的两个模板类型和是表模板类型和风格模板类型。表模板类型制定基本的输出结构，而风格模板类型制定输出将如何呈现。ODS将过程产生的数据和表模板结合成输出对象，输出对象接着与风格模板结合，并发送到目的地，创建输出。

   

可以使用template过程创建自己的风格模板，但proc template过程晦涩难懂。幸运的是，有一个最简单和最快速的方法控制修改输出，即使用内置风格模板。可用proc template语句来访问内置模板：

 

​        PROC TEMPLATE;

​     LIST STYLES;

RUN;

一些内置模板如下：

   

注意RTF和PRINTER既是目的地名又是风格名。DEFAULT是HTML的默认风格，RTF是RTF输出的默认风格，PRINTER是PRINTER的默认风格。

Print、report、TABULATE三个过程中，可以使用style=option来直接控制输出特征，而不需要创建一个新的模板。

 

### 5.2 追踪选择过程的输出

​     当ODS接受来自过程步的数据时，它将数据与表模板结合。对应的表模板和数据就叫做输出对象。如果使用by语句，SAS会为每一个BY组产生一个输出对象。每一个输出对象都有名字，可以用ODS TRACE语句来查找，并用ODS SELECT语句来选择。

 

**ODS TRACE****语句** ODS TRACE语句告诉SAS打印出SAS日志中输出对象的信息。这里有两个ODS TRACE的语句，一个是打开trace，一个是关闭。使用方法实例如下：

   

注意关闭语句要在run后面，否则在程序运行之前就关闭了trace。

 

**例子** 有关于番茄种类的数据，包括每种番茄的名字、颜色、从播种到收获的天数、典型重量：

   

下面代码创建了一个名为giant的数据集，并使用ODS TRACE ON和ODS TRACE OFF语句来追踪proc means过程。

   

程序运行后，日志窗口中就会有如下的追踪（由于使用了BY语句，故按照BY的组来追踪）：

   

 

**ODS select****语句** 知道输出对象的名字之后，可以用ODS SELECT语句来选择需要的输出对象。基本形式为：

   

Output-object-list是名字、标签、一个或更多的输出对象的路径。

 

**例子** 下面代码对giant运行了proc means，并用ODS SELECT语句选择了第一个输出对象，mean：

   

输出结果为：

   

 

### 5.3 从过程输出中创建SAS数据集

​     有时需要把一个过程的结果弄到SAS数据集中，有的过程用output或out=实现。但用ODS，可以储存从过程输出的任何一部分。首先要使用ODS TRACE语句决定选择输出对象名。然后使用ODS OUTPUT语句将输出对象发送到OUTPUT目的地中。 

 

**ODS OUTPUT****语句** 基本形式为：

ODS OUTPUT output-object=new-data-set;

这个语句不属于数据步和过程步。ODS OUTPUT打开SAS数据集并等待正确的过程输出，数据集保持开放，直到过程步的结尾。因为ODS OUTPUT是立即执行的，它将应用于proc正在处理的数据，或者应用于下一个proc（如果目前没有proc）。为确保得到正确的输出，建议将ODS OUTPUT语句放在PROC语句之后，下一个PROC 、DATA或RUN语句之前。

 

**例子** 仍然是关于番茄的数据：

   

下面是引用与SAS日志，显示由proc tabulate产生的追踪（trace），tabulate产生一个叫做table的输出：

   

下面的代码读取数据、使用ODS OUTPUT语句来创建叫做TABOUT（来自TABLE输出对象）的SAS数据集，然后用proc print打印出新数据集。

   

有两部分输出结果，第一部分是标准tabular结果，有proc tabulate产生。下面是TABOUT数据集，由ODS OUTPUT语句产生，并有proc print打印。

   

 

### 5.4 使用ODS语句创建HTML输出

将输出发送到HTML目的地，将得到HTML格式的文件。这个文件也可以被读入spreadsheets，甚至被打印或导入到文字处理软件中（有些格式会发生变化）。总之，产生一个HTML文件只需两步语句——打开HTML文件、关闭。

**ODS****语句** 将输出发送到HTML目的地，使用ODS HTML语句，基本形式为：

ODS HTML BODY='body-filename.html' options;

Option是用来改变HTML的类型(contents,page,or frame)，

l  Contents=   contents文件是一个链接到主体文件的一个目录表，它将会列出输出的每个部分，点击表中某个条目，相关输出会出现。

l  Page=       page文件类似于contents文件，不同的是，contents通过标签列出输出的每个部分，而page文件通过页码列出。

l  Frame=      frame允许同时访问在不同区域、框架或浏览器窗口中，访问主体文件、contents文件和page文件。

l  Style=       这个选项允许指定一个风格模板，默认的模板名为default。

下面的语句告诉SAS发送一个输出给HTML目的地，储存一个名为AnnualReport.html的主体文件，并使用D3D风格。

ODS HTML BODY='AnnualReport.html' STYLE=D3D;

ODS 语句不属于数据步也不属于过程步，摆放它的好位置是proc过程步之前，这个过程步的输出正是你希望捕捉的。

关闭HTML文件的ODS语句为：

ODS HTML CLOSE;

将这个语句放在proc之后，接在 run语句之后。

输出中包括有些程序（如PROC means和PROC FREQ）过程的名称。您可以使用ODS NOPROCTITLE语句删除程序名称，该语句可放在data步之前。

ODS NOPROCTITLE;

 

**例子** 下面的数据是关于选择的鲸鱼或鲨鱼的平均长度（英尺）

   

下面的代码创建了两个输出，一个是来自means过程，一个来自print过程。并且有两个ODS语句，一个创建了四个HTML文件：body,contents,page,and frame，一个是关闭HTML文件。

   

输出结果如下：

   

 

### 5.5 使用ODS语句创建RTF输出

当你创建了富文本格式，可以将其发送到word中，并像word表格一样编辑修改。语句与HTML语句差不多，区别在于option：

**ODS****语句** ODS打开RTF文件的基本形式为：

ODS RTF FILE='filename.rtf' options;

不像HTML，RTF文件只有一种类型，一些option如下：

l  COLUMNS=n  要求一个柱状输出，n是第几列。

l  Bodytitle

l  Sasdate      这个选项告诉SAS当前的SAS会话开始运行时，使用日期和时间。

l  Style=       指定一个风格模板

下面的代码告诉SAS将输出发送到RTF目的地，储存一个名为AnnualReport.rtf的主体文件，并使用FANCYPRINTER风格。

ODS RTF FILE='AnnualReport.rtf' STYLE=FANCYPRINTER;

放置这个代码的较好位置也是在proc之前，而关闭语句也是放置在proc语句之后，接在run之后。

ODS RTF CLOSE;

 

**例子** 仍然是鲸鱼和鲨鱼平均重量的数据：

   

如下的代码从means和print中产生输出，程序中有两个ODS语句，一个打开RTF文件，一个关闭RTF文件。

   

Marine.RTF文件在word中的结果如下，每一部分的输出结果在不同页面中出现：

   

   

 

### 5.6 使用ODS创建printer输出

**ODS****语句** 打开printer目的地的ODS语句最基本形式为：

ODS PRINTER;

如果使用这个简单的语句，SAS将创建你先在系统需要的输出类型，并自动打印输出，而不是储存文件。可以用add=option来储存输出。类似RTF，只有一种PRINTER类型文件。创建指定的输出类型的基本形式如下面几种：

l  Default printer:      ODS PRINTER FILE='filename.extension'options;

l  PCL:              ODS PCL FILE='filename.pcl'options;

l  PDF:              ODS PDF FILE='filename.pdf'options;

l  PostScript:          ODS PS FILE='filename.ps'options;

目的地一些有效的选项如下

l  COLUMNS=n    要求一个柱状输出，n是第几列。

l  STYLE=         指定一个风格模板

下面的代码告诉SAS创建PostScript output，将结果存在AnnualReport.ps中，并使用FANCYPRINTER风格。

ODS PS FILE='AnnualReport.ps' STYLE=FANCYPRINTER;

放置它的位置也是在proc之前。关闭一个printer文件 ODS语句基本形式为;

ODS destination-name CLOSE;

destination-name可能是PRINTER,PCL,PDF,或者 PS，视开启语句中的目的地而定。放置在proc的run语句之后。

 

**例子** 仍然是鲸鱼和鲨鱼平均重量的数据：

   

如下的代码从means和print中产生输出，程序中有两个ODS语句，一个打开PDF文件，一个关闭PDF文件。

   

在Adobe Acrobat中的输出结果如下，每一部分的输出结果在不同页面中出现：

   

   

 

### 5.7 定制标题和注脚

通过在在title和footnote语句中插入一个简单的选项，可以改变注脚和标题的样式，title和footnote语句的基本形式为:

TITLE options 'text-string-1' options 'text-string-2'…options 'text-string-n';

FOOTNOTE options 'text-string-1' options 'text-string-2 '…options'text-string-n';

可以将一段文字分成不同的部分，每个部分应用不同的样式，可以选择的主要选项如下表：

l  COLOR=   为文本指定一种颜色

l  BCOLOR=  为背景指定一种颜色

l  HEIGHT=   为文本指定高度

l  JUSTIFY=  要求对齐

l  Font=      为文本指定字体

l  Bold       粗体

l  ITALIC    斜体

 

**颜色**  为一段文本不同部分指定不同的颜色

 TITLE COLOR=BLACK 'Black' COLOR=GRAY 'Gray' COLOR=LTGRAY 'Light Gray';

显示为：

   

SAS支持几百种颜色，但有的不能被web等识别，所以安全的颜色为: BLACK,BLUE,

BROWN,CHARCOAL,CREAM,CYAN,GOLD,GRAY,GREEN,LILAC,LIME,MAGENTA,MAROON,OLIVE,ORANGE,PINK,PURPLE,RED,ROSE,SALMON,STEEL,TAN,VIOLET,WHITE,and YELLOW.

 

**背景颜色** 下面是用十六进制码来指定背景颜色：

TITLE BCOLOR='#C0C0C0' 'This Title Has a Gray Background';

显示为：

   

 

**高度** 下面设置高度：

TITLE HEIGHT=12pt 'Small' HEIGHT=.25in 'Medium' HEIGHT=1cm 'Large';

单位分别为像素、英尺、厘米，显示为：

   

**对齐** 下面分别设置左对齐、居中、右对齐：

TITLE JUSTIFY=LEFT 'Left' JUSTIFY=CENTER 'vs.' JUSTIFY=RIGHT 'Right';

显示为：

   

**字体** 示例：

TITLE 'Default' FONT=Arial'Arial'

FONT='Times New Roman' 'Times New Roman' FONT=Courier'Courier';

显示为：

   

**加粗与斜体** 默认下，标题是加粗且斜体的。关闭粗体和斜体要用FONT=option，示例：

TITLE FONT=Courier'Courier'

BOLD'Bold'BOLD ITALIC'Bold and Italic';

显示为：

   

 

### 5.8 用style=option定制proc print输出

用ODS中的style=option可以改变输出的整体外观，但是如果要只改变头部，或者其中一列，要在print、report和tabulate过程中用style=option。

Proc print语句中使用Style=option的基本形式为：

PROC PRINT STYLE(location-list)={style-attribute=value};

location-list说明了表中的哪一部分将应用风格，style-attribute是要改变的风格属性，value是属性值。下面的代码将data部分的background属性设为pink：

PROC PRINT STYLE(DATA)={BACKGROUND=pink};

下面是可以指定改变风格的部分：

DATA           所有的数据单元

HEADER        列标题（变量名）

OBS            OBS列，或者ID列（如果使用ID语句）的数据

OBSHEADER    OBS列或ID列的标题

TOTAL         有sum语句产生的总和行的数据

GRANDTOTAL   

在print中放置style=改变的是全表。比如header会改变全表的头部，如果只想改变某列的头部，需要在VAR语句中使用style：

VAR variable-list/STYLE(location-list)={style-attribute=value};

仅有variable-list中的变量会被改变风格。想要不同的变量有不同的风格，可以使用复合VAR语句。

 

**例子** 下面是关于女子5000米滑冰奥运会金牌获得者的数据，变量依次为：奥运年年份、国家、时间、比赛记录（有WR的表示是世界记录）。

   

下面的代码用proc print创建了HTML文件，使用的是默认风格模板。

   

结果如下：

   

下面的代码使用了style来改变所有数据单元的背景：

   

结果如下：

   

下面的代码增加VAR语句，将record列的字体改为斜体和粗体：

   

结果为

   

 

### 5.9 用style=option定制proc report输出

与5.8类似，基本语句为：

PROC REPORT STYLE(location-list)={style-attribute=value};

比如，如果想创建一个名为MYSALES的报告，并将列标题设置为绿色：

PROC REPORT DATA=mysales STYLE(HEADER)={BACKGROUND=green};

如果只需要改变报告中的某一列属性，则需要define语句，下面的语句告诉SAS使用month作为组变量，将其数据和标题的背景改为蓝色：

DEFINE Month/GROUP STYLE(HEADER COLUMN)={BACKGROUND=blue};

还可以用break和rbreak语句为摘要（summary）指定一个风格。下面的语句告诉SAS，对于month的每一个值，为摘要使用红色背景，为总体报告摘要使用橙色背景：

   

 

**例子** 下面是不同的女子5000米滑冰奥运会金牌获得者的数据，变量依次为：姓名、国家、年份、金牌数。每一行包括了两条记录：

   

下面的代码使用proc report创建了一个HTML文件，使用默认模板：

   

结果为：

   

下面的代码使用default风格模板，但在proc report中增加style选项以改变所有数据的背景颜色，并居中：

   

结果为:

   

现在将style添加到define语句中，只改变name这一列：

   

结果为：

   

 

### 5.10 使用style=option定制proc tabulate输出

下面显示了proc tabulate语句中可以应用style的地方，并且影响的表区域：

   

**Proc tabulate****语句** 如果想要来自数据集MYSALES的表的所有数据单元都变成黄色背景：

PROC TABULATE DATA=mysales STYLE={BACKGROUND=yellow};

**Table****语句** 下面的代码使得all列都有红色背景：

TABLE City,Month ALL*{STYLE={BACKGROUND=red}};

CLASSLEV,VAR,和CLASS statements CLASSLEV,VAR,和CLASS语句都是在斜杠/后面应用style语句。注意的是，classlev语句中的变量必须出现在class语句中，下面的代码是将月份month变量的每个值（Jan,Feb,Mar…）的前背景应用为绿色，使用classlev语句如下：

CLASSLEV Month/STYLE={FOREGROUND=green};

 

**例子** 下面是一份关于奥运会男子滑冰的数据，OR是奥运会纪录，WR是世界记录，NONE既不是奥运会记录，也不是世界记录。注意一行有四个观测值：

   

Tabulate过程建立了一个表，以年份作为行，记录作为列。年份和N的顶部都通过设置为null将其消除。ODS语句创建了HTML文件，使用默认模板：

   

结果如下：

   

现在将数据单元的数据居中，并将背景设置为白色：

   

显示结果为：

   

 

### 5.11 为你的输出增加交通信号灯

交通信号灯是基于单元格的值，来控制格的风格。它可以使得重要值变得醒目，它可以在print、report、tabulate中被使用。

使用之前需要做两件事：首先创建用户定义的格式。其次，在style=中将风格属性等于你定义的格式，比如，你创建了一个格式：

   

在print的VAR语句中，将属性值等于这个格式：

VAR Balance/STYLE={FOREGROUND=posneg.};

现在所有balance变量风格都发生变化。

例子 下面的数据是2002年冬奥会中，男子5000米滑冰前五名的数据，包括姓名、国家、成绩（用时）

   

下面代码读取打印数据，生成HTML文件，使用default模板：

   

结果为：

   

想要用信号灯显示每个成绩与世界记录的378.72、奥运记录382.20比较的结果，先创建用户自定义的格式REC，快于世界记录的用红色显示，橙色显示快于奥运记录的，其他颜色设置白色。接着在print语句中增加var语句，使用style=option为时间变量分配风格。最后，将定义的格式REC赋给background。

   

结果如下：

   

 

### 5.12 选择风格属性

​            

 

## 第六章 修改组合SAS数据集

### 6.1 使用SET语句修改数据集

SET语句可以增加新变量、创建子集、修改数据集。SET语句是一次一个变量地，将一个数据集放入数据步中予以分析。基本形式为：

​     DATA new-data-set;

SET data-set;

Data语句指定了新数据集名，set指定要读取的老数据集名。如果不想创建新的，则也可以在data中指定老数据集。

下面的代码创建了一个Friday的新数据集将sales数据集中的day属于Friday的观测值复制，并创建了新变量total：

   

 

**例子** 有一份关于火车运汽车的数据，汽车主为了在高峰期节省时间，或者为了节省汽油，选择让火车运汽车的方法，变量为一天中发车的时间、火车上的汽车数、火车中的人数：

   

数据被读入一个永久数据集trains中，储存在MYSASLIB目录文件夹下：

   

由于每辆车的最大乘客数为6人，现在想知道一列火车上，平均每辆汽车的乘客数是多少，可以在数据中插入一列，但这不在原始数据中计算，而是在一个新数据集中计算：

   

结果如下：

   

 

### 6.2 使用set语句堆叠数据

​     运用set语句可以把一个数据集堆在另一个数据集上，适用于两个变量相同的两个数据集。

基本形式为：

DATA new-data-set;

​     SET data-set-1 data-set-n;

首先指定一个新的数据集，然后列出需要合并的旧数据集。

如果一个数据集包含了另一个数据集没有的变量，那么合并后，该变量下将会出现缺失值。

 

**例子** 有如下两份南北数据，北方数据比南方多了一行变量（最后一行），其他变量均相同：

   

下面有三段代码，前两段将南方和北方的数据各输入数据集，并打印。第三段使用SET语句将南北方数据合并，并创建了新变量，AmountPaid：

   

   

输出结果如下：

   

 

### 6.3 使用SET语句插入数据集

​     前面的堆叠数据，可能把数据顺序打乱，当然可以再用proc sort再将数据排序。但这可能效率低下。在set语句中使用by语句可以高效率的将数据按顺序合并，基本形式为;

DATA new-data-set;

SET data-set-1 data-set-n;

BY variable-list;

BY语句中，可以指定一个或多个变量，让SAS进行排序。

注意，在合并几个数据之前，每个数据都要用BY进行排序，如果没有，则要用proc sort完成。

 

**例子** 仍然是刚才的例子：

   

注意南方的数据已经按照pass number（第二个变量）进行了排序，北方的没有。下面还是三段代码，第一段对南方的数据输入，打印。第二段对北方的数据输入、排序、打印。第三段进行合并，并创建新变量INTERLEAVE。

​      

下面是输出结果：

   

 

### 6.4 一对一匹配合并数据集

​     合并数据集，首先，如果数据没有排序，使用sort过程按照匹配变量排序。之后，在data语句中对新SAS数据集命名，再使用merge语句列出要合并的数据集名。使用BY语句说明共同变量。

  DATA new-data-set;

​               MERGE data-set-1 data-set-2;

   BY variable-list;

注意，如果两个数据集有重叠的变量——除了BY变量，那么第二个数据集中的此变量会覆盖第一个数据集中的。

 

**例子** 有一个巧克力店记录了每天所卖巧克力的类型以及数量，第一个文件sales data记录了所卖的巧克力代码和数量，第二个记录了巧克力代码、所代表的类型、描述。

   

下面有三段代码，前两段读取sales数据，description数据。后者已经对codenum变量进行排序，前者需要用proc sort进行排序。否则会出现错误的信息：ERROR:BY variables are

not properly sorted。

   

结果如下：

   

注意M315的销售记录缺失，因为sales data中 没有关于其的记录。

### 6.5 一对多匹配合并数据

​     一对多合并是指一个数据集中的一个观测值可以与另一个数据集中的多个观测值匹配。

基本形式与一对一一样：

DATA new-data-set;

MERGE data-set-1 data-set-2;

BY variable-list;

注意数据集的顺序，一对多的一要放在前面。在进行合并之前，仍然要对两个数据集按照匹配变量进行排序。其他注意与6.4差不多。

 

**例子** 有一份关于鞋子打折的数据，其中训练鞋、跑步鞋、走路鞋的折扣各不同。第一份数据是关于鞋子的风格、类型、价格。第二份数据是关于每个类型鞋子的折扣：

   

下面的代码用多对一合并了两个数据：

   

结果如下：

   

 

### 6.6合并统计量与原始数据

​     当你想比较每一个观测值和一组变量的均值时，可以先使用proc means计算统计量，并保存输出文件，再与原始文件合并。

 

 

 

**例子** 有一份关于鞋子销量的数据，变量为鞋子风格、类型、销量。现在想列出每种类型鞋子里，各风格的销售量所占的百分比：

   

代码：

   

描述统计量的结果summarydata如下：

   

合并后的数据如下：

   

 

### 6.7 合并total和原始数据

​     可以通过means过程创建一个包含总计（不是分组总计）的数据集。但不能直接与原始数据合并，因为没有匹配变量。幸运的是，可以用两个set语句：

 

 

DATA new-data-set;

​               IF _N_=1 THEN SET summary-data-set;

SET original-data-set;

原始数据包含了不止一个观测值，而summary数据集只有一个观测值。只在数据步的第一次迭代中，SAS读取了summary数据集，之后为新数据的所有变量记住这个变量值。它的工作原理在于SET语句是自动记住的。往常之中，记住的变量会被下一个观测值改写，但这里变量只在第一次迭代的时候读取，并为所有观测值记住，这一技术适用于没有匹配变量的情况下，将一个单个观测值合并到多个观测值中。（注意两个set语句的其他使用）

 

**例子** 与上节同样的例子，现在想看每种类型的鞋子销量占总销量的百分比：

   

代码为：

   

输出结果为：

   

 

### 6.8 用交易数据（transactions）更新主数据集（master）

​     update语句用来更新大量新数据信息。

与merge语句一样，都是按照匹配变量来合并数据，不同点在于：

l  匹配变量的变量值有唯一性。

l  交易数据的缺失值不会改写主数据中存在的值。

基本形式为:

DATA master-data-set;

​                          UPDATE master-data-set transaction-data-set;

 BY variable-list;

只能指定两个数据集，一个是主数据集一个是交易数据，都需要按照匹配变量排序。且BY变量必须具有唯一性。

 

**例子** 一家医院有一份关于病人的主数据。变量依次为病人账户号码、名字、地址、出生日期、性别、保险代码、信息最后被更新的时间。

   

当有新病人，或其他病人再进医院时，信息会被更新，比如，第一个病人的保险代码被更换了、最后一个病人的缺失数据被填补上、有新病人加入：

   

下面的代码将这个数据放入一个名为patientmaster的永久数据集中，目录为C盘下的MySASLib：

   

下面的代码读取交易数据并排序，使用updata语句将交易数据更新到主数据中。

   

输出结果如下：

   

注意FORTMAT定义格式：多个变量 格式名。

### 6.9 使用SAS数据集选项

前面已经见过很多选项，SAS语言主要有三种选项：系统选项、语句选项、数据集选项。系统选项有全局影响力，而数据集选项的影响力有限。

系统选项在SAS会话或工作期间都有效，包括center选项，它告诉SAS，center所有的输出。以及LINESIZE=option，设置输出中每一行的最大长度。

语句选项出现在某个语句中，影响某一个数据步或者过程步。

数据集选项影响的只是SAS如何读取和写入一个单个的数据集，可以在数据步（DATA,SET,MERGE,or UPDATE 语句）和过程步（conjuction with a DATA=statement option）中使用。用法是，接在数据集名之后，用括号括起来。有些最常见的选项：

KEEP=variable-list          告诉SAS保留哪个变量

DROP=variable-list         告诉SAS丢弃哪个变量

RENAME=(oldvar=newvar)   重命名某个变量

 FIRSTOBS=n              从观测值n开始读取变量

OBS=n                    到观测值n停止读取

IN=new-var-name

 

**选择并重命名变量** 下面是关于KEEP=,DROP=，和RENAME=的数据集选项的例子

   

KEEP=,DROP=，和RENAME=的作用与keep、drop、rename很相似。区别在于，后者适用于数据步中的所有变量，而前者仅使用与语句前面的那个数据集。而且，后者仅可以在数据步中使用，而前者除了数据步和过程步，还可以在输入和输出数据集中使用。

 

**用****observation number****选择观测值** 可以使用FIRSTOBS=和obs=来选择读取哪些观测值

   

这也类似于同名的语句选项和同名的系统选项，语句选项只适用于infile语句。数据集选项是用于数据步和过程步中存在的数据集，而系统选项适用于所有的文件和数据集。如果同时使用同样的系统选项和数据集选项，那么后者将覆盖前者。

 

**追踪观测值** 这里提到的选项都是针对现有的变量，而in=option则自己创建一个新变量。这个新变量是临时的，并且有自己在选项中指定。下面的例子，SAS创建了两个临时变量：InAnimals和InHabitat:：

   

该变量只存在于现在的过程步中。

 

### 6.10 用in=option追踪并选择观测值

​     如果合并了两个数据集，可以用in=option来追踪原始数据集对应新数据集中的哪个观测值。

In=data选项可以被用在数据步中的任何地方——SET,MERGE,或者UPDATE——但大部分用在merge语句上，接在要追踪的数据集后面。

下面的数据步创建了一个both数据集，合并两个数据集，state和ounty。并用in=Option创建了两个变量InState和 InCounty：

 

 

   

创建的变量是临时的，只存在于数据步期间。SAS给新变量赋值为0和1。比如county数据集没有关于Louisiana的数据（Louisiana只有parishes，没有counties），因此上例中，两个数据集都含有一个关于Louisiana的观测值，InState变量下的这个观测值为1，InCounty的为0。

这个被用在IF或IF-THEN语句中最多：

Subsetting IF:    IF InState=1;

IF InCounty=0;

IF InState=1 AND InCounty=1;

IF-THEN:       IF InCounty=1 THEN Origin=1;

IF InState=1 THEN State='Yes';

 

**例子** 一家运动品厂商有两份数据，一个包括所有客户的数据，一份包括了第三季度订单的数据。现在想要了解哪些客户在第三季度没有任何订单，即可以用in=option选项。客户数据包括客户编号、姓名、地址；订单数据包括客户编号、总价格：

   

发现没有订单客户的代码如下，数据步中创建了新变量recent，如果出现在客户数据中的观测值没有出现在order中，则recent赋为0，否则赋为1。

 

   

结果如下：

   

 

### 6.11 使用output语句写多维数据集

​     有时候想在一个数据步中创建多个数据，可以在DATA语句后面多接几个数据集名即可，如下语句告诉SAS创建三个数据集：LIONS、

TIGERS、和 BEARS:

DATA lions tigers bears;

这样仅仅是创建了三个一样的数据集，如果想创建不同的，可以用output语句

 

每一个数据步的结尾都有一个暗含的output语句，它告诉SAS在处理下一个观测值之前，将当前的观测值写入输出数据集中。可以用自己的output语句来推翻这个暗含的output语句，基本形式为：

OUTPUT data-set-name;

如果遗漏了数据集名，则将被写入数据步中所有的数据集中去，output可以单独使用，也可以使用在IF-THEN或DO-loop过程中：

IF family='Ursidae' THEN OUTPUT bears;

**例子** 有一份关于动物园给动物喂食的数据，变量为动物类型、生物学分类、居住区域、喂食是否在早上/下午/两者：

   

下面的代码创建了两个列表，一个是早上喂食，一个是下午喂食：

   

日志：

   

输出报告为：

   

 

 

### 6.12 使用output将一个观测值变成多个观测值

​     SAS通常在数据步结尾将一个观测值写入数据中，但可以写入多个观测值，在DO loop中或单独使用output语句。Output语句控制何时将观测值写入SAS数据集中。如果数据集中没有OUTPUT语句，则暗含在结尾，放置了output之后，则结尾的就不再暗含存在。当SAS出现OUTPUT语句时，则写入一个观测值。

 

 

 

**例子** 下面的代码阐述如何在DO LOOD语句中使用output语句来产生一个数据集。

   

这个代码没有INPUT或SET语句，故整个数据步中只有一次迭代——但包括了DO LOOP中的六次循环。由于OUTPUT语句在DO LOOP循环中，因此每次循环都会创建一个观测值：

   

如果没有OUTPUT语句，SAS仅会写入一个观测值，因为结尾处暗含的OUTPUT语句。

 

**例子** 有一份关于三个电影院的门票销售数据，记录了月份、电影院名称、门票销售额：

   

现在需要将电影院名作为一个变量、销售额作为一个变量、月份重复三次。

下面的代码使用三次input语句读取同一个原始文件。第一个读取变量month、location和tickets，并用@停留住数据行，接着用OUTPUT语句输出这个观测值。下一个INPUT读取这行后面的名、销售额，并再停留住行。接着读取，但释放行，进入下一个迭代。这个代码用output语句使每一行创建了三个观测值：

   

结果为:

   

 

### 6.13 使用proc transpose将观测值转变为变量

​     transpose过程可以转置数据集，将观测值转变为变量或将变量转变为观测值。部分情况下，将观测值转变为变量，可以使用下面代码：

 

 

PROC TRANSPOSE DATA=old-data-set OUT=new-data-set;

BY variable-list;

ID variable;

VAR variable-list;

 

**BY****语句** 可以使用BY语句，如果您有任何分组变量要保持作为变量。这些变量包括在已转置的数据集内，但它们本身并不转置。转置的数据集每个转置的变量在BY水平下都有一个观测。例如，在图中所示的变量X是BY变量。该数据集必须在转置前按这些变量排序。

 

**ID****语句** ID语句命名变量，这些变量值将变成新的变量名，ID变量在一个数据集中只能发生一次，如果有BY语句，那么在一个by-group中，变量值必须是唯一的。如果ID变量是数值型变量，新的变量名必须有一个下划线作为前缀（_1 or_2,for example）。如果不适用ID语句，新变量将命名为COL1，COL2等。

 

**VAR****语句** VAR语句命名变量，这个变量的变量值是要转置的。

 

**例子** 有一份关于儿童棒球联盟选手的数据，包括队名、选手编号、数据类型(salary or batting average)、以及entry：

   

现在想考察平均打击数与salary之间的关系，首先要将salary和平均打击数变量变量。下面的代码读取数据、按照队伍、选手排序数据，再转置数据：

   

在proc transpose这步中，BY变量是team和player。ID变量是type，它的值salary和batavg将是新变量名，将要转置的变量entry在VAR语句中指定。注意原来是变量名的entry，现在作为_name_变量下面的变量值。结果为：

   

 

### 6.14 使用SAS自动变量

SAS有一些自动变量，这些变量看不到，是临时的并不会被储存。但在数据步中，可以任意使用。

 

**_N_****和****_ERROR_** _N_记录了SAS在数据步中循环的次数，它不一定等于观测数。因为诸如IF语句就可以使迭代次数与观测数不一致。如果一个观测值的数据出现错误，_ERROR_会被赋值为1，否则赋值为0。错误数据包括无效数据（数值型格式变量却赋为字符串值），转换错误（0作为除数），函数中不合法的自变量（log（0））。

 

FIRST.variable**和**The Little SAS Book 学习笔记

目录

[The Little SAS Book 学习笔记... 1](#_Toc368324236)

[第一章 SAS软件入门... 5](#_Toc368324237)

[1.1 SAS语言... 5](#_Toc368324238)

[1.2 SAS数据集... 6](#_Toc368324239)

[1.3 SAS程序的两个过程... 7](#_Toc368324240)

[1.4 数据步的内置循环... 8](#_Toc368324241)

[1.5 选择一个提交程序的方式... 9](#_Toc368324242)

[1.6 SAS视窗环境中的视窗和命令... 10](#_Toc368324243)

[1.7 在SAS视窗环境中提交程序... 11](#_Toc368324244)

[1.8 阅读SAS日志... 13](#_Toc368324245)

[1.9 输出窗口中浏览结果... 15](#_Toc368324246)

[1.10 创建HTML输出... 17](#_Toc368324247)

[1.11 SAS数据的逻辑库... 19](#_Toc368324248)

[1.12 用SAS资源管理器访问SAS数据集... 21](#_Toc368324249)

[1.13 使用SAS系统选项... 23](#_Toc368324250)

[第二章 将你的数据放入SAS. 25](#_Toc368324251)

[2.1 将你的数据放入SAS的方法... 25](#_Toc368324252)

[2.2 用View table窗口输入数据... 25](#_Toc368324253)

[2.3 用导入向导（Import Wizard）读取文件... 27](#_Toc368324254)

[2.4 告诉SAS你的原始数据在哪... 29](#_Toc368324255)

[2.5 list input读取空格分开的原始数据... 31](#_Toc368324256)

[2.6 column input读取按固定列排列的原始数据... 32](#_Toc368324257)

[2.7 informats读取非标准格式的原始数据... 33](#_Toc368324258)

[2.8 可选择变量形式... 34](#_Toc368324259)

[2.9 混合读取方式... 36](#_Toc368324260)

[2.10 读取凌乱的原始数据... 38](#_Toc368324261)

[2.11 跨行观测值的读取方式... 39](#_Toc368324262)

[2.12 一行有多个观测值的原始文件读取... 40](#_Toc368324263)

[2.13 读取原始数据的部分观测值... 41](#_Toc368324264)

[2.14 用infile语句中的选项控制输入... 42](#_Toc368324265)

[2.15 用数据步读取分隔符文件（delimited files）... 44](#_Toc368324266)

[2.16 用导入过程（IMPORT procedure）读取分隔符文件... 45](#_Toc368324267)

[2.17 用导入过程（IMPORT procedure）读取PC文件... 46](#_Toc368324268)

[2.18 用DDE读取PC文件... 48](#_Toc368324269)

[2.19 临时和永久数据集... 49](#_Toc368324270)

[2.20 用LIBNAME语句使用永久数据集... 50](#_Toc368324271)

[2.21 通过直接指代使用永久数据集... 51](#_Toc368324272)

[2.22 列出SAS数据集目录... 52](#_Toc368324273)

[第三章 开发你的数据... 54](#_Toc368324274)

[3.1 创建并重新定义变量... 54](#_Toc368324275)

[3.2 使用SAS函数... 55](#_Toc368324276)

[3.3 选出的SAS字符函数... 56](#_Toc368324277)

[3.4 选出的SAS数值函数... 56](#_Toc368324278)

[3.5 使用IF-THEN语句... 56](#_Toc368324279)

[3.6 用IF-THEN语句将观测值分组... 57](#_Toc368324280)

[3.7 构造子集... 58](#_Toc368324281)

[3.8 处理SAS的日期数据... 59](#_Toc368324282)

[3.9 可选择的Date Informats、Functions和Formats. 60](#_Toc368324283)

[3.11 使用retain和sum语句... 61](#_Toc368324284)

[3.12 用数组简化程序... 62](#_Toc368324285)

[3.11 列出变量名的快捷方式... 63](#_Toc368324286)

[第四章 排序、打印并描述你的数据... 65](#_Toc368324287)

[4.1 使用SAS过程步... 65](#_Toc368324288)

[4.2 用where语句在过程中构造子集... 66](#_Toc368324289)

[4.3 用proc sort为数据排序... 67](#_Toc368324290)

[4.4 用proc print打印你的数据... 68](#_Toc368324291)

[4.5 用formats改变打印外观... 69](#_Toc368324292)

[4.6 可供选择的formats. 71](#_Toc368324293)

[4.7 使用proc format创建自己的格式... 72](#_Toc368324294)

[4.8 定制一个简单的报告... 74](#_Toc368324295)

[4.9 使用proc means描述数据... 75](#_Toc368324296)

[4.10 将描述性统计写入SAS数据集中... 76](#_Toc368324297)

[4.11 用proc freq为数据计数... 77](#_Toc368324298)

[4.12 用proc tabulate产生一个表格报告... 79](#_Toc368324299)

[4.13 为proc tabulate输出增加统计量... 80](#_Toc368324300)

[4.14 提升proc tabulate的输出外观... 81](#_Toc368324301)

[4.15 改变proc tabulate输出的表头... 83](#_Toc368324302)

[4.16 为proc tabulate输出的数据方格指定多种格式... 84](#_Toc368324303)

[4.17 用proc report产生一个简单的输出... 85](#_Toc368324304)

[4.18 在proc report中使用define语句... 87](#_Toc368324305)

[4.19 用proc report创建简易报告... 88](#_Toc368324306)

[4.20 给proc report输出增加summary break.. 90](#_Toc368324307)

[4.21 为proc report输出增加统计量... 91](#_Toc368324308)

[第五章 用ODS增强你的输出结果... 93](#_Toc368324309)

[5.1 ODS（Output Delivery System）的概念... 93](#_Toc368324310)

[5.2 追踪选择过程的输出... 94](#_Toc368324311)

[5.3 从过程输出中创建SAS数据集... 96](#_Toc368324312)

[5.4 使用ODS语句创建HTML输出... 97](#_Toc368324313)

[5.5 使用ODS语句创建RTF输出... 99](#_Toc368324314)

[5.6 使用ODS创建printer输出... 101](#_Toc368324315)

[5.7 定制标题和注脚... 102](#_Toc368324316)

[5.8 用style=option定制proc print输出... 103](#_Toc368324317)

[5.9 用style=option定制proc report输出... 105](#_Toc368324318)

[5.10 使用style=option定制proc tabulate输出... 108](#_Toc368324319)

[5.11 为你的输出增加交通信号灯... 110](#_Toc368324320)

[5.12 选择风格属性... 112](#_Toc368324321)

[第六章 修改组合SAS数据集... 114](#_Toc368324322)

[6.1 使用SET语句修改数据集... 114](#_Toc368324323)

[6.2 使用set语句堆叠数据... 115](#_Toc368324324)

[6.3 使用SET语句插入数据集... 116](#_Toc368324325)

[6.4 一对一匹配合并数据集... 118](#_Toc368324326)

[6.5 一对多匹配合并数据... 120](#_Toc368324327)

[6.6合并统计量与原始数据... 121](#_Toc368324328)

[6.7 合并total和原始数据... 122](#_Toc368324329)

[6.8 用交易数据（transactions）更新主数据集（master）... 123](#_Toc368324330)

[6.9 使用SAS数据集选项... 125](#_Toc368324331)

[6.10 用in=option追踪并选择观测值... 126](#_Toc368324332)

[6.11 使用output语句写多维数据集... 127](#_Toc368324333)

[6.12 使用output将一个观测值变成多个观测值... 129](#_Toc368324334)

[6.13 使用proc transpose将观测值转变为变量... 130](#_Toc368324335)

[6.14 使用SAS自动变量... 132](#_Toc368324336)

[第七章 使用SAS宏功能灵活写代码... 134](#_Toc368324337)

[7.1 宏概述... 134](#_Toc368324338)

[7.2 用宏变量提交文本... 134](#_Toc368324339)

[7.3 用宏创建一个模块化的代码... 135](#_Toc368324340)

[7.4 给宏增加参数... 136](#_Toc368324341)

[7.5 使用条件逻辑写宏代码... 138](#_Toc368324342)

[7.6 用call symput编写数据驱动的程序... 140](#_Toc368324343)

[7.7 排除宏错误的bug. 141](#_Toc368324344)

[第八章 使用基本统计过程... 143](#_Toc368324345)

[8.1 用PROC UNIVARIATE检验数据分布... 143](#_Toc368324346)

[8.2 用proc means产生统计量... 144](#_Toc368324347)

[8.3 用proc freq检验分类数据... 145](#_Toc368324348)

[8.4 用proc corr检测相关性... 147](#_Toc368324349)

[8.5 使用proc reg做简单的回归分析... 149](#_Toc368324350)

[8.6 读取proc reg的输出... 149](#_Toc368324351)

[8.7 使用proc anova做单因素方差分析... 151](#_Toc368324352)

[8.8 读取proc anova的输出... 152](#_Toc368324353)

[8.9 统计分析的图形界面... 153](#_Toc368324354)

[第九章 导出数据... 154](#_Toc368324355)

[9.1 导出数据的方法... 154](#_Toc368324356)

[9.2 用导出向导写文件... 154](#_Toc368324357)

[9.3 用EXPORT Procedure写分隔的文件... 157](#_Toc368324358)

[9.4 用EXPORT Procedure写PC文件... 158](#_Toc368324359)

[9.5 用数据步写原始文件... 160](#_Toc368324360)

[9.6 用ODS写分隔和HTML文件... 161](#_Toc368324361)

[9.7 和其他类型电脑分享SAS数据集... 163](#_Toc368324362)






## 第一章 SAS软件入门

### 1.1 SAS语言

许多软件要么是菜单驱动，要么是命令驱动（输入命令——看结果）。SAS两者都不是，在SAS中，你用一个叫做SAS程序的一系列指令语句，这些程序可以表达出你想做的事情，并用SAS语言写下来。SAS有菜单驱动栏，比如SAS企业向导模块，它使SAS看起来像一个点击的软件，但这些模块仍然使用SAS语言为你写程序。如果你试图用SAS写下你自己的程序，那就要具备一定的灵活性。

 

**SAS** **程序** 一个SAS程序就是一个按顺序执行的语句序列，一个语句给SAS下达信息和指令，且必须要正确的安放。一个常用来与SAS程序做类比的例子是去银行取款，你进入银行、排队、轮到你，那么你会对柜台谁你想做的事，叙述语句可能会是这样：

I would like to make a withdrawal.

My account number is 0937.

I would like$200.

Give me five 20s and two 50s.

注意第一句话说了你想做的事情，之后把相关信息传递给柜台并帮你完成要求。这里信息传递的顺序不重要，重要的是在你的叙述中，首先要说明你要做什么。你不能先说：“Give me five 20s and two 50s.”这会使柜台小姐一头雾水。此外，你必须确保后面的语句都围绕第一句展开。

 

**SAS****语句** 像任何语言一样，SAS语句的编写也需要遵守一些语法规则。幸运的是，相比英语来说，SAS语句的规则不仅少，而且简单。

最重要的规则是：

**每一个****SAS****语句都由一个分号结尾**

听起来很简单，但即使最富有经验的SAS程序员也会偶然忘记分号。如果你能记住这个规则，再来看看另外两个规则吧。

 

**SAS****程序布局** 让每一条语句看起来整洁、用缩进来表现语句的各个部分，这是很有用的，但不是必须的：

l  SAS语句不区分大小写。

l  一条语句可以持续到第二行（只要不把一个单词分开）。

l  几条语句可以用一行。

l  可以在任何一列中开始一条语句

 

**注释** 可以在你的程序中插入一些注释，让它更容易明白。即使你插入一些你喜欢的食物品名也不会对程序有所影响，因为SAS不会读取注释。但不要忘记注释是为了让某人更轻松地学习你的程序，并明白你为什么这么做。

*Read animals’ weights from file;

DATA animals;

INFILE ’c:\MyRawData\Zoo.dat’;

INPUT Lions Tigers;

PROC PRINT DATA=animals; /*Print the results*/

RUN;

有两种注释方法，一种是‘*’和‘；’一起使用；一种是用/* */表示，由于某些操作环境解释第一列中的斜线星号（/ *）作为工作结束的标志，使用这种风格的注释时要小心不要把它放在第一列。出于这个原因，我们选择了星号分号的风格为这本书的注释。

**错误** SAS程序通常将执行的错误标注为醒目的红色字母，你可能忘了分号，拼错了字母，按错了键盘，一个小错误会使得整个程序无法运行。当你看到红色部分多余黑色部分的时候，不要灰心。

 

### 1.2 SAS数据集

在你进行分析、撰写报告，对你的数据进行任何处理之前，SAS必须能够处理你的数据，你的数据必须是一种叫SAS数据集的特殊形式。因为SAS非常灵活，能够读取任何形式的数据，所以将你的数据变成SAS数据集是一件非常简单的事。

 

**变量和观测值** 在传统的SAS术语中，数据包括变量和观测值。采用相关的数据库的术语，SAS数据集也被叫做表、观测值也被叫做行、变量也被叫做列，你可以看到下面这个包含一些数据的表。

​                                                  

 

**数据类型** 未加工的数据有多种形式，但SAS将其简单化。在SAS中只有两种数据类型——数值型和字符型。数值型完全是数据，可以被加减乘除、可以是正负且是小数。字符变量是除数值之外的类型，可以是数值、字母、和一些特殊的字符（￥、！），最多可以占用32767个字节长度。

如果一个变量既包括数字又包括字符，那么它一定是字符变量。如果只包括数字，可能是字符变量也可能是数值变量。在上面这个表中，姓名是字符变量，身高和体重是数值变量，ID，既可能是数值有可能是字符，依据你的选择。

 

**缺失**值 数据有时会有些不完美，某些变量的个别观测值会缺失。字符变量的缺失值用空格表示，数值变量的缺失值用句号（.）表示。上表中，体重的第五个观测值缺失，用.表示。姓名的第六个观测值缺失，用空格表示。

 

**SAS****数据集的大小** 在SAS 9.1之前（prior to SAS 9.1），SAS数据集可以包含32767个变量，从SAS 9.1开始（beginning with SAS 9.1），SAS可包含的最多变量数由你的电脑可用资源决定（内存，CUP？）。但是超过32767个变量的SAS数据集不能用在早期的SAS版本上。

 

**SAS****命名规则** 为你的变量和数据集命名，使它们容易被辨别。A,B,C这样的名字可能看起来很完美，写程序的时候也很方便，但当你6个月后再使用这些数据时，你会发现name，height，weight这样的名字更有用。为变量和数据集命名时要遵守如下规则：

l  名字的长度要小于等于32个字节。（一个字母1个字节，一个汉字2个字节）

l  以字母或下划线开头。

l  可以包含字母、数字、或者是下划线，不能是%$!*&#@。

l  可以是小写或大写字母，且不区分大小写。

 

**SAS****数据集储存的文件** SAS数据集包含了一些类似名称、创建日期、创建用的SAS版本等信息。SAS也储存了每个变量的信息，包括名称、类型、长度、数据集中的位置。这些信息叫做数据集的描述部分，它使得数据集可以自我编制（self-documenting）。

 

### 1.3 SAS程序的两个过程

​     SAS程序有两个基本模块：数据步和过程步。一个典型的SAS程序，由数据步创建SAS数据集开始，再由过程步分析数据。这里有一个例子：数据步中将米转化成千米，过程步中输出结果

   

数据步和过程步由语句组成（废话），一个过程少至1条语句、多至几百条。新手常犯的错误是将两种过程语句用混，只要记住数据步负责读取、修改数据，过程步负责分析数据、输出报告和效用函数，就不会犯错。

数据步由DATA语句开始：data+数据名。上例中数据步处理了名为distance的数据。为了读取外部数据、未加工的数据，数据步提供了DO LOOPS,IF-THEN/ELSE，以及一些数值和字符函数。数据步也可以按照你想要的方式合并数据集，包括联接（concatenation）和合并（match-merge）。

过程步由proc语句开始：proc+过程名（print、sort、means…），SAS过程步可以处理从数据储存、输出到方差分析、3D图表的一切操作。

当程序遭遇DATA\PROC等标志着新程序开始的语句时，程序结束。如果运行的是批处理，则run代表语句的结束。Run告诉SAS去执行所有之前的程序行，全局变量不是DATA或PROC过程的部分。上图的那个程序，当proc出现时，代表data过程结束。

典型的程序是以DATA语句开头，输入或修改数据，然后将数据传递给PROC语句。但并不一定非要用这种模式来混合data和proc语句，你可以用任何顺序来排列data和proc两者的顺序，一个程序甚至可以仅有data语句或proc语句。

下表是data语句和proc语句的一些基本不同点:

   

这只是一个简化表，SAS软件非常灵活，所以data语句和proc语句之间真正的区别也是很模糊的。记住，这个表并不是说proc语句永远不能创建SAS数据集，或者DATA语句永远不能够分析生成报告。

 

### 1.4 数据步的内置循环

Data步读取并修改数据，让你以灵活的方式控制处理数据。Data步也有一个潜在的、内置的循环语句。你不用告诉SAS去执行这个循环，SAS会自动执行。

**数据步按照一行一行、一个观测值一个观测值的顺序执行**

这句话的表意并不明确，许多新手直到成了老手都没明白这句话的含义。

数据步“一行一行的执行”，这句话很好理解。但很多新手还是容易在这里出错，例如在没有创建一个变量之前就使用它，如果Z变量是X、Y两个变量组合的新变量，那么必须确定创建Z变量的语句在创建X、Y变量语句之后。

而“一个观测值一个观测值的执行”就不是那么容易理解。这意味着SAS先读取一个观测值，然后对这个观测值进行数据步的所有语句（当然也是一行一行的），然后再读取第二个观测值执行。每次执行SAS只有一个观测值。

我们将SAS执行的图景放慢：SAS从你的数据集中读取一个观测值。SAS对你的这个观测值执行数据步，如果数据步一直运行到结束而没有错误，SAS会把当前的观测值写入一个新的、输出数据集中，并返回到数据步开头，读取第二个观测值进行执行。当最后一个观测值都被写入输出数据集中之后，SAS结束数据步，进入下一个步。

   

有一个类比，数据步就像是一个投票程序。当你来到投票的地点，你会站在别人后面进行排队，排到你时，你会被问到：你叫什么名字，住在哪里。当你回答之后，你可以投票。在这里，排队的人就像是观测值，投票的程序就像是数据步。一次只能让一个人投票，每个人都相互独立。并且投票的程序是一步一步来的，你不能没说明自己的姓名和住址之前就投票。

 

### 1.5 选择一个提交程序的方式

目前为止我们讨论了写SAS程序，但仅仅写不能带给你任何结果，你必须要提交并执行。有数种方法可以执行SAS程序，但不是任何方法都适合于你的操作环境。查找一下SAS帮助文档，或者咨询下你的SAS顾问，看看哪种方法适合你的操作环境。

 

**SAS****视窗环境**      如果你使用SAS是按照系统提示，或者是点击SAS的图标，那么你适合使用SAS视窗环境。在这种交互式的环境中，你可以写入、编辑SAS程序，提交处理、浏览、输出结果的SAS程序。此外，视窗有许多功能可以处理不同的任务，如管理SAS文件、定制界面、访问SAS帮助文档、导入和导出数据。你的视窗环境的界面取决于你电脑的的类型、使用的终端、电脑操作系统和启动SAS时实际的选择。如果你使用的是个人电脑，那么SAS视窗环境的感觉和其他软件类似。

 

**SAS****企业向导** 如果你有SAS企业向导软件，这个软件在windows下即可运行。你可以用这个软件提交程序：使用插入菜单打开代码窗口，输入序或打开现有SAS程。之后你可以用本地电脑、或者在远程服务器上（需要安装）运行SAS程序。

 

 

 

 

​     **非交互式模式** 非交互式模式是SAS程序语句已先存于你系统的文件中，直接执行那个文件。非交互式模式可以让SAS立即执行程序，通过某个指令开始（$），后接文件名，如：

$ SAS Myfile.sas

 

​        
 **批处理或后台模式** 在批处理或后台模式下，你的程序存于一个文件中，SAS会自动执行，你不需要在电脑旁，如果程序多，SAS会将这个程序进行排队等待。这种模式通常用在大型电脑中，因此通常可以一次性处理多个任务。批处理或后台模式的成本比较低，适合于大型工作，工作完成后，结果会存于文件夹中，你可以任何时候输出查看。批处理未必适合你的操作环境，另外提交方式也会有不同，最好查看SAS帮助文档，或咨询SAS顾问。

 

​             
 **远程提交** 如果你安装了CONNECT模块，可以进行远程提交，即在一台电脑上（本地）编写程序，在另一台电脑上（远程）处理，结果会返回本地电脑。当你处理大型任务，而你的电脑性能又不够时，可以连接到远程的高性能电脑上，也可访问远程电脑的分享文件。

**交互行模式** 交互行模式下，SAS每次提示用户输入一个语句，想改正输入的语句不是那么容易的。因此除非你足够优秀和熟练，否则最好不要用这个模式。你可以用endsas并回车来退出这个模式：

Endsas；

如果你想知道为什么会进入这个模式，并且在以后避免进入，你需要咨询SAS顾问。

### 1.6 SAS视窗环境中的视窗和命令

**SAS****视窗** SAS有五种基本的视窗（窗口）：结果视窗、资源管理器视窗、和三种程序视窗：程序编辑、日志、输出。除此之外，在获得SAS帮助、改变SAS系统选项、定制SAS人机会话等情况时，可能还会用到其他的视窗，下图显示了Microsoft Windows SAS会话中默认的视图：

   

 

**编辑窗口** 编辑窗口中你可以输入、编辑、提交SAS程序。Windows操作环境默认的是增强型编辑窗口，它对语法更敏感，并用颜色标注程序，使得更容易理解和发现错误。其他操作环境默认的是程序编辑窗口，并随操作环境和SAS版本的不同，界面特征也不同。

 

**日志窗口** 日志窗口是关于SAS会话的说明。在提交SAS程序之后，任何的说明、错误、警告和程序语句都会显示在日志窗口上。

 

**输出窗口** 如果程序产生需输出的结果，那么会反映在在输出窗口中。

 

**结果窗口** 结果窗口就像输出窗口的一个目录表，以提纲形式列出了输出的每一个部分。

 

**SAS****命令**SAS命令是为了不同的任务，你有三种方式发出命令：菜单、工具栏、SAS命令栏，如下图：

   

**菜单** （大部分操作环境都会有一个下拉菜单要么在窗口上方要么在屏幕上方…..oh my god!略）

 

**工具栏**（不是所有的操作环境都有工具栏…略！）

 

**SAS****命令栏** 可以在这里输入SAS命令，一些操作环境中，命令栏坐落在工具栏中，另一些操作环境中，每个SAS窗口都有一个命令行（command line），通过语句command=>激活。大部分命令是可以直接用菜单进行选择的。

 

**控制你的视窗** 你可以通过菜单、命令栏、点击的方式激活任何一种程序窗口。

 

### 1.7 在SAS视窗环境中提交程序

**将你的程序放入编辑窗口中** 你可以通过输入，或者打开现有程序文件的方式将程序放入编辑窗口中。打开现有的程序文件，可以通过菜单-打开，也可以通过工具栏的图表，或者直接将文件拖放到编辑窗口中。

 

**提交你的程序** 你有几种方式来提交程序：

​     使用工具栏的提交图表

 

​     激活命令栏，输入submit命令回车。

 

从run运行的下拉菜单中选择submit提交

​        


左图显示了如何在windows视窗中提交增强型编辑窗口的程序。

​        
 **访问****SAS****日志和输出** 提交程序后，日志窗口和输出窗口会有相应的日志和结果显示，如果你使用的是增强型编辑窗口，之前的程序会保留，如果使用的是程序编辑窗口，之前的程序不会保留。如果你的程序产生了输出，那么结果窗口会显示这些输出的目录，下图是一个例子，显示了提交程序之后，增强型编辑窗口、日志窗口、结果窗口、输出窗口的样式。

   

取回你的程序 如果不幸你的程序出现了问题，你需要再次运行，对于程序编辑窗口，由于之前的程序不在保留，因此需要调回命令（recall），有两种方法：

​     

命令窗口中输入recall

 

​     

 

 

激活编辑窗口，从运行（run）下拉菜单中选择

 

 

如果不停的使用recall命令，SAS可以一直往前调回程序，知道所有提交的程序都被调回。

 

### 1.8 阅读SAS日志

**在哪找到****SAS****日志** SAS日志窗口的位置随着你使用的操作环境、选择的模式（视窗、非交互、批处理）、个人的设置的不同而不同。在视窗模式下，提交程序之后，日志窗口默认的位置如下图：

   

对于批处理和非交互模式的日志则会被写入一个文件中，你需要使用操作环境的命令来查看，一般日志文件的名字与对应的SAS程序名一直，如你的SAS程序命为abc.sas，那么日志文件的命则为abc.log

日志包含的内容 日志中虽然有很多琐碎，但也包含了重要的信息。这里有一个将英里转换为千米的程序：

*Create a SAS data set named distance;                                                                                                  

*Convert miles to kilometers;                                                                                                           

DATA distance;                                                                                                                          

Miles=26.22;                                                                                                                            

Kilometers=1.61*Miles;                                                                                                                  

*Print the results;                                                                                                                     

PROC PRINT DATA=distance;                                                                                                               

RUN;

运行之后，SAS的日志窗口会产生一个类似这样的日志：

   

① 说明了你使用的SAS版本和site。

② 是原始的SAS程序语句

③ 说明了数据步为你创建的数据集名称，观测值数和变量数。它可以帮助你确认你的程序没有丢失观测值，也没有创建你不需要的变量。

④ 这部分显示了数据步和过程步占用的电脑资源。当你使用的是多用户系统，或者处理大型数据而使得SAS运行占用大量时间时，这部分信息可以帮助你检查哪一步比较耗时。

如果SAS程序出现错误，错误信息也会反馈在日志窗口中，说明哪里出错及出错表现。

 

### 1.9 输出窗口中浏览结果

你使用的模式不同，产看输出结果的方法也会不同。如果是在视窗模式下提交SAS程序，那么直接在输出窗口查看，如果是批处理和非交互模式下，那么结果就会保存在一个文件里，需要用命令查看。比如使用UNIX系统下的非交互模式，结果会存在一个后缀为.lst的文件里，使用cat或其他更多命令来查看。

 

**输出窗口** 提交程序后，结果会出现在输出窗口中，下图是一个输出窗口的例子

   

**打印或保存输出窗口的目录** 激活输出窗口的目录，在菜单栏文件（file）下拉菜单中选择打印（print）或保存（save）即可。

 

**结果窗口** 结果窗口起到输出窗口的目录作用，当你的输出结果非常多时，结果窗口很有用。它可以让你很清楚的看到输出结果的每一部分。下图是一个方差分析（ANOVA）过程的结果。在这个图中，左边是输出结果的目录，点击+号将其展开，可以看见ANOVA结果的各个部分，双击某一部分，则该部分结果就会位于输出窗口顶部。

   

 

**打印或保存部分输出** 如果要打印结果窗口中显示的某一部分的输出，则需将鼠标移到该部分上，右击，选择打印或保存即可。或者点击一下，使其黑亮，再从菜单栏文件（file）的下拉菜单中选择输出或保存。

   

 

### 1.10 创建HTML输出

如果使用的是SAS视窗环境，那么可以为结果创建超文本标记语言（HTML）格式。

**参数选择窗口** 选择菜单栏中工具（tools）下拉菜单的选项（options）-参数选择（preferences）。选择结果（result）选项卡，如下图所示：

   

这个参数选择窗口上，有一个“创建列表（create listing）”选项，默认的输出就是列表输出。下面还有“创建HTML”选项，用来创建HTML。样式（style）选项用来为HTML选择一个风格样式。选择之后，点击OK。

 

**结果浏览窗口和结果窗口** （注意下面提到的三种窗口：结果浏览窗口result viewer，结果窗口results window，输出窗口output window）

一旦选择了HTML输出，每次运行程序的时候都会自动出现一个结果浏览窗口（result viewer），下图显示了在运行了一个均值和输出的程序后，出现两个窗口：结果浏览窗口——显示HTML输出，结果窗口——显示输出的目录。

   

结果浏览窗口一次只显示输出结果的一个部分，通过选择结果窗口的目录，可以查看其他的部分。值得注意的是，结果窗口给出的目录中，每一个部分都给出了两种相同的目录，一个是链接到输出窗口，一个是链接到结果浏览窗口

保存结果浏览窗口的输出（output of result viewer）的方法：激活结果浏览窗口，选择菜单栏文件（file）下拉菜单的保存（save as）、输出（print）。

可以在style中为输出选择不同的风格，如下图就是D3D的风格：

   

 

### 1.11 SAS数据的逻辑库

SAS逻辑库库只是数据集文件存放的地点。打开SAS视窗模式后，会看到SAS资源管理器窗口（explore），双击逻辑库图标，资源管理器窗口会显示出所有已定义的图标。要返回前一级窗口，选择查看（view）-向上一级（up one level），或者在工具栏中直接点击向上一级图标   。

 

**逻辑库窗口** 打开逻辑库窗口后，除了自己创建的库外，至少会呈现三个逻辑库：sashelp，sasuser，和work，如果安装了某些SAS模块，还有一些特别的逻辑库，比如SAS/GRAPH模块的Maps逻辑库。Sashelp包含了控制SAS会话以及样本数据集的一些信息。WORK是sas数据集的临时储存地点，创建的数据集如果没有指定库，则默认储存在这里，关闭程序时则自动删除数据集。也可以更改默认的库，从而不是临时库。

   

​     

**创建新逻辑库** 创建新逻辑库有两种方法：在逻辑库窗口中选择文件（file）下拉菜单的新建（new）；或者直接右键——新建。

 

 

 

 

 

 

在新建逻辑库（new library）窗口中，为你的逻辑库起一个名字，这里叫做Mylib,指定库的存放路径。如果不想每次启动SAS都要调用这个库，则勾选启动时启用（enable at startup）即可。

   

​     

这是一个新建的Mylib逻辑库的视图。

 

 

 

 

 

 

 

 

 

 

 

 

### 1.12 用SAS资源管理器访问SAS数据集

可以利用SAS资源管理器打开数据集、浏览、编辑，也可以列出数据集的信息，如创建时间和变量名。

​     

**目录窗口** 打开一个逻辑库，进入一个目录窗口，显示这个库中所有的文件和文件夹。右图的目录窗口中显示Mylib逻辑库有三个文件：Customers，Models，orders。双击某文件，则可以打开这个文件的可视视图。     

 

**可视视图** 这个窗口允许你创建、浏览、编辑数据集。

​     

**列出****SAS****数据集的属性** 用资源管理器还可以列出SAS数据集的一些属性情况，右击某文件，选择下拉菜单的属性（properties），属性窗口显示了SAS数据集的属性信息，如创建时间、行列数等。

 

 

 

 

 

 

 

 

 

 

 

 

​     

 

 

 

如果选择列（columns）选项卡，则出现数据的列信息

 

 

 

 

 

 

​     

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

### 1.13 使用SAS系统选项

SAS系统选项是影响SAS运行的一些参数，比如输出的显示、内存的占用、错误的处理等问题。这些小问题由SAS为你设定好，你也可以改变它。

SAS系统选项的参数不是所有都适合你的操作环境，适合于你的再SAS的帮助文档中给出。可以通过打开SAS系统选项窗口或使用option程序来查看你的SAS系统参数。Option程序的语句如下：

Proc options；

Run；

有四种方法可以指定系统选项的参数，SAS帮助文档会告诉你哪种适合你的操作系统：

\1. 系统管理员会创建一个包含了系统选项设定的配置文件，每次SAS启动时都会访问这个文件。

\2. 在启动SAS之后，根据系统提示指定系统选项。

\3. 如果使用SAS视窗环境，可以从SAS系统选项中改变已选择的选项。

\4. 使用OPTIONS语句。

这四种方法按照优先性排列，方法2优先于方法1，方法3优先于方法2，方法4优先于3。如果使用SAS视窗环境，方法3,4最好。

 

**OPTIONS****语句** OPTIONS语句是SAS程序的一部分，并可影响之后的所有语句。由OPTIONS关键词开头，后面是相关选项。比如：

OPTIONS LINESIZE=80 NODATE;

OPTIONS语句既不属于数据步也不属于过程步，这个全局变量可以出现在程序的任何部分，但放在开头最有意义，你可以很容易看到哪些选项在发挥作用。如果OPTIONS语句只出现在数据步或者过程步中，那么它会影响那个过程，和下面的过程（If the OPTIONS statement is in a DATA or PROC step,then it affects that stepand the following steps.）。注意，后面的OPTIONS语句会覆盖前面的，即以后面的OPTIONS为主。     

 

**SAS****系统选项窗口** 通过这个窗口也可以改变系统选项。可以通过在命令栏中输入“OPTIONS”，或从工具（tools）下拉菜单中选择. 

窗口出来后，找到要修改的部分，右击——修改值（modify the value）即可。

 

 

**一般选项** 下面是一些可能用到的一般系统选项

| CENTER\|NOCENTER                                            | 输出是否居中，还是左对齐。默认居中                           |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| DATE\|NODATE                                                | 今天的日期是否出现在输出的顶部。默认输出                     |
| LINESEZE=n                                                  | 控制输出行的最大长度，n可能的值为64到256                     |
| NUMBER\|NONUMBER                                            | 输出的页面页码是否需要。默认需要。                           |
| ORIENTATION=PORTRAIT；   ORIENTATION=LANDSCAPE；            | 指定打印输出的方向。默认竖向（portrait）                     |
| PAGENO=n                                                    | 输出页开始的页面。默认为1                                    |
| PAGESIZE=n                                                  | 每个页面输出的最大行数。可能的值为15到32767                  |
| RIGHTMARGIN=n   LEFTMARGIN=n   TOPMARGIN=n   BOTTOMMARGIN=n | 指定打印输出的边缘大小。默认0.00英寸（Specifies size of   margin(such as 0.75in or 2cm)to be used for printing output.Default:0.00in.） |
| YEARCUTOFF=yyyy                                             | 设定起始年份                                                 |




## 第二章 将你的数据放入SAS

### 2.1 将你的数据放入SAS的方法

你可能有各种形式的数据，包括手写在纸上、存放在电脑上、或是在数据库管理系统里，不论如何，总有一种方法可以让SAS来读取。

SAS读取的数据的方法主要有以下几种类型：

l  直接输入；

l  从原始数据文件中创建一个SAS数据集（creating SAS data sets from raw data files）；

l  将其他软件中的数据文件转换成SAS数据集；

l  直接读取其他软件的数据集；

 

**直接输入** 

l  View table窗口可以让你以表格形式输入数据，可以定义变量、设置属性，如name、length和 type(character or numeric).

l  SAS 企业向导模块，a Windows only application, has a data entry window that is very similar to the View table window. As with View table, you can define variables and give them attributes.

l  SAS/FSP 模块，是Full Screen Product的简称，可以设计定制的数据输入窗口，也有检测数据输入错误的功能（The SAS/FSP product is licensed separately from Base SAS software.）。

 

**从原始数据文件中创建一个****SAS****数据集** 你有两种方法读取原始数据文件：

l  数据步可以读取任何形式的原始数据文件，这种方法还将在2.4中详解。

l  导入向导（Import Wizard）、导入过程（IMPORT procedure）适用于UNIX、OpenVMS和 Windows操作环境的简单方法，可以读取CSV（comma-separated values）和其他一些限定的文件类型。

 

**将其他软件中的数据文件转换成****SAS****数据集** 如果数据在一个软件中以某种格式存放，但需要用另一种软件分析时，就会很麻烦。有几种方法可以将某种软件中的数据转换成SAS数据集：

l  如果安装SAS/ACCESS模块，可以用导入过程（import procedure）和导入向导（Import Wizard）将Excel、Lotus、dBase和Access文件导入SAS数据集，见2.3和2.17（？）。

l  如果没有安装，可以用存放数据的软件创建一个原始文件，并用数据步或导入过程（import procedure）读取。很多软件都可以创建CSV文件。

l  Windows操作环境下也可以用动态数据交换技术（Dynamic Data Exchange，DDE），见2.18。前提是必须有一个其他的Windows程序与SAS同时运行，再使用DDE和数据步。

 

**直接读取其他软件的数据集** 

l  SAS/ACCESS产品可以不用转换数据格式读取数据，并适用于大部分数据库管理系统，包括ORACLE,DB2,INGRES和 SYBASE（但使用方法本书没有介绍）。

l  使用Excel engine和Access engine来读取这两种类型的数据。（SAS帮助文档）

l  还有其他的一些数据引擎（data engines）来读取数据，如SPSS engine（附录D），查找帮助文档找到适合你操作环境的所有有效engine。

 

### 2.2 用View table窗口输入数据

调用View table窗口，在工具栏的下拉菜单中选择表编辑器（Table Editor）。

   

**列属性窗口** 每一列顶部的字母是默认的变量名，右击变量名，即可打开列属性（column attributes）窗口，设置属性之后，点击应用（apply），设置完后关闭即可。

   

**输入数据** 

   

**保存表** 选择文件（file）——另存为（save as），选择一个逻辑库保存，如果想保存在新的逻辑库，点击创建新逻辑库图表（New Library），输入逻辑库的名字和保存路径。

 

**打开一个已有的表** 首先打开表编辑器，选择文件（file）——打开（open）。打开之后，SAS默认的是浏览模式，如果要对数据进行编辑，则要在编辑（edit）菜单中选择编辑模式。也可以在资源管理器窗口中双击打开一个已有的表。

 

**其他功能** 其他一些功能包括排序、打印（printing）、增加和删除行、一次浏览一行（表单视图Form View）、一次浏览多行（表视图 Table View）。图标和菜单都可以选择这些功能。

 

**在****SAS****程序中使用表** 如下程序语句可以将表内容输出打印：

PROC PRINT DATA=Sasuser.coffee;

RUN；

### 2.3 用导入向导（Import Wizard）读取文件

导入向导会浏览你的文件以决定变量的类型，并默认数据表的第一行存放变量名。

第一步，从文件（file）下拉菜单中选择导入数据（import data）导入向导（Import Wizard）

   

第二步，从standard data sources中选择要导入的数据类型。以comma separated values（*.csv）为例。点击下一步

第三步，指定要导入的文件位置，SAS默认第一行存放变量名，从第二行开始存放数据。Options可以改变这种默认选择。

   

第四步，选择数据集要存放的逻辑库，并为数据集取一个名字（member）

   

最后，导入向导创造一个proc import语句，可以是SAS再次导入这个数据。

   

另外，对于一些类型的数据文件还有额外的步骤，比如Microsoft Access文件，你需要输入数据库名和药导入的表名，有时甚至还要输入user的ID号和密码。

 

**在****SAS****程序中使用导入数据** 比如你将数据存放在work逻辑库，并署名为flowers，那么你可以这样来输入它：

PROC PRINT DATA=WORK.flowers;

RUN;

由于work是默认的逻辑库，所以也可以直接这样：

PROC PRINT DATA=flowers;

RUN;

 

### 2.4 告诉SAS你的原始数据在哪

如果数据是原始数据（比如text, ASCII, sequential, flat files），那么用数据步来读取能带给你最大的灵活性。但首先你要告诉SAS你的原始数据在哪。

原始数据可以通过文本编辑器（text editors）或系统命令。对PC使用者来说，原始数据没有相关联的应用程序（就像doc文件与word相关联，双击doc程序就默认调用word程序以打开），有时他们会与像Microsoft Notepad这样的简单编辑器相关联。

**内部原始数据** 如果直接将数据输入SAS程序中，那么数据就是SAS内部数据。DATALINES是一个指示，告诉SAS下面跟着是数据行，直到分号结尾，这个分号可以另起一行，也可以接在数据的后面。也可以用card代替DATALINES。下面是一个程序，这个程序创建了一个USPRESIDENTS数据集。（Input语句还将在2.5和2.15中讨论）

   

**外部原始数据** 数据外SAS程序外部时，使用INFILE语句告诉SAS外部数据的文件名和存放路径，它在data语句之后，在INPUT语句之前。INFILE后面的文件名和路径要用引号，各种系统的引用方式各不同：

   

假设有一个President.dat数据在你的C盘的MyRawData目录中，

   

那么可以用如下方式引用这个外部数据：

   

**SAS****日志** 读取外部数据时，SAS日志会给一些很有用的信息，检查这些信息可以解决一些问题，比如对比INFILE语句读取的记录数和数据集中实际观测值，可以确定SAS是否正确的读取了数据。上面程序的日志如下图所示，

   

**过长记录** 在一些操作环境中，SAS假定外部数据文件的记录长度为256或更少（记录长度是指某行中的字符数，包括空格），如果长度过长，SAS不能读取全部，此时需要在INFILE语句中使用LRECL=来指定长度，这个长度必须是数据中最长行的长度，如：

INFILE ’c:\MyRawData\President.dat’ LRECL=2000;

可以通过SAS日志来查看最大记录长度。

### 2.5 list input读取空格分开的原始数据

如果原始数据都至少被一个空格分开，那么用list input读取数据可能是正确的。List input是一个很简单的读取数据的方式，但是会受到很多限制。你必须读取所有的数据记录，不能跳过某些值、缺失值必须用句号“.”代替。字符串数据不能包含空格、长度不能超过8个字符。而且如果数据文件包含日期变量或者其他需要特别处理的变量，list input将不再适用。虽然很多限制，但仍有大量的文件可以用这种方式读取。

INPUT语句是数据步的一部分，它告诉SAS如何读取原始数据。使用List input来写input语句：在INPUT关键词之后列出变量名（按照变量在文件中出现的顺序），变量名长度在32个字节（含）以下，只能包含字母、下划线和数据，并必须以字母或者下划线开头。如果变量是字符串，后面要价“$”号，值与值之间至少有一个空格，语句要以分号结束。如：

   

这表明输入三个变量，其中name是字符串，age和height是数值变量。

**例子** 你想组织一次青蛙跳跃比赛，现在你记录了每只参赛青蛙的名字、体重、和三次跳跃的距离，如果某次的跳跃距离不合格，那么就用“.”代替，数据文件ToadJump.dat形式如下：

   

虽然不是很整洁、但满足list input的所有要求（字符串长度小于8个字节、不包含空格、值之间都有至少一个空格，缺失数据也用句号代替）。Nosiy的数据溢出到第二行了，但这不影响，SAS会按照变量顺序自动跳到下一行读取。如下是读取这个数据的SAS程序：

   

Input后面是变量名，ToadName是字符串变量，其他是数值变量；proc print过程用来输出数据集中所有的变量和观测值；title语句用告诉SAS输出顶部的标题，如果不指定标题，SAS将以“the SAS system”作为标题在每一页的顶部。输出的形式如下：

   

由于Noisy的数据溢出到下一行，因此下面的说明会出现在SAS日志上：

   

 

### 2.6 column input读取按固定列排列的原始数据

当一些原始数据的值之间没有空格分开，或者没用用句号代替缺失值时，list input就不能用。但当每个变量的值都出现在数据行的相同位置时，并且变量值是字符串或者标准数值（只包含数据、小数点、正负号、和科学标注的E。逗号和日期都不能算）时，可以使用column input来读取。

相比list input，column input有如下优势：

l  不要求变量值之间的空格；

l  缺失值可以直接用空格代替；

l  字符串中可以包含空格；

l  可以跳过不需要的变量。

调查数据使用column input，因为调查答案的记录都是用单个数字（0-9），如果每个答案之间再用空格分开，就会使整个文件会扩大两倍。有地址的数据文件也使用 column input，因为地址之中常常包含空格，比如街道Martin Luther King Jr.Boulevard在column input中就可以当成一个变量而不是五个。可能用column input读取的数据也可以用formatted input读取或者几种方式组合。

Column input的input语句格式如下：input关键字后接变量名、再接变量的列位置（列位置是字符或者数值在一行中的位置）。字符串变量名后仍要用“空格+$”，变量名之间仍要用空格隔开。示例如下：

   

这个语句表明，Name变量，在行中占据第1列第10列，为字符串变量，age占据第11-13列，为数值变量，height占据第14-18列，数值变量。

**例子** 原始数据记录如下：

   

读取这个数据的column input程序如下：

   

第一个变量visitingteam占据第1-20列，为字符变量；concessionsales占据第21-24列，为数值变量，下面几个变量均占据固定的列。输出结果如下：

   

 

### 2.7 informats读取非标准格式的原始数据

有时候原始数据不全是字符串或者数值，比如类似1,00,001这样包括逗号的字符串值，电脑就不能读取，其他诸如包含美元符号、十六进制、压缩十进制的数据都是非标准数据。SAS中，informats可以用来告诉电脑如何读取这样的数值。

日期是最普通的非标准数据，SAS informats会把类似10-31-2003或者31OCT03转换成数字，日期的起点为1960年1月1日，即这一天的数字为0。

Informats的三种普遍格式为：字符串、数值、日期。这三种格式的形式如下：

   

$代表是字符串、informats代表形式（比如日期的MMDDYY）、w是宽度、d是小数点的位数、最后是句号“.”，缺少句号会使得SAS把形式（如MMDDYY）当做变量名。一个简单formatted input的简单INPUT语句如下：

   

Name为字符串变量，占据10个宽度，即列位置从1-10；age为数值变量，占据3个宽度，列位置从11到13；height也为数值变量，占据5个宽度，包括了1位小数点和小数点本身，列位置从14-18（如150.3）；最后是日期变量，从第19列开始，形式为MMDDYY。

**例子** 原始数据如下：

   

读取这个数据的informat程序如下：

   

年龄后面的+1代表跳过一列，即原始数据中年龄后面有一个空格。最后的5个变量score1-score5，都要求有同样的形式，4.1。将变量名和形式分别放在两个括号集中，可以一次性定义很多变量。输出结果如下：

   

 

### 2.8 可选择变量形式

一般使用的变量形式的定义，以及它们的宽度范围和默认宽度如下：

   

   

 

### 2.9 混合读取方式

每种数据读取方式都有其优势，list最简单，column和formatted虽然复杂但是不要求变量之间的空格，并且变量名中可以包含变量，而且formatted可以读取特殊的数据比如日期。SAS可以灵活的让你搭配不同的读取方式，以达到最大的方便。 

例子 如下的原始数据记录了美国国家公园的信息：姓名（name）、所属州（state）、建立时间（year established）、占地面积（size in acreage）：

   

有多种方式进行数据读取，下面的程序是方式之一：

   

其中ParkName是column方式读取，State和Year是list方式读取，Acreage是formatted方式读取，输出结果如下所示：

   

混合读取方式有时会遇到问题：SAS通过一个指示器标注位置，来读取原始数据的一行，但每种读取方式对指示器的使用稍有不同。List方式下，SAS自动找到非空格区域并开始读取；column方式下，SAS读取你所指定的特定位置；informatted方式下，SAS不理会指示器的标准，只是依次的读取。这时，就会需要列指示器@n，来人为的让SAS的读取直接跳至某列。

在上面的程序中，列指示器@40告诉SAS在读取Acerage变量之前，移动到第40列去，如果移去指示器，程序为：

   

输出结果如下图所示：

   

之所以出现这样的结果，要看原始文件的列坐标排列：

   

Comma9告诉SAS读取9列，SAS就会读取包括空格在内的9列，这便会导致输出结果的问题。

 

### 2.10 读取凌乱的原始数据

有的数据排列混乱，长度不一。这样的数据需要新的工具处理：@’character’ 列指示器和colon modifier。

**@’character’** **列指示器** 2.9中提到@column列指示器可以让SAS直接从某列开始读取数据。但有时候你不知道要读取的数据是从哪列开始，此时你只要知道要读取的数据的前面那个字符或单词即可。比如有一个关于狗的原始文件，你想要读取狗的品种号，但文件排列很凌乱，只知道品种号跟随在单词breed后面，那么可以用如下方式读取：

Input @’Breed:’ DogBreed $;

**colon modifier** 由于input读取字符串变量默认为8个字符，因此在上例中如果狗的品种名（dogbreed）超过8个字符，则需要定义长度，定义为$length，在该长度中，空格也算在内。如果要使SAS读取过程中遇到空格则不再继续读取，则要在$length.前面加冒号“:”。比如原始数据中有这么一行：

My dog Sam Breed:Rottweiler Vet Bills:$478

如果用上述不同方法读取，会有不同结果：

   

例子 web日志是凌乱数据的一个很好例子，下面是一个网站的web日志，数据开始于访问IP，后面有访问日期、访问文件名等信息。

   

现在想要读取访问日期和访问的文件名，但是它们每行中所占据的列的位置都不同，而且文件名的长度每行都不一样，那么SAS读取这种文件通过如下方式：

   

@’[’作为列指示器，告诉SAS读取[之后的内容，@’GET’告诉SAS读取GET之后的内容，由于文件名作为字符串变量，这里基本都会超过8个字节，因此后面附加:$20。输出结果如下：

   

 

### 2.11 跨行观测值的读取方式

一般原始文件中一行代表一个观测值，有时会出现一个观测值跨行的情况。由于SAS会自动转到下一行读取数据，直到读取这个观测的所有变量（input语句中给出），所以你需要告诉SAS什么时候不要换行，以便在日志中不出现SAS-went-to-a-new-line的暂停说明，此时需要在INPUT语句中加行指示器。

行指示器，斜线/：告诉SAS跳至原始数据的第二行；#n：跳至第n行，n代表原始数据中某观测值的行数（#2则让SAS跳至某观测值的第二行），#n不能用来回跳。

**例子** 有一组关于温度的数据，temperature.dat第一行代表城市和州，第二行代表本日最高温和最低温，第三行代表史上最高温和最低温。

   

用如下的程度来读取这份数据：

   

Input后面告诉SAS读取第一行的city变量和state变量，斜线/告诉SAS移动到下一行的第一列，以便读取normalhigh和normallow。#3告诉SAS移动到第三行的第一列以便继续读取观测值的recordhigh变量和recordlow变量。这里/可以用#2代替，也可以用/代替#3。

日志记录如下：

   

从日志中可以看出，虽然原始原件占了9行，但只有三个观测值。

输出结果如下：

   

 

### 2.12 一行有多个观测值的原始文件读取

​     

当一行出现多个观测值时，可以在input语句结尾加一个停止符号@@

**例子** 有一个关于降水量的数据，precipitation.dat，文件包含城市名、州名、月平均降水量、月平均降水天数：

   

这个数据文件中，第一行包含了两个观测值，可以用@@的程序读取：

   

 

日志记录如下：

   

中间的说明，SAS went to a new line when INPUT statement reached past the end of a line.是指读取第二个值时达到第一行末尾，并转到下一行继续读取。通常这些信息会预示一个问题出现，但在这里它们都是你所想要的（为什么？）

输出结果如下：

   

 

### 2.13 读取原始数据的部分观测值

​     

有时候只需要读取原始数据的部分观测值，比如只需要年鉴中的女性数据、收入超过10万的人口数据等。

此时的数据读取方式如下：在SAS读取某一行观测值时，首先读取足够的变量以便决定是否需要保留此行的观测值。然后在input语句结尾加符号@，叫做a trailing at（called a trailing at），这告诉SAS先停在（hold）此行，同时用IF语句检测此观测值是否满足需要，如果是，那么可以再用一个input语句来读取现有的变量。

例子 有一个关于当地交通的数据，traffic.dat数据包含街道的类型（freeways和surface）、街道名称、早晨每小时的机动车流动量、晚上每小时机动车流动量。

   

如果现在你只需要freeway的数据，可以用下述程序：

   

第一个input读取字符串变量，@是SAS停留在观测值上并用IF检测，第二个input读取input后面的变量值。

程序执行后日志包括两部分说明，一个说明读取了8个记录，另一个说明新数据集中只包含三个观测值。

   

输入结果如下所示：

   

 

**@ vs @@** @的作用类似于@@，都是行停留指示符（line-hold specifiers），不同地方在于停留多久，@能使SAS停留到下一个input语句（也不换行），@@能使停留的时间到下一个data步（也不换行）。

比如这段代码：

data test;                                                                                                                              

​    infile cards ;                                                                                                                      

​    input x @; 

​    input y; 

​    input z @@; 

cards;                                                                                                                                  

1 2 3 4 5 6                                                                                                                             

7 8 9 10 11 12                                                                                                                          

13 14 15 16 17                                                                                                                          

;                                                                                                                                       

run;

test输出结果就是：

​     

 

 

 

### 2.14 用infile语句中的选项控制输入

读取原始(raw)数据时，SAS做了某些假设，比如从第一行开始读取数据，对于跨行观测值，会自动转到下一行继续读取。但有的特殊数据不满足这些假设，infile语句的选项可以让SAS读取这些特殊数据。

**FIRSTOBS=** FIRSTOBS= 选项告诉SAS从哪一行开始读取数据，当数据开头有些说明信息，或者想要跳过某些行时，这个选项很有用。例如，如下原始数据文件中，开头两行是关于数据的描述：

   

那么用如下程序可以让SAS从第三行开始读取数据：

   

**OBS=** OBS=告诉SAS一直读取到哪一行位置，注意是行而不是观测值（有的观测值占据多行）比如，如下的原始数据文件中，结尾处还有一句不需要的数据说明时。就需要这个选项：

   

用FIRSTOBS=3和OBS=5就可以读取第三行到第五行的数据：

   

**MISSOVER** 在input语句中输入的几个变量，SAS在观测值中就读取几个变量，如果一行未读完，则进入下一行直到输入的变量都读取了变量值。missover可以让SAS不进入下一行读取，未赋值的变量就使其成为缺失值。当如下这种数据，就需要missover选项，一个学生应该有5门课的成绩，但由于最后两门是自学课程，不是所有学生都完成，故而缺失：

   

如下的程序可以让SAS将Nguyen第五门课的成绩设为缺失值，从而不牵扯到下一行：

   

**Truncover** 使用column input或formatted input输入时可能会需要这个选项，因为这时有的数据行比其他的短。如下的原始数据中，由于三行的长度都不一样，input中只能指定最长的一行：

   

程序如下：

   

这里指定了第二行的长度street $ 22-37，但是第一行maple ave.并没占够至第37列（注意后面是没有空格的），故而必须用truncover，否则会转到下一行继续读取，第三行情况也是。

 

### 2.15 用数据步读取分隔符文件（delimited files）

分隔符文件中，变量值之间会用一些特殊的字符隔开，比如逗号或制表符。DLM=和DSD选项可以让SAS容易地读取这些分隔符文件。

**DLM=**  用list input读取文件时，变量值之间应该用空格隔开。对于其他的分隔符，可以用DLM=/DELIMITER=选项来指定，从而可以读取文件。

**例子** 如下的数据中，学生姓名、每周读书数目是用逗号隔开的：

   

用选项来指定分隔符即可：

   

如果原始数据是用制表符隔开的，那么可以使用DLM=’09’X来指定，因为制表符的十六进制值是09，如果你电脑使用EBCDIC（扩充的二进制编码的十进制交换码），那么应该用DLM=’05’X。

```
DSD选项 DSD (Delimiter-Sensitive Data)有三个作用：忽略引号中数据的分隔符，例如一个观测Joseph,76,"Red Racers, Washington"非引号中的逗号能识别成分隔符，而引号中的逗号不能识别；自动将字符串中的引号去掉；将两个相邻的分隔符当作缺失值来处理。并且，DSD默认分隔符为逗号，如果数据中的分隔符不是逗号，那么要用DLM来指定。比如，读取一个制表符为分隔符、并且用两个制表符代表缺失值的数据文件，则要用下面的语句：
```

INFILE ’file-specification’ DLM=’09’X DSD;

**CSV****文件** CSV文件，Comma-separated values files(逗号分隔的文件)，是可以用DSD选项的文件类型。Excel可以储存CSV格式的文件。

**例子** 某咖啡馆，老板每晚请不同的乐队表演来吸引顾客，他记录了乐队名称、演出日期、晚上8点、9点、10点、11点的顾客数量：

   

注意，其中有一个乐队的名字中用逗号来分隔，并且使用了引号。最后一条记录中还有一个缺失值，用两个连续的逗号表示。INFILE语句中的DSD选项可以用来读取这个文件，并且，由于每个记录长度不一样，还需要用missover：

   

注意bandname和GigDate两个变量使用了**冒号修改器**，冒号修改器告诉SAS读取信息的长度（BandName为30，GigDate为10）。如果不加冒号修改器，将会默认每个变量的长度为该变量取值最长的那个值的长度，输出结果如下：

   

 

### 2.16 用导入过程（IMPORT procedure）读取分隔符文件

Proc import会浏览你的数据文件，自动决定变量类型（字符串或数值），为字符串变量分配正确的长度，辨认出日期变量。Proc import会将两个连续的分隔符视为缺失值，会读取引号中的变量值。一行读完后，会自动分配缺失值给未赋值的变量。此外，如果你愿意，你可以使用你的数据文件中的第一行作为变量名。导入过程（IMPORT procedure）自动为你写下数据步，这可以在提交之后的日志窗口中查看。

一个导入过程（IMPORT procedure）的最简单形式：

PROC IMPORT DATAFILE=’filename’ OUT=data-set;

用语句DATAFILE=’filename’读取文件名，用OUT=data-set创建SAS数据集。SAS会通过文件的扩展名来检测文件的类型：

   

如果文件没有正确的扩展名，或者是DLM格式的，必须在proc import语句中用DBMS=option。如果想要创建的数据集名字已经存在，那么要用replace选项代替。一个使用replace和dbms的例子。

PROC IMPORT DATAFILE=’filename’ OUT=data-set DBMS=identifier REPLACE;

导入过程（IMPORT procedure）从数据文件中的第一行获取变量名，可以通过在PROC IMPORT后面增加GETNAMES=NO语句来改变这种默认，PROC IMPORT会分配给变量名字：VAR1，VAR2，VAR3等。如果你的数据文件是DLM类型的，PROC IMPORT会假定分隔符为空格，用DELIMITER=可以改变默认（空格）的分隔符。

DATAROWS = n;  Start reading data in row n. Default is 1. 

GUESSINGROWS = n; Use nrows to determine variable types. Default is 20.

如下是一段有上述代码的程序：

   

**例子** 下面还是使用咖啡馆中，乐队表演的例子（2.15），注意其中有一个乐队的名字中用逗号来分隔，并且使用了引号：

   

用proc import读取数据的代码如下：

   

输出结果如下，注意GigDate的日期格式能够被proc import辨认出来：

   

 

### 2.17 用导入过程（IMPORT procedure）读取PC文件

如果安装了SAS/ACCESS模块，导入过程（IMPORT procedure）可以导入一些PC文件类型。它会浏览你的文件以决定变量类型，并默认使用数据的第一行来分配变量名。Windows操作环境中可以导入excel、Lotus、dBase、和Access文件。Unix系统中可以导入dBase文件，并且从SAS9.1开始，Unix系统也可以导入excel和access文件。在windows环境中有一个不需要SAS/ACCESS模块的方法——Dynamic Data Exchange(DDE)，将在2.18中讲解。

**Microsoft Excel****，****Lotus****，和****dBase****文件** 下面是用导入过程（IMPORT procedure）读取PC文件的一般过程：

PROC IMPORT DATAFILE=’filename’ OUT=data-set DBMS=identifier REPLACE;

如果读取的文件是如下类型，就不用DBMS=OPTION。

   

在读取excel时，有时需要指定要读取的是哪一个工作薄——sheet

SHEET=name-of-sheet;

默认情况下，导入过程（IMPORT procedure）会从工作薄的第一行中读取变量名。如果不需要，可以用如下代码使得SAS给变量赋名为F1，F2等。

GETNAMES=NO;

**Microsoft Access Files** 读取这种文件需要用DATABASE=和DATATABLE=，而不是DATAFILE=option。

   

下面的是DBMS可以辨认的Access文件

   

**例子** 有如下的EXCEL数据：

   

读取的proc import程序：

   

输出结果如下：

   

### 2.18 用DDE读取PC文件

DDE，动态数据交换（Dynamic Data Exchange），读取PC文件的优点为：可以直接访问存于PC文件中的数据，不要求购买其他SAS产品；缺点为：只能用在windows环境下，只能在程序运行时（比如excel），SAS才能进行读取。

有几种方式可以用DDE访问数据：

l  复制数据到剪贴板

l  指定DDE三元组

l  从SAS中启动PC程序，然后读取数据。

**复制数据到剪贴板** 可以直接复制数据至剪贴板，然后在SAS程序的DDE FILENAME 语句中是使用CLIPBOARD关键字。比如，excel中有如下的工作薄：

   

复制A2到G5，然后在不关闭excel的状态下，提交如下SAS程序：

   

FILENAME语句将指代的文件（BASEBALL）定义成DDE类型，并指定从剪贴板（CLIPBOARD）中去读取它。DDE默认空格为分隔符，如果变量值之间有空格，则要在INFILE语句中用NOTAB选项和DLM=’09’X选项，前者告诉SAS在变量值之间放置制表符，后者告诉SAS将制表符定义为分隔符。如果数据中有缺失值，则要在INFILE中加入DSD和MISSOVER选项，前者将两个连续的分隔符视为缺失值，后者告诉SAS如果此行读完，不要进入下一行给未赋值的变量赋值。

**指定****DDE****三元组** 这种方法可以不用复制数据，直接指定出文件的DDE三元组。DDE三元组的形式为：**application|topic!item****。**

有一种方法可以在SAS中直接查看文件的DDE三元组，方法为：复制数据至剪贴板里，触发SAS会话，从解决方案（Solution）菜单中选择附件（Accessories）——DDE三元组。一个窗口会出现你复制文件的DDE三元组。比如，一个工作薄的DDE三元组为：

Excel|C:\MyFiles\[BaseBall.xls]sheet1!R2C1:R5C7

读取这个文件的FILENAME语句为：

FILENAME baseball DDE 'Excel|C:\MyFiles\[BaseBall.xls]sheet1!R2C1:R5C7';

**从****SAS****中启动应用程序** 这种方法可以不用在运行SAS之前启动数据程序。想要从SAS中启动程序，然后读取数据，则首先需要NOXWAIT和NOXSYNC系统选项，然后使用X语句，一个例子：

   

NOXSYNC和NOXWAIT语句告诉SAS不要等待用户输入。X语句告诉windows执行或打开引号中路径的文件，注意这里路径设置了两个引号，如果路径中有空格，则要设置两个引号。使用这种方法，必须要在FILENAME语句中指定DDE三元组。

### 2.19 临时和永久数据集

SAS临时数据集只在目前工作或会话中存在，关闭SAS或结束工作时则删除；永久数据集当关闭SAS或结束工作时仍然存在。

**SAS****数据集名** 所有的SAS数据集都有用句号分开的两层数据集名，如work.a。第一层前缀work是逻辑库名，第二层是在逻辑库中用于辨别自己的成员名。

名字的规则是，以字母或下划线开头，并且名字中只能包含字母、数字和下划线。而且，库名不能超过8个字节，而成员名却可以达到32个字节。

大部分数据集通过数据步创建，过程步也可以创建。如果指定了一个前缀不为work的两层数据集名，则这个数据集就是永久的。如果不指定前缀，则默认数据集是临时的，自动分配到work逻辑库中。下面是一些数据集名对应的逻辑库，成员名，类型：

   

**临时数据集** 如下的程序创建并打印了一个名为DISTANCE的临时数据集：

   

这里，只指定了成员名distance，自动分配到work库中，日志窗口中有说明：

NOTE: The data set **WORK.DISTANCE** has 1 observations and 2 variables.

**永久数据集** 可以在资源管理器窗口中定义一个新库使用：

   

也可以通过如下程序：

   

那么日志窗口就会出现如下说明：

NOTE: The data set **MYLIB.DISTANCE** has 1 observations and 2 variables.

这是一个永久数据集，因为前缀不是work。

### 2.20 用LIBNAME语句使用永久数据集

LIBNAME语句的基本形式为：LIBNAME libref ’your-SAS-data-library’;

LIBNAME的后面，需要指定库名和存放的路径，在个人操作环境下LIBNAME语句的基本形式为：

   

**创建永久数据集** 如下的例子创建了一个永久SAS数据集，包含了magnolia trees的一些信息。每一种树，原始文件都包含它的科学名、普通名、最大高度、第一次开花的年龄、是evergreen还是deciduous、以及花的颜色。

   

下面的代码将会创建一个PLANTS的逻辑库，路径为C盘下的MySASLib。然后从原始文件Mag.dat中读取数据，并创建一个名为MAGNOLIA的永久数据集，存在PLANTS库中。

   

日志窗口会出现如下说明：

NOTE: The data set **PLANTS.MAGNOLIA** has 5 observations and 6 variables.

如果在电脑中打印文件的地址目录，会发现文件名不是PLANTS.MAGNOLIA。这是因为操作系统有自己对文件命名的方式，这个文件，在Windows, UNIX和OpenVMS操作环境中名字为magnolia.sas7bdat，在OS/390或者z/OS环境中，文件名就会如LIBNAME语句中定义的data-set-name形式。

**读取永久数据集** 如果你想打印出上例中创建的数据集，可以用如下语句：

   

这次LIBNAME语句中的库名为example，但却是同样的路径，逻辑库名可以改变，但成员名MAGNOLIA却一样。输出如下：

   

 

### 2.21 通过直接指代使用永久数据集

可以通过直接指代来使用SAS数据集，且不需要自己定义，SAS为你做好。

直接指代，依据系统不同，使用方法也不同，如下：

   

可以看到，一些系统的语句中需要指出路径，但如果遗漏了路径，SAS自动使用当前路径，比如这样一个创建名为trees的永久数据集的代码：

DATA ‘trees’;

UNIX和OPENVMS操作环境下，当前的路径默认为启动SAS的路径，可以通过工具（TOOLS）下拉菜单的选项（OPTIOPN）菜单来改变这种默认，windows环境下当前路径会显示在SAS窗口底部。可以通过双击这个路径来改变默认。

**例子** 如下还是关于magnolia trees的这个例子，

   

下面的代码将从原始文件mag.dat中读取数据，创建一个名为MAGNOLIA的永久数据集，存放在C盘的Mysaslib路径中：

​        

相应的输出窗口显示如下：

NOTE: The data set c:\MySASLib\magnolia has 5 observations and 6 variables.

如果打开MySASLib文件夹，会发现一个名为magnolia.sas7bdat的文件。在没指定库的情况下，SAS会自动为你创建一个库，在资源管理器窗口中可以看到，右图是SAS为magnolia创建的库。

用直接指代读取SAS数据集可以直接用引号+路径的方式读取永久数据集，比如打印magnolia数据集可以：

 

 

   

输出窗口如下：

   

 

### 2.22 列出SAS数据集目录

由于SAS是自文档化，即在自动储存了数据集的信息，因此可以通过contents过程来查看SAS数据集的描述。

Proc contents data=data-set

如果遗漏了data=的语句，SAS自动列出最近创建的数据集。

**例子** 如下的程序创建了一个数据集，并且使用proc contents。数据步中使用了label语句，label语句为变量打上标签，并储存在数据集中，在打印时会显示。过程步中也可以使用label，但只在proc contents中有效，不会储存在数据集中。Informat和format可以指定信息和格式，储存在数据集中，也可以在过程步中使用，但不储存在数据集中。

   

输出如下：

   

输出先显示了数据集的信息，然后介绍了每个变量。

   




## 第三章 开发你的数据

### 3.1 创建并重新定义变量

可以通过分配语句来创建并重新定义变量，基本形式为：

Variable=expression

Variable是变量名，expression可以是常量、其他变量、或者数学表达式。分配语句的基本类型有：

   

Expression是数学表达式时，需要遵循运算法则，先算指数、再算乘除、之后是加减。可以用括号改变运算等级。

**例子** 如下是一个农产品估重数据，每位农民要求对他们的番茄、南瓜、豌豆、葡萄进行估重：

   

下面代码从garden.dat原始文件中读取数据，并进行修改：

   

这个程序包含了5句分配语句，第一个将14赋值给zone，第二个使type等于一个字符串常量……打印出的结果中，既包括旧变量，又包括新变量：

   

由于观测值susan的peas变量出现了缺失值，因此这个观测值的total和pertom变量也出现了缺失值。日志窗口的说明如下：

NOTE:Missing values were generated as a result of performing an operation on missing values.

### 3.2 使用SAS函数

SAS有400多个函数，主要涵盖如下领域:

   

函数基本形式：function-name(argument,argument,…)，所有的函数都需要括号，即使没有参数。下面的程序计算使用MDY函数，MDY函数需要三个参数：月、日、年。

Birthday=MDY(MonthBorn,DayBorn,YearBorn);

函数可以嵌套，即一个函数可以是另一个函数的参数。比如：NewValue=INT(LOG(10));

**例子** 有一个南瓜雕刻比赛的数据，pumpkin.dat数据包含了参赛者的名字、年龄、雕刻的南瓜类型、报名日期、五位裁判给出的分数。

   

下面的代码读取了数据、创建了两个新变量、转换了一个大小写：

   

AvgScore 使用均值函数创建的变量，计算参数的均值，这与直接相加再除以5不同的地方在于，当参数中出现缺失值时，直接相加再除的方法返回缺失值，而均值函数计算非缺失参数的均值。

DayEntered变量使用DAY函数，返回日期在一个月里的天数。

Type用大写转换函数将原来的字母转换成大写字母。

结果是：

   

 

### 3.3 选出的SAS字符函数

### 3.4 选出的SAS数值函数

### 3.5 使用IF-THEN语句

条件语句IF-THEN的基本形式为：IF 条件 THEN 执行;

比如：IF Model='Mustang' THEN Make='Ford';

条件语句中的一些基本比较符号：

   

还有IN比较符，比如这句中IF Model IN('Corvette','Camaro') THEN Make='Chevrolet';代表当Model为Corvette或Camaro的时候，将Chevrolet赋给Make。

一个条件只能有一个执行，如果要多个执行，则需要DO和END关键字。

   

可以用AND和OR来定义多个条件：IF Model='Mustang' AND Year<1975 THEN Status='classic';

   

**例子** 如下的数据包含了模型的名字、年份、制造商和颜色：

   

下面的代码从cars.dat的原始文件中读取数据，使用IF-THEN语句填满缺失值，并创建一个新变量Status

   

输出结果如下：

   

 

### 3.6 用IF-THEN语句将观测值分组

IF THEN/ELSE的一般形式为：

IF condition THEN action;

ELSE IF condition THEN action;

ELSE IF condition THEN action;

用else语句与直接用多个IF-THEN语句比起来，有两个优势，第一是更有效率，电脑将占用更少的时间；第二是else可以确保你的两个condition之间互斥。

有时候最后一个ELSE只有action，没有IF-THEN：

   

**例子** 有一个住房改善的数据，home.dat，包括了姓名、改善工作、改善成本：

   

下面的代码读取数据，并新建了一个CostGroup的变量。根据Cost的值将数据分成high、medium、low和missing三类：

   

输出结果是：

   

 

### 3.7 构造子集

IF语句可以构造子集，取数据集中的部分数据。

基本形式为：IF+expression;  比如：IF Sex='f';

如果IF条件中的数据是真，则数据步将继续执行。

还可以使用DELETE语句，来删除哪些不要的数据： IF expression THEN DELETE;

这两句话是等价的：IF Sex='f'; IF Sex='m' THEN DELETE;

**例子** 有关于莎士比亚歌剧的清单，Shakespeare.dat，包含歌剧名、首次表演年份、类型：

   

下面的代码读取数据，并且用IF语句构造一个只包含喜剧（comedies）的子集：

   

输出结果如下：

   

观察日志有时能很好的保证我们截取了我们要的数据：

   

在这个例子中，用DELETE等价的语句为：

IF Type='tragedy' OR Type='romance' OR Type='history' THEN DELETE;

### 3.8 处理SAS的日期数据

日期数据的处理很棘手，有的月份有31天、有的30天、有的28天。SAS简化的日期数据，将所有的日期转化成一个以1960年1月1日为起点的数。比如：

   

SAS处理日期数据的三个工具为：读取数据的informats，使用数据的函数（functions），打印数据的formats。

**Informats** 读取日期数据需要用formatted input。比如，如何告诉SAS用MMDDYY10. informats读取名为BirthDate的变量：

INPUT BirthDate MMDDYY10.;

**设定默认的百年** 07/04/76这样的数据可能是1976，也可能是2076、1776。因此需要YEARCUTOFF=来指定一个一百年的第一年，默认的是1920年。下面的语句就是告诉SAS将一个两位年份的日期解释为1960年到2049年之间：

OPTIONS YEARCUTOFF=1950;

**SAS****表达式中的日期** 一旦被以SAS日期格式读取之后，可以将此数据想其他数值数据一样用在表达式中。比如像为图书馆的书设定21天的还书日期，只需要在结束日期上加上21：

DueDate = CheckDate + 21;

通过在表达式中加入引号和字母D，可以将一个日期当做常数来使用，如下的代码创建了一个EarthDay05的变量，并且等于April 22,2005

EarthDay05='22APR2005'D;

函数 SAS日期函数使得操作大大简便，比如today（）返回今天的日期。

语句DaysOverDue=TODAY()-DateDue;可以计算一本书应归还的剩余期限。

**Formats**打印日期数据时，还需要将数值换成日期，下面的FORMAT语句告诉SAS用WORDATE18.格式打印变量BirthDate。

FORMAT BirthDate WORDATE18.;

**例子** 图书馆有借书卡数据，Dates.dat，包含持卡人姓名、出生日期、卡办理日期。

   

下面的代码读取数据，计算变量使用期限（expiredate），使用期限为3年；变量expirequarter计算使用期限的四分之一，使用函数QTR（）。接着用IF语句来判断一个卡是否为新卡，在2003年1月1日之后办理的，为新卡：

   

输出结果为：

   

注意BirthDate没有用日期格式。

### 3.9 可选择的Date Informats、Functions和Formats

   

   

   

 

下面是例子：

   

   

   

 

### 3.11 使用retain和sum语句

当开始数据步的每一个观测值迭代时，SAS会先将所有变量值设为缺失，再通过input和分配语句改变。Ratain和sum语句可以改变这种方式。

**Retain****语句** retain语句可以让SAS保存前一次变量的值。它可以出现在数据步的任何位置，基本形式为： 

RETAIN variable-list;

也可以指定一个初始值，而不是用缺失值或前一次的值代替初始值

RETAIN variable-list initial-value;

**Sum****语句** SUM语句用于你想将一个表达式的值累加到一个变量上去时，基本形式为：

variable+expression;

这个语句将表达式的值赋给变量，同时将变量的值保留到下一次迭代。这个变量必须是数值型，且初始值为0。因此，语句等价于如下形式：

RETAIN variable 0;

variable=SUM(variable,expression);

例子 有一个关于本赛季棒球比赛的数据，games.dat，包含比赛日期、参赛队伍、hit数据、runs数据

   

现在需要增加两个变量，一个反应本赛季的总runs数，一个反应一场比赛中最大的runs数。下面的代码用sum语句实现总run数，用retain和max函数实现最大runs数：

   

变量maxruns取前面迭代的maxruns和runs中最大值；变量runstodate将每一场比赛的runs都加到自己身上。结果如下：

   

 

### 3.12 用数组简化程序

对于太多变量要处理的程序，数组将大大简化程序。

SAS中，数组是一组变量，变量可以是已存在的，也可以是新创建的。

数组在数据步中用ARRAY来定义，基本形式为：

ARRAY name(n) $ variable-list;

Name是数组名，n是变量数，()也可以用[]和{}代替。如果变量是字符串，则需要$，且变量是新创建的字符串时，$是必须的。变量名依照顺序排列，如数组：

ARRAY store(4) Macys Penneys Sears Target;

则store(1)是Macys，store(2)是Penneys，store(3)是Sear，store(4)是Target。

数组本身不储存在数据集中，只有在数据步中才被定义。命名规则与变量一样（不超过32字节，以字母、下划线开头，只能包含字母、数字、下划线）

**例子** 广播电台wbrk做了一份关于歌曲的听众调查，对10首歌进行打分，分值在1-5，如果没听过则填9。数据文件wbrk.dat包括了被访者姓名、年龄、以及十首歌的打分。

   

下面的代码将所有打分为9的改为缺失值：

   

十首歌被放入song的数组中。输出结果如下：

   

注意这里数组没有被保存到数据集中，而i被保存了。

 

### 3.11 列出变量名的快捷方式

如果想把100个变量放入数组，并不需要一个一个变量名的输入，有快捷方式可以列出变量名。

**Number range lists** 开始于同一个单词，结尾于连续的数字的，可以使用Number range list。比如：

   

**Name range lists** 这种列表是依据变量在数据集中的排列顺序来的，比如，创建如下数据步：

   

则变量的排列顺序就为：Y A C H R

那么可以依照这个顺序用“put 第一个变量--最后一个变量”来简化：

   

如果不能确定数据集中变量的顺序，可以用proc contents的postion选项来查看。下面的代码列出了永久数据集distance的变量顺序：

   

**Special sas name list** 特别的名字列表，_ALL_、_CHARACTER_、_NUMERIC_可以用于任何你想使用的地方，所有的变量，所有的字符变量，或所有的数值变量。当你想要做某些事的时候，例如计算一个观测的数值型变量的平均值（MEAN（of _NUMERIC_）），或列出的所有观测中的变量值（PUT_ALL_;)，这些名单是有用的。

 

**例子** 广播电台WBRK想要修改前面的代码（将9改为缺失值），使用mean函数计算平均分数：

   

程序中，当原始变量（domk-ttr）值为9时，song变量值为缺失值，否则就把原始变量的值赋给song变量。另外avgscore计算平均值：

   




## 第四章 排序、打印并描述你的数据

### 4.1 使用SAS过程步

​     使用过程步就像填写一个如左图的表格，当然每个过程步都有独特的地方，本部分主要讨论各过程步相同的地方。

大部分过程步都有一个必须的语句，也有可选的语句，比如打印语句：proc print，这两个词是必须的，但可选的语句也有很多。

 

**Proc****语句** 所有的语句的必须部分为proc+过程名，比如print、contents等。后面接一些可选项。比如proc print data=banana；

data=banana选项告诉SAS打印哪个文件，如果不加，则SAS默认打印最近使用的数据。前面还可以加libname语句，建立一个对本地文件的链接（2.20），比如：

LIBNAME tropical 'c:\MySASLib';

​       PROC CONTENTS DATA=tropical.banana;

或者直接引用（2.21）：PROC CONTENTS DATA='c:\MySASLib\banana';

 

**BY****语句** BY语句只在过程proc sort中是必须的，它用来对观测值排序。其他过程BY告诉过程对变量进行分别分析，且是可选的。比如要对每个州进行分别分析，则为：BY State

另外，除了proc sort，其他过程都假设了数据已经进行了排序，所以如果数据还没有排序，那么在分析之前要用proc sort排序。

 

**TITLE** **和****FOOTNOTE****语句** 这是为输出加上标题和脚注。最基本的title语句为：title ‘标题’，双引号、单引号皆可，比如：

TITLE 'This is a title';

如果标题中带有撇号，则需用双引号，或者将撇号换为双撇号：

TITLE ”Here’s another title”;

TITLE ’Here’’s another title’;

可以通过在title、footnote后面加上数字来添加多个标题和脚注：

FOOTNOTE3 ’This is the third footnote’;

但是小数字的标题会代替大数字的标题，如title2会代替title3。

标题的去除可以用title+空值：TITLE; footnote+空值：footnote;

 

**Label****语句** 它可以为输出的变量加上标签，一个标签最大256字节，下面的代码为receivedate和shipdate创建了标签：

LABEL ReceiveDate=’Date order was received’

ShipDate=’Date merchandise was shipped’;

注意的是，在数据步中使用label语句，则标签会保存在数据集中；在过程步中使用，标签只在这个过程中有效。

 

**定制输出** 使用系统选项，可以为输出设置诸如居中、日期、单行长度、页长度等。使用Output Delivery System，还可以改变输出的风格，以不同的格式输出（HTML、RTF），甚至改变输出的任何细节。

 

**输出数据集** 可以用ODS OUTPUT语句为输出结果创立一个数据集（5.3），一些过程中也可以用out=option。

 

### 4.2 用where语句在过程中构造子集

也可以用where构造子集，它方便快捷，因为他不创建新的数据集。且能够用在过程步中。

Where语句的基本形式为：

WHERE condition;

只有满足条件的观测值才进行proc过程。

一些使用最多的操作符及例子：

   

**例子** 有一份关于画家的数据，artists.dat，包含画家的姓名、主要风格、国籍：

   

第一步首先是数据步，读取数据、使用直接指代在C盘mysaslib目录下创建一个名为style的数据集。

   

某天如果想打印出印象派impressionism画家的情况，那么可以使用where语句

   

输出结果为：

   

 

### 4.3 用proc sort为数据排序

基本形式为：

PROC SORT;

​           BY variable-1...variable-n;

SAS首先会按照第一个变量排序，再对后面的排序。

Data=，out=用来指定输入和输出数据，如果缺失out=，则SAS会将排序后的数据集代替原来的数据集。下面的代码告诉SAS对数据messy排序，并将排序后的数据存在neat中：

PROC SORT DATA=messy OUT=neat;

选项nodupkey告诉SAS排序时删除重复值，比如：

PROC SORT DATA=messy OUT=neat NODUPKEY;

SAS默认是升序，可以用选项DESCENDING来变成降序，将DESCENDING加在要降序的变量前面：

BY State DESCENDING City;

**例子** 下面的数据显示了一些鲸鱼和鲨鱼品种的平均长度：

   

下面的代码读取并排序数据

   

输出结果为：

   

因为SAS认为缺失值是比字符串和数值都小，所以排在了第一位。另外，由于whale shark 40的数据有两个，故因为nodupkey选项而被删除一个。说明可见日志：

   

 

### 4.4 用proc print打印你的数据

基本形式：PROC PRINT;

SAS默认打印最近使用的数据集，DATA=可以指定数据集：

PROC PRINT DATA=data-set;

SAS默认打印观测值数，noobs选项可以取消。SAS默认打印时用变量标签代替变量，用label可以改变取消：

PROC PRINT DATA=data-set NOOBS LABEL;

还有下面的选项：

BY variable-list; 前提是数据必须进行排序

ID variable-list; 指定观测变量

SUM variable-list; 打印变量总数

VAR variable-list; 指定打印哪部分变量以及打印顺序，默认打印全部。

 

**例子** 有学生卖糖果的数据，Candy.dat，记录学生名、所属班级、销售日期、卖的糖果类型、卖出的糖果数。

   

下面的程序读取数据、计算每个学生赚得的利润（每买一块赚1.25美元），并用proc sort按班级排序。接着在proc print语句中加入by，以分班级打印，加入sum，计算每个班级总利润：

   

输出结果为：

   

 

### 4.5 用formats改变打印外观

打印数据时，SAS会自动为你安排最好的格式，小数点位数、空格等。

当不需要默认格式时，可以用SAS formats改变打印的外观。

对于字符串、数值、日期变量，SAS有很多格式。比如可以用commaw.d格式打印有逗号的数字，用$w.格式控制打印的字符数，用MMDDYYw.格式将日期（以1960.1.1为基点的数字）打印成12/03/2003这样的格式。甚至可以将格式打印成十六进制、区位十进制、压缩十进制等。

SAS格式的普通形式为：

   

符号说明：$说明了是字符串、format是格式名、w是包括在小数点在内的长度、d是小数位数。句号非常重要，它用来区分格式名和变量名。

 

**Format****语句** 可以用format语句同时将格式和变量联系起来，用format+变量名+格式名，比如想要将格式DOLLAR8.2和变量profit、loss联系起来，把格式MMDDYY8.和格变量saledate联系起来：

FORMAT Profit Loss DOLLAR8.2 SaleDate MMDDYY8.;

Format可以用在数据步和过程步中，前者将把格式永久储存，后者只是临时储存。

注：DOLLAR8.2表示打印的结果字符数不超过8（数值+$）。

 

**Put****语句** 当写原始数据或者报告时，也可以在put语句中使用formats，在每个变量后面加上格式：

PUT Profit DOLLAR8.2 Loss DOLLAR8.2 SaleDate MMDDYY8.;

 

**例子** 在上面的学生卖糖果的案例中，可以看到输出的日期是SAS日期值，这里用format变换成日期格式，并且用DOLLAR6.2将利润换成货币格式，

   

输出结果为：

   

 

### 4.6 可供选择的formats

   

   

下面是

​      

 

### 4.7 使用proc format创建自己的格式

有时候用数字代表实际的变量值，比如1代表男性，2代表女性，这种代码在打印的时候不好解读，可以用proc format使得打印出想要的值。

基本形式为：

   

Value语句中的name是格式的名字，如果格式是位字符串设计，则必须以$开头，长度不能超过32个字节（包括$），不能以数字结尾，除了下划线不能包含其他任何特殊符号。且名字不能与已有的格式名冲突。Range是分配给等号右边文本的变量值，文本可以达到32767个字节，有的过程只会打印前面8或16个字节。下面是一个例子：

   

变量值是字符串时要加上引号，range不止一个值要用逗号隔开，连续的range要用-，关键字low和high可以用来指代变量中最小和最大的非缺失值。也可以用<来排除或指代某些范围，但"<"来表示不包括范围的结尾值。other可以给任何没有列在value语句中的变量分配格式。

 

**例子** 有一份关于汽车公司客户的调查信息。包括客户年龄、性别（1为男性，2为女性）、每年收入、偏爱的汽车颜色（yellow,gray,blue,or white）：

   

下面的代码读取数据，并使用format过程为颜色、性别和汽车创建格式，并在打印数据时用format为变量指定这些输出格式：

   

输出结果为：

   

 

### 4.8 定制一个简单的报告

数据步可以帮助在报告中完成一些个性的需求，比如一页打印一个观测值等。

用file语句和put语句 ，基本形式为：

FILE‘file-specification’PRINT;

如input，put语句也有list，column，formatted方式，但因为SAS已经知道变量类型，因此不用符号$。且如果使用list，SAS会自动在两个变量之间加上空格；使用column或者formatted，SAS将会把变量放在任何你指定的地方。使用指示器@n指定移动到第n列，+n指定移动n列，/跳动到下一行，#n跳动到第n行。用@hold住当前行。

 

**例子** 再一次使用学生卖糖果的案例，Candy.dat，记录学生名、所属班级、销售日期、卖的糖果类型、卖出的糖果数。

   

老师想看每位学生的销售情况，故要每页分别打印一位学生的情况，代码如下：

   

   

Data _null_是告诉SAS不要写数据集名，以便使得程序更快。File语句创建了一个输出文件，空标题title语句告诉SAS去除所有的自动标题。

第一个put语句以一个指示器开头，@5，告诉SAS移动到第5列，接着打印出“candy sales report for”，后面是姓名name。变量name、class和quantity都是以list方式打印，而profit是使用formatted方式打印，并给定格式dollar6.2。一个斜杠是指跳到下一行，两个斜杠是跳到下两行。最后，语句put_page_是在每个学生报告下面插上页码，程序运行后，日志说明如下：

   

前三页报告如下：

   

   

   

 

### 4.9 使用proc means描述数据

可以用proc means查看一些简单的统计量，Means过程开始于关键词proc means，后面接需要打印的统计量，基本形式：

PROC MEANS options;

如果不加选项，则默认打印出非缺失值个数、均值、标准差、以及最大最小值，下面是用选项可以查看的统计量：

   

如果没有其他语句，proc means语句会给你数据集中所有观测值和所有数值变量的统计量，这里是一些可以用到的语句：

l  BY variable-list; 分变量单独分析，但数据必须先按照variable-list的变量顺序排序（proc sort）。

l  CLASS variable-list; 也是分变量单独分析，看起来会更集中一些，且不需要排序。

l  VAR variable-list; 指定分析中使用哪种数值变量，默认则使用所有的数值变量。

 

**例子** 有一个花朵销售的数据，Flowers.dat，包括顾客ID，销售日期，petunias，snapdragons，marigolds三种花的销售量：

   

下面的代码读取数据，计算新变量销售月份month，并使用proc sort按照月份排序，并使用proc means的by语句来按照月份描述数据：

   

输出结果为：

   

 

### 4.10 将描述性统计写入SAS数据集中

有两种方法可以在SAS数据集中储存描述性统计量，Output Delivery System(ODS)，或者output语句。前者在5.3，后者的基本形式为：

OUTPUT OUT=data-set output-statistic-list;

Data-set是要储存结果的数据集名，output-statistic-list则界定需要保存哪些统计量和名称，可能的形式为：

statistic(variable-list)=name-list

statistic可能是proc means语句中的任何一种统计量（sum，n，mean…），variable-list则界定VAR语句中哪些变量需要输出，name-list则定义统计量的新名字。比如，proc means语句产生了一个数据集ZOOSUM，包括一个观测值和变量lionweight（the mean of the lions’ weights），BearWeight（the mean of the bears’ weights）。

   

Noprint是告诉SAS不需要产生任何打印结果，因为已经将结果存入数据集中。

 

**例子** 仍然是花朵销售的数据

   

要描述数据，每个顾客只有一个观测值，包括SUM和MEAN，并且将结果储存到数据集中以便日后分析。下面的程序读取程序，按照CustomerID排序，使用means过程，结果存在totals数据集中。以原始名Petunia,SnapDragon,Marigold给出sum，以新变量名MeanPetunia,

MeanSnapDragon,and MeanMarigold给出mean。

   

结果如下：

   

 

### 4.11 用proc freq为数据计数

对一个变量计算频数叫做one-way，两个叫做two-way，多个叫做交叉表。使用proc freq最明显的目的是现实分类数据的分布情况，基本形式为：

PROC FREQ;

​      TABLES variable-combinations;

产生一维频率表，只要列出变量名。下面的语句列出了变量yearseducation的每一个值的个数。

TABLES YearsEducation;

建立两个变量的交叉表需要一个*号，下面的语句显示变量Sex by YearsEducation的频数情况：

TABLES Sex*YearsEducation;

这个语句之后可以用/option的形式添加选项，主要下面几个：

LIST：用list形式打印交叉表（而不是网格）

MISSING：频率统计量中包含缺失值

NOCOL：强制在交叉表中不打印列百分比

NOROW：强制在交叉表中不打印行百分比

OUT=data-set：输出数据集

比如说，使用第二个选项：TABLES Sex*YearsEducation/MISSING;

 

**例子** 有一家咖啡店的销售数据，记录了销售的咖啡种类（cappuccino,espresso,kona,or iced coffee），以及每次购买的顾客是打包还是原地就饮：

   

下面的代码就产生了一个one-way和two-way的频率表：

   

代码告诉SAS打印两个表，一个是one-way的频率表，一个是交叉表。交叉表的每个小方格内，SAS打印了频数、百分比、行百分比和列百分比。左边和右边是累积百分比。注意计算频数时没有考虑缺失值。

   

 

### 4.12 用proc tabulate产生一个表格报告

比起print means和print freq，Proc tabulate过程产生的报告更耐看。

Proc tabulate的基本形式为：

PROC TABULATE;

CLASS classification-variable-list;

TABLE page-dimension,row-dimension,column-dimension;

Class语句告诉SAS哪些变量将数据分成不同部分。

Table语句可以定义一个表，可以用多个table语句定义多个表，

 

**维度** table语句可以在报告中指定三个维度：页、行、列。如果只指定一个维度，则默认是列维度；如果指定两个，则是行和列。

 

**缺失数据** 默认下不考虑缺失数据，在proc语句后面增加missing选项可以改变这种默认：

PROC TABULATE MISSING;

 

**例子** 有关于船的一些数据，Boats.dat，记录了每艘船的姓名、港口、移动方式（sailing或者power vesse），类型（schooner,catamaran,or yacht），使用它远行的价格

   

你想得到一份报告，包含了每一个港口的、sailing或者power vessel的、每一种类型的、船的数量，下面的代码用proc tabulate创建了一个三维报告：港口作为页、移动方式作为行、类型作为列：

   

报告分两页，港口的每个值情况为一页：

   

 

### 4.13 为proc tabulate输出增加统计量

Class语句列出分类变量，而VAR语句告诉SAS那些变量包含连续数据。基本形式为：

PROC TABULATE;

VAR analysis-variable-list;

CLASS classification-variable-list;

TABLE page-dimension row-dimension column-dimension;

 

**关键词** 下面是tabulate可以计算的值：

ALL:增加行、列或页，显示总数

Max：最高值

Min：最低值

Mean：算术均值

Median：中位数

N：非缺失值个数

Nmiss：缺失值数

P90：90th分位数

Pctn：某类的观测值百分数

Pctsum：某类值总和的百分数

STDDEV：标准差

SUM：求和

 

**Concatenating,crossing,and grouping** 一个维度中，变量或关键词可以被连接、交叉、分组。连接变量或关键词，只需用空格分开列出即可；变量或关键字交叉只需要用*分开列出即可；分组只需要用括号括住变量或关键词。

Concatenating:                          TABLE Locomotion Type ALL;

Crossing:                               TABLE MEAN*Price;

Crossing,grouping,and concatenating:        TABLE PCTN*(Locomotion Type);

 

**例子** 仍然是船的例子，

   

下面的代码类似4.12，但多了VAR语句，table只包括两维，但使用了Concatenate,cross,and group：

   

输出结果如下：

   

 

### 4.14 提升proc tabulate的输出外观

三种方式可以提升输出的外观：

**Format=** **选项** 可以改变数据的格式，比如，在表中使得数字有逗号，并不含小数，则使用：

PROC TABULATE FORMAT=COMMA10.0;

**Box=****和****misstext=** **选项** format只能用在proc语句中，而box=和misstext=只能用在table语句中。box=的作用是在tabulete报告的左上角的空格中写下一句简洁的语句（作用类似标题）。Misstext则是为空数据格指定一个值，默认是一个句号，比如下句：

TABLE Region,MEAN*Sales/BOX='Mean Sales by Region' MISSTEXT='No Sales';

这是告诉SAS在左上角打印“Mean Sales by Region”，并且在没有数据的方格内打印“No Sales”

 

**例子** 仍然是船的数：

   

如下代码比前面多了format、box、misstext语句。注意format要出现在proc语句中，而box和misstext语句则出现在table语句中。

   

这是“被提升了的”外观，由于format指定dollar9.2，因此都用货币格式输出。左上角的full day excursions是由于box语句，空方格内的none是由于misstext语句。

   

 

### 4.15 改变proc tabulate输出的表头

有两种方法可以改变顶部信息

**Class** **变量** **变量值** 要改变class语句列出的变量值的表头，使用format创建一个用户定义的格式，然后用format语句将格式赋给变量。

**变量名和关键字** 改变变量名和关键字的表头，用=’text’赋值即可，可以用等号加空值的方法去除表头，即=’’，语句为：

TABLE Region='',MEAN=''*Sales='Mean Sales by Region';

这是告诉SAS移去region和mean的顶部，并且将sale的表头换为“Mean Sales by Region”

有时候当行顶部被赋为空格时，会留下一个空白空格，可以用row=float强制去除这种空白空格：TABLE MEAN=''*Sales='Mean Sales by Region',Region=''/ROW=FLOAT;

 

**例子** 仍然是船的数据：

   

下面的代码和以前一样，多了对表头的改变，format语句创建了一个用户定义的格式$typ，并用format语句把这个格式赋给变量type，table语句中locomotion、mean、type的表头被赋为空格，price的表头被赋值“Mean Price by Type of Boat.”

   

输出结果为：

   

这样的结果看起来清晰且紧凑。

 

### 4.16 为proc tabulate输出的数据方格指定多种格式

可以为不同变量指定不同格式，基本形式为：

variable-name*FORMAT=formatw.d

比如在table语句中插入这个复杂的语句：

TABLE Region,MEAN*(Sales*FORMAT=COMMA8.0 Profit*FORMAT=DOLLAR10.2);

这是给变量sales指定格式comma8.0，给变量profit指定格式dollar0.2。

 

**例子** 仍然是船的数据，新增加了一个变量，以显示船的长度：

   

假如你想在报告中同时show出平均价格和平均长度，仅为价格指定货币格式。下面的代码这样实现，为变量price指定格式dollar6.2，为length指定格式6.0：

   

输出结果如下，注意价格和长度的格式不一样：

   

 

### 4.17 用proc report产生一个简单的输出

Report包含print、means和tabulate、sort的所有功能，可以用一本书来介绍，基本形式为：

​      PROC REPORT NOWINDOWS;

COLUMN variable-list;

Column语句类似于proc print的var语句，告诉SAS哪些变量该包括并以何种顺序，如果遗漏语句column，SAS默认在数据集中包括所有变量，如果遗漏选项NOWINDOWS，SAS默认启用交互report窗口。

默认情况下，PROC报告立即在列标题下方打印数据。为使数据和顶部能很好的区分开来，可以使用headline和headskip：

PROC REPORT NOWINDOWS HEADLINE HEADSKIP;

Headline在顶部下面拉了一条线，headskip在顶部下面留了一段空白。

 

**数值变量****VS****字符串变量** 从proc report得到的报告类型，部分依据于使用的数值类型。只要报告中起码有一个字符串变量，默认的报告就是每个观测值一行。但如果报告全是数值变量，默认proc report将会加总这些变量，即使是日期变量也会被加总。

 

**例子** 有一份关于美国国家公园（national parks）和国家纪念碑（monuments）的数据，Parks.dat，变量包括名字、类型（NP for national park or NM for national monument），地区（East or West），博物馆的数量，野营地的数量：

   

下面的代码形成了两份报告，第一份没有column语句，SAS使用所有变量，第二份使用column语句，选择部分变量：

   

第一份报告与proc print相似，第二份报告，由于只选择museum变量和camping两个数值型变量，默认直接显示加总情况：

   

 

### 4.18 在proc report中使用define语句

Define用来为单个变量指定一些选项，基本形式为：

DEFINE variable/options’column-header’;

 

**Usage****选项** 这个选项告诉SAS如何使用这个变量，可能的usage选项包括：

Across：为变量的每一个变量值都创建一个列

Analysis：为变量创建统计量，数值变量默认有这个usage选项，且统计量默认为sum。

Display：为数据集中的每一个观测值都创建一行，对于字符串变量，这个选项是默认的。

Group：为每个变量的变量值都创建一行。

Order：为每个观测值都创建一行，且行值的排列是按照指定的变量来顺序。

 

**改变列表头** proc report中几种方法可以改变列表头，4.1中的label语句，或者用define语句指定列表头，下面的代码使得SAS的report按照age排序，并且以“Age at Admission”作为列顶部：

DEFINE Age / ORDER 'Age at/Admission' WIDTH=9;

您可能需要指定的width选项，使您的列表头适合它。在这个例子中，Admission这个词有9个字符，所以宽度必须至少为9。

 

**缺失数据** 默认在order，group，和across variables中不考虑缺失值，用missing选项可以改变这种默认：

PROC REPORT NOWINDOWS MISSING;

 

**例子** 仍然是关于国家公园和纪念碑的数据：

   

下面的代码包含两个define语句，第一个用order选项来定义region，第二个为变量camping定义列表头。Camping是一个数值变量，默认有analysis选项。Missing选项也出现在了proc语句中，因此缺失值也会被考虑在报告中：

   

输出结果为：

   

Region有三个变量值，第一个是missing缺失值。

 

### 4.19 用proc report创建简易报告

Group创建简易行，across创建简易列。

 

**Group** **变量** 下面的代码告诉SAS创建一个显示每个部门工资总和、奖金总和（数值变量将默认被加总）的报告：

   

 

**Across****变量** 为了定义acorss变量，也需要define语句，不同的是，SAS默认不是对变量值求和，而是计数。如果要加总，则需要在across变量和analysis变量之间加逗号，告诉SAS哪个变量要加总，下面的代码告诉SAS用列来显示出每个部门工资和奖金的总和：

   

 

**例子** 仍然是国家公园和纪念碑的例子，

   

下面的代码包含两个proc report，第一个中，region和type都被定义成group变量，第二个中，region仍然是个group变量，但type是across变量。注意两个column语句基本一样，除了第二个中增加了逗号将across变量和analysis 变量交叉。

   

输出结果为

   

 

### 4.20 给proc report输出增加summary break

Break语句可以为报告增加停顿，为每个指定的变量的变量值增加停顿。基本形式如下：

​     BREAK location variable/options;

RBREAK location/options;

Location有两种可能值——before和after，决定是之前停顿还是之后停顿。斜杠之后的选项告诉SAS插入哪种停顿，主要类型有：

OL        停顿的地方加入横线

Page       开始一个新的页面

Skip       插入一个空行

Summarize  插入数值变量之和

UL         在停顿下面划线

需要注意的是，break要求指定一个变量，而rbreak不需要。因为rbreak只产生一个停顿（开始或结尾），而break语句为指定的变量的每一个变量值都产生停顿。这个变量必须是group变量或order变量，并且要在define语句中定义过。可以在任何报告中使用rbreak语句，但只能在有最起码一个group或者order变量的报告中使用break语句。

 

**例子** 仍然是国家公园和纪念碑的例子：

   

下面的代码将region定义为order变量，使用break和rbreak语句和after选项，summarize加总数值变量的和：

   

输出结果为：

   

 

### 4.21 为proc report输出增加统计量

简单的方法是在column语句中加入统计量的关键字，常用的有：

Max、min、mean、median、n、nmiss、p90、pctn、pctsum、std、sum

 

**给变量应用统计量** 给变量应用统计量，在变量和统计量之间插入逗号即可，统计量N不需要逗号。如：

COLUMN Age, MEDIAN N;

为多个变量应用多个统计量，需要括号，如下面代码要求一个变量age应用两个统计量min和max；两个变量height和weight应用一个统计量mean：

COLUMN Age, (MIN MAX); (Height Weight),MEAN;

**例子** 仍然是国家公园和纪念碑的数据：

   

下面的代码包括了两个proc report，都应用了统计量N和mean，但第一个定义type为group变量，第二个定义type为across变量。

   

输出结果为：

   




## 第五章 用ODS增强你的输出结果

### 5.1 ODS（Output Delivery System）的概念

过程步不会产生输出，它只会产生数据，然后把数据发送给ODS，以决定输出的样式等。所以，不要考虑是否使用ODS，而考虑怎么使用，是接受默认输出还是改变设置。

ODS就像一家商务飞机，游客乘坐car和bus赶来，在机场确认行李、安检、最终登机，飞往目的地。ODS中，数据就像游客，通过各种过程步而来，ODS处理每一个数据集并发送到目的地。实际上，不同的ODS类型就是目的地，当达到目的地时，数据的样式是由模板决定。模板是一个告诉ODS如何格式化您的数据的指令集。目的地和模板这两个概念的是你了解可以用ODS做什么的基础。

 

**目的地** 如果没有指定目的地，那么你的数据默认发往“列表listing”，这里有几种可选的目的地：

LISTING   标准SAS输出

Output     SAS输出数据集

Html      超文本标记语言

RTF       富文本格式

PRINTER  高分辨率的打印机输出（PS, PCL, and PD）

PS        附言

PCL       Printer Control Language 打印机控制语言

PDF       Portable Document Format

MARKUP  markup languages including XML

DOCUMENT output document

 

**风格和表模板** 模板描述ODS如何制定数据格式并呈现数据。最普通的两个模板类型和是表模板类型和风格模板类型。表模板类型制定基本的输出结构，而风格模板类型制定输出将如何呈现。ODS将过程产生的数据和表模板结合成输出对象，输出对象接着与风格模板结合，并发送到目的地，创建输出。

   

可以使用template过程创建自己的风格模板，但proc template过程晦涩难懂。幸运的是，有一个最简单和最快速的方法控制修改输出，即使用内置风格模板。可用proc template语句来访问内置模板：

 

​        PROC TEMPLATE;

​     LIST STYLES;

RUN;

一些内置模板如下：

   

注意RTF和PRINTER既是目的地名又是风格名。DEFAULT是HTML的默认风格，RTF是RTF输出的默认风格，PRINTER是PRINTER的默认风格。

Print、report、TABULATE三个过程中，可以使用style=option来直接控制输出特征，而不需要创建一个新的模板。

 

### 5.2 追踪选择过程的输出

​     当ODS接受来自过程步的数据时，它将数据与表模板结合。对应的表模板和数据就叫做输出对象。如果使用by语句，SAS会为每一个BY组产生一个输出对象。每一个输出对象都有名字，可以用ODS TRACE语句来查找，并用ODS SELECT语句来选择。

 

**ODS TRACE****语句** ODS TRACE语句告诉SAS打印出SAS日志中输出对象的信息。这里有两个ODS TRACE的语句，一个是打开trace，一个是关闭。使用方法实例如下：

   

注意关闭语句要在run后面，否则在程序运行之前就关闭了trace。

 

**例子** 有关于番茄种类的数据，包括每种番茄的名字、颜色、从播种到收获的天数、典型重量：

   

下面代码创建了一个名为giant的数据集，并使用ODS TRACE ON和ODS TRACE OFF语句来追踪proc means过程。

   

程序运行后，日志窗口中就会有如下的追踪（由于使用了BY语句，故按照BY的组来追踪）：

   

 

**ODS select****语句** 知道输出对象的名字之后，可以用ODS SELECT语句来选择需要的输出对象。基本形式为：

   

Output-object-list是名字、标签、一个或更多的输出对象的路径。

 

**例子** 下面代码对giant运行了proc means，并用ODS SELECT语句选择了第一个输出对象，mean：

   

输出结果为：

   

 

### 5.3 从过程输出中创建SAS数据集

​     有时需要把一个过程的结果弄到SAS数据集中，有的过程用output或out=实现。但用ODS，可以储存从过程输出的任何一部分。首先要使用ODS TRACE语句决定选择输出对象名。然后使用ODS OUTPUT语句将输出对象发送到OUTPUT目的地中。 

 

**ODS OUTPUT****语句** 基本形式为：

ODS OUTPUT output-object=new-data-set;

这个语句不属于数据步和过程步。ODS OUTPUT打开SAS数据集并等待正确的过程输出，数据集保持开放，直到过程步的结尾。因为ODS OUTPUT是立即执行的，它将应用于proc正在处理的数据，或者应用于下一个proc（如果目前没有proc）。为确保得到正确的输出，建议将ODS OUTPUT语句放在PROC语句之后，下一个PROC 、DATA或RUN语句之前。

 

**例子** 仍然是关于番茄的数据：

   

下面是引用与SAS日志，显示由proc tabulate产生的追踪（trace），tabulate产生一个叫做table的输出：

   

下面的代码读取数据、使用ODS OUTPUT语句来创建叫做TABOUT（来自TABLE输出对象）的SAS数据集，然后用proc print打印出新数据集。

   

有两部分输出结果，第一部分是标准tabular结果，有proc tabulate产生。下面是TABOUT数据集，由ODS OUTPUT语句产生，并有proc print打印。

   

 

### 5.4 使用ODS语句创建HTML输出

将输出发送到HTML目的地，将得到HTML格式的文件。这个文件也可以被读入spreadsheets，甚至被打印或导入到文字处理软件中（有些格式会发生变化）。总之，产生一个HTML文件只需两步语句——打开HTML文件、关闭。

**ODS****语句** 将输出发送到HTML目的地，使用ODS HTML语句，基本形式为：

ODS HTML BODY='body-filename.html' options;

Option是用来改变HTML的类型(contents,page,or frame)，

l  Contents=   contents文件是一个链接到主体文件的一个目录表，它将会列出输出的每个部分，点击表中某个条目，相关输出会出现。

l  Page=       page文件类似于contents文件，不同的是，contents通过标签列出输出的每个部分，而page文件通过页码列出。

l  Frame=      frame允许同时访问在不同区域、框架或浏览器窗口中，访问主体文件、contents文件和page文件。

l  Style=       这个选项允许指定一个风格模板，默认的模板名为default。

下面的语句告诉SAS发送一个输出给HTML目的地，储存一个名为AnnualReport.html的主体文件，并使用D3D风格。

ODS HTML BODY='AnnualReport.html' STYLE=D3D;

ODS 语句不属于数据步也不属于过程步，摆放它的好位置是proc过程步之前，这个过程步的输出正是你希望捕捉的。

关闭HTML文件的ODS语句为：

ODS HTML CLOSE;

将这个语句放在proc之后，接在 run语句之后。

输出中包括有些程序（如PROC means和PROC FREQ）过程的名称。您可以使用ODS NOPROCTITLE语句删除程序名称，该语句可放在data步之前。

ODS NOPROCTITLE;

 

**例子** 下面的数据是关于选择的鲸鱼或鲨鱼的平均长度（英尺）

   

下面的代码创建了两个输出，一个是来自means过程，一个来自print过程。并且有两个ODS语句，一个创建了四个HTML文件：body,contents,page,and frame，一个是关闭HTML文件。

   

输出结果如下：

   

 

### 5.5 使用ODS语句创建RTF输出

当你创建了富文本格式，可以将其发送到word中，并像word表格一样编辑修改。语句与HTML语句差不多，区别在于option：

**ODS****语句** ODS打开RTF文件的基本形式为：

ODS RTF FILE='filename.rtf' options;

不像HTML，RTF文件只有一种类型，一些option如下：

l  COLUMNS=n  要求一个柱状输出，n是第几列。

l  Bodytitle

l  Sasdate      这个选项告诉SAS当前的SAS会话开始运行时，使用日期和时间。

l  Style=       指定一个风格模板

下面的代码告诉SAS将输出发送到RTF目的地，储存一个名为AnnualReport.rtf的主体文件，并使用FANCYPRINTER风格。

ODS RTF FILE='AnnualReport.rtf' STYLE=FANCYPRINTER;

放置这个代码的较好位置也是在proc之前，而关闭语句也是放置在proc语句之后，接在run之后。

ODS RTF CLOSE;

 

**例子** 仍然是鲸鱼和鲨鱼平均重量的数据：

   

如下的代码从means和print中产生输出，程序中有两个ODS语句，一个打开RTF文件，一个关闭RTF文件。

   

Marine.RTF文件在word中的结果如下，每一部分的输出结果在不同页面中出现：

   

   

 

### 5.6 使用ODS创建printer输出

**ODS****语句** 打开printer目的地的ODS语句最基本形式为：

ODS PRINTER;

如果使用这个简单的语句，SAS将创建你先在系统需要的输出类型，并自动打印输出，而不是储存文件。可以用add=option来储存输出。类似RTF，只有一种PRINTER类型文件。创建指定的输出类型的基本形式如下面几种：

l  Default printer:      ODS PRINTER FILE='filename.extension'options;

l  PCL:              ODS PCL FILE='filename.pcl'options;

l  PDF:              ODS PDF FILE='filename.pdf'options;

l  PostScript:          ODS PS FILE='filename.ps'options;

目的地一些有效的选项如下

l  COLUMNS=n    要求一个柱状输出，n是第几列。

l  STYLE=         指定一个风格模板

下面的代码告诉SAS创建PostScript output，将结果存在AnnualReport.ps中，并使用FANCYPRINTER风格。

ODS PS FILE='AnnualReport.ps' STYLE=FANCYPRINTER;

放置它的位置也是在proc之前。关闭一个printer文件 ODS语句基本形式为;

ODS destination-name CLOSE;

destination-name可能是PRINTER,PCL,PDF,或者 PS，视开启语句中的目的地而定。放置在proc的run语句之后。

 

**例子** 仍然是鲸鱼和鲨鱼平均重量的数据：

   

如下的代码从means和print中产生输出，程序中有两个ODS语句，一个打开PDF文件，一个关闭PDF文件。

   

在Adobe Acrobat中的输出结果如下，每一部分的输出结果在不同页面中出现：

   

   

 

### 5.7 定制标题和注脚

通过在在title和footnote语句中插入一个简单的选项，可以改变注脚和标题的样式，title和footnote语句的基本形式为:

TITLE options 'text-string-1' options 'text-string-2'…options 'text-string-n';

FOOTNOTE options 'text-string-1' options 'text-string-2 '…options'text-string-n';

可以将一段文字分成不同的部分，每个部分应用不同的样式，可以选择的主要选项如下表：

l  COLOR=   为文本指定一种颜色

l  BCOLOR=  为背景指定一种颜色

l  HEIGHT=   为文本指定高度

l  JUSTIFY=  要求对齐

l  Font=      为文本指定字体

l  Bold       粗体

l  ITALIC    斜体

 

**颜色**  为一段文本不同部分指定不同的颜色

 TITLE COLOR=BLACK 'Black' COLOR=GRAY 'Gray' COLOR=LTGRAY 'Light Gray';

显示为：

   

SAS支持几百种颜色，但有的不能被web等识别，所以安全的颜色为: BLACK,BLUE,

BROWN,CHARCOAL,CREAM,CYAN,GOLD,GRAY,GREEN,LILAC,LIME,MAGENTA,MAROON,OLIVE,ORANGE,PINK,PURPLE,RED,ROSE,SALMON,STEEL,TAN,VIOLET,WHITE,and YELLOW.

 

**背景颜色** 下面是用十六进制码来指定背景颜色：

TITLE BCOLOR='#C0C0C0' 'This Title Has a Gray Background';

显示为：

   

 

**高度** 下面设置高度：

TITLE HEIGHT=12pt 'Small' HEIGHT=.25in 'Medium' HEIGHT=1cm 'Large';

单位分别为像素、英尺、厘米，显示为：

   

**对齐** 下面分别设置左对齐、居中、右对齐：

TITLE JUSTIFY=LEFT 'Left' JUSTIFY=CENTER 'vs.' JUSTIFY=RIGHT 'Right';

显示为：

   

**字体** 示例：

TITLE 'Default' FONT=Arial'Arial'

FONT='Times New Roman' 'Times New Roman' FONT=Courier'Courier';

显示为：

   

**加粗与斜体** 默认下，标题是加粗且斜体的。关闭粗体和斜体要用FONT=option，示例：

TITLE FONT=Courier'Courier'

BOLD'Bold'BOLD ITALIC'Bold and Italic';

显示为：

   

 

### 5.8 用style=option定制proc print输出

用ODS中的style=option可以改变输出的整体外观，但是如果要只改变头部，或者其中一列，要在print、report和tabulate过程中用style=option。

Proc print语句中使用Style=option的基本形式为：

PROC PRINT STYLE(location-list)={style-attribute=value};

location-list说明了表中的哪一部分将应用风格，style-attribute是要改变的风格属性，value是属性值。下面的代码将data部分的background属性设为pink：

PROC PRINT STYLE(DATA)={BACKGROUND=pink};

下面是可以指定改变风格的部分：

DATA           所有的数据单元

HEADER        列标题（变量名）

OBS            OBS列，或者ID列（如果使用ID语句）的数据

OBSHEADER    OBS列或ID列的标题

TOTAL         有sum语句产生的总和行的数据

GRANDTOTAL   

在print中放置style=改变的是全表。比如header会改变全表的头部，如果只想改变某列的头部，需要在VAR语句中使用style：

VAR variable-list/STYLE(location-list)={style-attribute=value};

仅有variable-list中的变量会被改变风格。想要不同的变量有不同的风格，可以使用复合VAR语句。

 

**例子** 下面是关于女子5000米滑冰奥运会金牌获得者的数据，变量依次为：奥运年年份、国家、时间、比赛记录（有WR的表示是世界记录）。

   

下面的代码用proc print创建了HTML文件，使用的是默认风格模板。

   

结果如下：

   

下面的代码使用了style来改变所有数据单元的背景：

   

结果如下：

   

下面的代码增加VAR语句，将record列的字体改为斜体和粗体：

   

结果为

   

 

### 5.9 用style=option定制proc report输出

与5.8类似，基本语句为：

PROC REPORT STYLE(location-list)={style-attribute=value};

比如，如果想创建一个名为MYSALES的报告，并将列标题设置为绿色：

PROC REPORT DATA=mysales STYLE(HEADER)={BACKGROUND=green};

如果只需要改变报告中的某一列属性，则需要define语句，下面的语句告诉SAS使用month作为组变量，将其数据和标题的背景改为蓝色：

DEFINE Month/GROUP STYLE(HEADER COLUMN)={BACKGROUND=blue};

还可以用break和rbreak语句为摘要（summary）指定一个风格。下面的语句告诉SAS，对于month的每一个值，为摘要使用红色背景，为总体报告摘要使用橙色背景：

   

 

**例子** 下面是不同的女子5000米滑冰奥运会金牌获得者的数据，变量依次为：姓名、国家、年份、金牌数。每一行包括了两条记录：

   

下面的代码使用proc report创建了一个HTML文件，使用默认模板：

   

结果为：

   

下面的代码使用default风格模板，但在proc report中增加style选项以改变所有数据的背景颜色，并居中：

   

结果为:

   

现在将style添加到define语句中，只改变name这一列：

   

结果为：

   

 

### 5.10 使用style=option定制proc tabulate输出

下面显示了proc tabulate语句中可以应用style的地方，并且影响的表区域：

   

**Proc tabulate****语句** 如果想要来自数据集MYSALES的表的所有数据单元都变成黄色背景：

PROC TABULATE DATA=mysales STYLE={BACKGROUND=yellow};

**Table****语句** 下面的代码使得all列都有红色背景：

TABLE City,Month ALL*{STYLE={BACKGROUND=red}};

CLASSLEV,VAR,和CLASS statements CLASSLEV,VAR,和CLASS语句都是在斜杠/后面应用style语句。注意的是，classlev语句中的变量必须出现在class语句中，下面的代码是将月份month变量的每个值（Jan,Feb,Mar…）的前背景应用为绿色，使用classlev语句如下：

CLASSLEV Month/STYLE={FOREGROUND=green};

 

**例子** 下面是一份关于奥运会男子滑冰的数据，OR是奥运会纪录，WR是世界记录，NONE既不是奥运会记录，也不是世界记录。注意一行有四个观测值：

   

Tabulate过程建立了一个表，以年份作为行，记录作为列。年份和N的顶部都通过设置为null将其消除。ODS语句创建了HTML文件，使用默认模板：

   

结果如下：

   

现在将数据单元的数据居中，并将背景设置为白色：

   

显示结果为：

   

 

### 5.11 为你的输出增加交通信号灯

交通信号灯是基于单元格的值，来控制格的风格。它可以使得重要值变得醒目，它可以在print、report、tabulate中被使用。

使用之前需要做两件事：首先创建用户定义的格式。其次，在style=中将风格属性等于你定义的格式，比如，你创建了一个格式：

   

在print的VAR语句中，将属性值等于这个格式：

VAR Balance/STYLE={FOREGROUND=posneg.};

现在所有balance变量风格都发生变化。

例子 下面的数据是2002年冬奥会中，男子5000米滑冰前五名的数据，包括姓名、国家、成绩（用时）

   

下面代码读取打印数据，生成HTML文件，使用default模板：

   

结果为：

   

想要用信号灯显示每个成绩与世界记录的378.72、奥运记录382.20比较的结果，先创建用户自定义的格式REC，快于世界记录的用红色显示，橙色显示快于奥运记录的，其他颜色设置白色。接着在print语句中增加var语句，使用style=option为时间变量分配风格。最后，将定义的格式REC赋给background。

   

结果如下：

   

 

### 5.12 选择风格属性

​            

 

## 第六章 修改组合SAS数据集

### 6.1 使用SET语句修改数据集

SET语句可以增加新变量、创建子集、修改数据集。SET语句是一次一个变量地，将一个数据集放入数据步中予以分析。基本形式为：

​     DATA new-data-set;

SET data-set;

Data语句指定了新数据集名，set指定要读取的老数据集名。如果不想创建新的，则也可以在data中指定老数据集。

下面的代码创建了一个Friday的新数据集将sales数据集中的day属于Friday的观测值复制，并创建了新变量total：

   

 

**例子** 有一份关于火车运汽车的数据，汽车主为了在高峰期节省时间，或者为了节省汽油，选择让火车运汽车的方法，变量为一天中发车的时间、火车上的汽车数、火车中的人数：

   

数据被读入一个永久数据集trains中，储存在MYSASLIB目录文件夹下：

   

由于每辆车的最大乘客数为6人，现在想知道一列火车上，平均每辆汽车的乘客数是多少，可以在数据中插入一列，但这不在原始数据中计算，而是在一个新数据集中计算：

   

结果如下：

   

 

### 6.2 使用set语句堆叠数据

​     运用set语句可以把一个数据集堆在另一个数据集上，适用于两个变量相同的两个数据集。

基本形式为：

DATA new-data-set;

​     SET data-set-1 data-set-n;

首先指定一个新的数据集，然后列出需要合并的旧数据集。

如果一个数据集包含了另一个数据集没有的变量，那么合并后，该变量下将会出现缺失值。

 

**例子** 有如下两份南北数据，北方数据比南方多了一行变量（最后一行），其他变量均相同：

   

下面有三段代码，前两段将南方和北方的数据各输入数据集，并打印。第三段使用SET语句将南北方数据合并，并创建了新变量，AmountPaid：

   

   

输出结果如下：

   

 

### 6.3 使用SET语句插入数据集

​     前面的堆叠数据，可能把数据顺序打乱，当然可以再用proc sort再将数据排序。但这可能效率低下。在set语句中使用by语句可以高效率的将数据按顺序合并，基本形式为;

DATA new-data-set;

SET data-set-1 data-set-n;

BY variable-list;

BY语句中，可以指定一个或多个变量，让SAS进行排序。

注意，在合并几个数据之前，每个数据都要用BY进行排序，如果没有，则要用proc sort完成。

 

**例子** 仍然是刚才的例子：

   

注意南方的数据已经按照pass number（第二个变量）进行了排序，北方的没有。下面还是三段代码，第一段对南方的数据输入，打印。第二段对北方的数据输入、排序、打印。第三段进行合并，并创建新变量INTERLEAVE。

​      

下面是输出结果：

   

 

### 6.4 一对一匹配合并数据集

​     合并数据集，首先，如果数据没有排序，使用sort过程按照匹配变量排序。之后，在data语句中对新SAS数据集命名，再使用merge语句列出要合并的数据集名。使用BY语句说明共同变量。

  DATA new-data-set;

​               MERGE data-set-1 data-set-2;

   BY variable-list;

注意，如果两个数据集有重叠的变量——除了BY变量，那么第二个数据集中的此变量会覆盖第一个数据集中的。

 

**例子** 有一个巧克力店记录了每天所卖巧克力的类型以及数量，第一个文件sales data记录了所卖的巧克力代码和数量，第二个记录了巧克力代码、所代表的类型、描述。

   

下面有三段代码，前两段读取sales数据，description数据。后者已经对codenum变量进行排序，前者需要用proc sort进行排序。否则会出现错误的信息：ERROR:BY variables are

not properly sorted。

   

结果如下：

   

注意M315的销售记录缺失，因为sales data中 没有关于其的记录。

### 6.5 一对多匹配合并数据

​     一对多合并是指一个数据集中的一个观测值可以与另一个数据集中的多个观测值匹配。

基本形式与一对一一样：

DATA new-data-set;

MERGE data-set-1 data-set-2;

BY variable-list;

注意数据集的顺序，一对多的一要放在前面。在进行合并之前，仍然要对两个数据集按照匹配变量进行排序。其他注意与6.4差不多。

 

**例子** 有一份关于鞋子打折的数据，其中训练鞋、跑步鞋、走路鞋的折扣各不同。第一份数据是关于鞋子的风格、类型、价格。第二份数据是关于每个类型鞋子的折扣：

   

下面的代码用多对一合并了两个数据：

   

结果如下：

   

 

### 6.6合并统计量与原始数据

​     当你想比较每一个观测值和一组变量的均值时，可以先使用proc means计算统计量，并保存输出文件，再与原始文件合并。

 

 

 

**例子** 有一份关于鞋子销量的数据，变量为鞋子风格、类型、销量。现在想列出每种类型鞋子里，各风格的销售量所占的百分比：

   

代码：

   

描述统计量的结果summarydata如下：

   

合并后的数据如下：

   

 

### 6.7 合并total和原始数据

​     可以通过means过程创建一个包含总计（不是分组总计）的数据集。但不能直接与原始数据合并，因为没有匹配变量。幸运的是，可以用两个set语句：

 

 

DATA new-data-set;

​               IF _N_=1 THEN SET summary-data-set;

SET original-data-set;

原始数据包含了不止一个观测值，而summary数据集只有一个观测值。只在数据步的第一次迭代中，SAS读取了summary数据集，之后为新数据的所有变量记住这个变量值。它的工作原理在于SET语句是自动记住的。往常之中，记住的变量会被下一个观测值改写，但这里变量只在第一次迭代的时候读取，并为所有观测值记住，这一技术适用于没有匹配变量的情况下，将一个单个观测值合并到多个观测值中。（注意两个set语句的其他使用）

 

**例子** 与上节同样的例子，现在想看每种类型的鞋子销量占总销量的百分比：

   

代码为：

   

输出结果为：

   

 

### 6.8 用交易数据（transactions）更新主数据集（master）

​     update语句用来更新大量新数据信息。

与merge语句一样，都是按照匹配变量来合并数据，不同点在于：

l  匹配变量的变量值有唯一性。

l  交易数据的缺失值不会改写主数据中存在的值。

基本形式为:

DATA master-data-set;

​                          UPDATE master-data-set transaction-data-set;

 BY variable-list;

只能指定两个数据集，一个是主数据集一个是交易数据，都需要按照匹配变量排序。且BY变量必须具有唯一性。

 

**例子** 一家医院有一份关于病人的主数据。变量依次为病人账户号码、名字、地址、出生日期、性别、保险代码、信息最后被更新的时间。

   

当有新病人，或其他病人再进医院时，信息会被更新，比如，第一个病人的保险代码被更换了、最后一个病人的缺失数据被填补上、有新病人加入：

   

下面的代码将这个数据放入一个名为patientmaster的永久数据集中，目录为C盘下的MySASLib：

   

下面的代码读取交易数据并排序，使用updata语句将交易数据更新到主数据中。

   

输出结果如下：

   

注意FORTMAT定义格式：多个变量 格式名。

### 6.9 使用SAS数据集选项

前面已经见过很多选项，SAS语言主要有三种选项：系统选项、语句选项、数据集选项。系统选项有全局影响力，而数据集选项的影响力有限。

系统选项在SAS会话或工作期间都有效，包括center选项，它告诉SAS，center所有的输出。以及LINESIZE=option，设置输出中每一行的最大长度。

语句选项出现在某个语句中，影响某一个数据步或者过程步。

数据集选项影响的只是SAS如何读取和写入一个单个的数据集，可以在数据步（DATA,SET,MERGE,or UPDATE 语句）和过程步（conjuction with a DATA=statement option）中使用。用法是，接在数据集名之后，用括号括起来。有些最常见的选项：

KEEP=variable-list          告诉SAS保留哪个变量

DROP=variable-list         告诉SAS丢弃哪个变量

RENAME=(oldvar=newvar)   重命名某个变量

 FIRSTOBS=n              从观测值n开始读取变量

OBS=n                    到观测值n停止读取

IN=new-var-name

 

**选择并重命名变量** 下面是关于KEEP=,DROP=，和RENAME=的数据集选项的例子

   

KEEP=,DROP=，和RENAME=的作用与keep、drop、rename很相似。区别在于，后者适用于数据步中的所有变量，而前者仅使用与语句前面的那个数据集。而且，后者仅可以在数据步中使用，而前者除了数据步和过程步，还可以在输入和输出数据集中使用。

 

**用****observation number****选择观测值** 可以使用FIRSTOBS=和obs=来选择读取哪些观测值

   

这也类似于同名的语句选项和同名的系统选项，语句选项只适用于infile语句。数据集选项是用于数据步和过程步中存在的数据集，而系统选项适用于所有的文件和数据集。如果同时使用同样的系统选项和数据集选项，那么后者将覆盖前者。

 

**追踪观测值** 这里提到的选项都是针对现有的变量，而in=option则自己创建一个新变量。这个新变量是临时的，并且有自己在选项中指定。下面的例子，SAS创建了两个临时变量：InAnimals和InHabitat:：

   

该变量只存在于现在的过程步中。

 

### 6.10 用in=option追踪并选择观测值

​     如果合并了两个数据集，可以用in=option来追踪原始数据集对应新数据集中的哪个观测值。

In=data选项可以被用在数据步中的任何地方——SET,MERGE,或者UPDATE——但大部分用在merge语句上，接在要追踪的数据集后面。

下面的数据步创建了一个both数据集，合并两个数据集，state和ounty。并用in=Option创建了两个变量InState和 InCounty：

 

 

   

创建的变量是临时的，只存在于数据步期间。SAS给新变量赋值为0和1。比如county数据集没有关于Louisiana的数据（Louisiana只有parishes，没有counties），因此上例中，两个数据集都含有一个关于Louisiana的观测值，InState变量下的这个观测值为1，InCounty的为0。

这个被用在IF或IF-THEN语句中最多：

Subsetting IF:    IF InState=1;

IF InCounty=0;

IF InState=1 AND InCounty=1;

IF-THEN:       IF InCounty=1 THEN Origin=1;

IF InState=1 THEN State='Yes';

 

**例子** 一家运动品厂商有两份数据，一个包括所有客户的数据，一份包括了第三季度订单的数据。现在想要了解哪些客户在第三季度没有任何订单，即可以用in=option选项。客户数据包括客户编号、姓名、地址；订单数据包括客户编号、总价格：

   

发现没有订单客户的代码如下，数据步中创建了新变量recent，如果出现在客户数据中的观测值没有出现在order中，则recent赋为0，否则赋为1。

 

   

结果如下：

   

 

### 6.11 使用output语句写多维数据集

​     有时候想在一个数据步中创建多个数据，可以在DATA语句后面多接几个数据集名即可，如下语句告诉SAS创建三个数据集：LIONS、

TIGERS、和 BEARS:

DATA lions tigers bears;

这样仅仅是创建了三个一样的数据集，如果想创建不同的，可以用output语句

 

每一个数据步的结尾都有一个暗含的output语句，它告诉SAS在处理下一个观测值之前，将当前的观测值写入输出数据集中。可以用自己的output语句来推翻这个暗含的output语句，基本形式为：

OUTPUT data-set-name;

如果遗漏了数据集名，则将被写入数据步中所有的数据集中去，output可以单独使用，也可以使用在IF-THEN或DO-loop过程中：

IF family='Ursidae' THEN OUTPUT bears;

**例子** 有一份关于动物园给动物喂食的数据，变量为动物类型、生物学分类、居住区域、喂食是否在早上/下午/两者：

   

下面的代码创建了两个列表，一个是早上喂食，一个是下午喂食：

   

日志：

   

输出报告为：

   

 

 

### 6.12 使用output将一个观测值变成多个观测值

​     SAS通常在数据步结尾将一个观测值写入数据中，但可以写入多个观测值，在DO loop中或单独使用output语句。Output语句控制何时将观测值写入SAS数据集中。如果数据集中没有OUTPUT语句，则暗含在结尾，放置了output之后，则结尾的就不再暗含存在。当SAS出现OUTPUT语句时，则写入一个观测值。

 

 

 

**例子** 下面的代码阐述如何在DO LOOD语句中使用output语句来产生一个数据集。

   

这个代码没有INPUT或SET语句，故整个数据步中只有一次迭代——但包括了DO LOOP中的六次循环。由于OUTPUT语句在DO LOOP循环中，因此每次循环都会创建一个观测值：

   

如果没有OUTPUT语句，SAS仅会写入一个观测值，因为结尾处暗含的OUTPUT语句。

 

**例子** 有一份关于三个电影院的门票销售数据，记录了月份、电影院名称、门票销售额：

   

现在需要将电影院名作为一个变量、销售额作为一个变量、月份重复三次。

下面的代码使用三次input语句读取同一个原始文件。第一个读取变量month、location和tickets，并用@停留住数据行，接着用OUTPUT语句输出这个观测值。下一个INPUT读取这行后面的名、销售额，并再停留住行。接着读取，但释放行，进入下一个迭代。这个代码用output语句使每一行创建了三个观测值：

   

结果为:

   

 

### 6.13 使用proc transpose将观测值转变为变量

​     transpose过程可以转置数据集，将观测值转变为变量或将变量转变为观测值。部分情况下，将观测值转变为变量，可以使用下面代码：

 

 

PROC TRANSPOSE DATA=old-data-set OUT=new-data-set;

BY variable-list;

ID variable;

VAR variable-list;

 

**BY****语句** 可以使用BY语句，如果您有任何分组变量要保持作为变量。这些变量包括在已转置的数据集内，但它们本身并不转置。转置的数据集每个转置的变量在BY水平下都有一个观测。例如，在图中所示的变量X是BY变量。该数据集必须在转置前按这些变量排序。

 

**ID****语句** ID语句命名变量，这些变量值将变成新的变量名，ID变量在一个数据集中只能发生一次，如果有BY语句，那么在一个by-group中，变量值必须是唯一的。如果ID变量是数值型变量，新的变量名必须有一个下划线作为前缀（_1 or_2,for example）。如果不适用ID语句，新变量将命名为COL1，COL2等。

 

**VAR****语句** VAR语句命名变量，这个变量的变量值是要转置的。

 

**例子** 有一份关于儿童棒球联盟选手的数据，包括队名、选手编号、数据类型(salary or batting average)、以及entry：

   

现在想考察平均打击数与salary之间的关系，首先要将salary和平均打击数变量变量。下面的代码读取数据、按照队伍、选手排序数据，再转置数据：

   

在proc transpose这步中，BY变量是team和player。ID变量是type，它的值salary和batavg将是新变量名，将要转置的变量entry在VAR语句中指定。注意原来是变量名的entry，现在作为_name_变量下面的变量值。结果为：

   

 

### 6.14 使用SAS自动变量

SAS有一些自动变量，这些变量看不到，是临时的并不会被储存。但在数据步中，可以任意使用。

 

**_N_****和****_ERROR_** _N_记录了SAS在数据步中循环的次数，它不一定等于观测数。因为诸如IF语句就可以使迭代次数与观测数不一致。如果一个观测值的数据出现错误，_ERROR_会被赋值为1，否则赋值为0。错误数据包括无效数据（数值型格式变量却赋为字符串值），转换错误（0作为除数），函数中不合法的自变量（log（0））。

 

**FIRST.variable****和****LAST.variable** 当使用BY语句时，这两个变量才有效。SAS处理一个观测值时，如果某个变量的新变量值是第一次出现，first.variable被赋值为1，其他观测值中被赋为0。LAST.variable是同理的某变量的变量值是最后一次出现时，赋为1，其他赋为0。

 

**例子** 有一份不知道绕着镇中心走路比赛的数据，变量为entry number、age group和 finishing time。注意每行不止一个观测值：

   

第一件要做的事情是为完成情况创建一个新变量。下面代码读取数据，按照finishing time排序，另一个数据步创建新变量place，并赋给它当前的_N_值，print过程产生finishers列表：

   

   

第二段代码给出了每个年龄组的第一名：BY语句中自动产生了first.variable，后面的IF语句保留了每个年龄组的第一个观测值，由于数据是按照年龄组agegroup和time排序的，因此第一个观测值就是第一名。结果为：

   




## 第七章 使用SAS宏功能灵活写代码

### 7.1 宏概述

宏以前被认为是经验老道的SAS程序员使用的高级技术。但现在新手也能够了解一些。幸运的是，宏的基本功能不是那么难理解。本章介绍的最普遍使用的SAS宏语言的特征。

 

​    **宏处理器** 标准SAS程序中，提交程序后，SAS就编译并立即执行。但宏语句多了一步，在提交之后，SAS会将宏语句传送到宏处理器上，将其转变为SAS标准代码，通常叫做“变换代码”（meta-programming.）

 

​    **宏和宏变量** SAS宏代码包括两个基本部分：宏命令和宏变量。宏变量通常加一个“&”作为前缀，而宏命令通常加一个“%”作为前缀。

 

​    **局部****VS****全局** 宏变量有局部宏变量和全局宏变量。如果在宏的内部定义则为局部宏变量，只能在内部使用。如果在开放代码中定义则为全局宏变量。避免两种错误：在宏之外（开放代码）使用局部变量；创建同名的局部变量和全局变量。

 

​    **启动宏处理器** 使用宏指令之前必须将宏系统选项打开，尽管有时默认是打开的。可以用下面代码查看是否打开： PROC OPTIONS OPTION=MACRO; RUN;查看日志，如果看到MACRO，则打开了；如果看到NOMACRO，则没有打开。

 

**避免宏错误** 宏会让人很头痛，可以通过分段形式避免。首先，用SAS标准语言写下程序；接着，将其转变为宏代码。

 

### 7.2 用宏变量提交文本

​    **用****%let****创建一个宏变量** 最简单给宏变量分配一个值的方法是%let，基本形式为：

%LET macro-variable-name=value;

宏变量名必须符合SAS命名法则，（少于等于32字节、以字母或下划线开头、只能包括字母、数字和下划线），下面创建了宏变量：

  %LET iterations=10;

  %LET country=New Zealand;

当赋值字符串时，不需要加引号。除非在开头和结尾有空格，否则从等号到分号的全部内容都是变量值。

 

**使用宏变量** 宏变量前面要加前缀&，注意宏处理器找不到单引号内的宏变量，只能用双引号。如下的例子：

DO i=1 to &iterations;

TITLE ”Addresses in &country”;

经宏处理器编译后，语句变成：

DO i=1 to 10;

TITLE ”Addresses in New Zealand”;

 

​    **例子** 一份关于花店销售的数据，变量为顾客ID，销售日期，花的种类，数量：

   

想要一份反映某一种类型花的销售情况数据，宏变量就可以不用编辑数据步和过程步来选择一种花种：

   

结果如下：

   

 

### 7.3 用宏创建一个模块化的代码

宏可以使一段代码在一个或多个程序中被反复使用，而不需要重复地去编写相同或相似的代码。基本形式为：

%MACRO macro-name;

macro-text

%MEND macro-name;

%MACRO语句告诉SAS这是宏开始，而%MEND则意味着结束。macro-name是自己命名的，但mend后面的macro-name则是可选的，但加入会使得句子好很多（easier to debug and maintain）。

 

**启动宏** 定义了宏之后，可以通过在宏名称前面增加%来启动宏：%macro-name，注意这里可以不用分号。

 

​    **例子** 使用前面花店销售的数据：

   

下面的代码创建了一个名为%SAMPLE的宏，来将数据按照Quantity排序，打印出最大销售额的五个观测值（先降序排列，然后用OBS指定最后一行）。然后用标准数据步读取数据，并启动宏：

   

结果为：

   

这样的宏有些限制，因为它只能做一件事。现在结合%let语句，并增加参数使得其更加灵活

 

​    **宏自动呼叫库** 本书中的宏仅在一个程序内部定义和启动。也可以将宏储存在一个中心位置，叫做自动呼叫库，被各个程序分享。具体来说，将宏作为文件储存在某路径中，或作为分区数据集中的一员。使用MAUTOSOURCE和SASAUTOS=系统选项告诉SAS在哪里查找宏。之后，即使宏没有出现在程序中，也可以启动它了。

### 7.4 给宏增加参数

参数就是宏的变量，给宏增加参数，在%MACRO语句中的括号内列出宏变量的名字。基本形式为：

%MACRO macro-name(parameter-1=,parameter-2=,...parameter-n=);

macro-text

%MEND macro-name;

比如，一个叫做%QUARTERLYREPORT的宏可能这样开始：

%MACRO quarterlyreport(quarter=,salesrep=);

这个宏有两个参数&QUARTER 和&SALESREP。启用这个宏可以用这样的语句：

%quarterlyreport(quarter=3,salesrep=Smith)

 

​    **例子** 仍然是花店销售例子：

   

现在需要一份报告，反映每位对每位顾客的销售。下面的代码定义了宏%SELECT，并启动两次。这个宏排序并打印数据FlowerSales，使用参数创造了两位命为&CUSTOMER和&SORTVAR的宏变量：

   

   

   

结果为：

   

 

### 7.5 使用条件逻辑写宏代码

在宏中使用条件逻辑的基本形式为：

%IF condition %THEN action;

%ELSE %IF condition %THEN action;

%ELSE action;

%IF condition %THEN %DO;

SAS statements

%END;

 

​    **自动宏变量** 每一次启动SAS，宏处理器自动创建一些宏变量，可以使用在程序中。最常见的有：

   

比如，可以像这样结合自动宏变量和条件逻辑语句：

%IF &SYSDAY=Tuesday %THEN %LET country=Belgium;

%ELSE %LET country=France;

 

​    **例子** 仍然是花店销售数据：

   

现在想在周一和周四的时候打印报告，代码如下：

   

当程序提交之后，宏处理器将会写下如下代码：

   

如果这段代码是周四写的，那么结果如下：

   

### 7.6 用call symput编写数据驱动的程序

分配一个值给宏变量，可以使用call symput：

CALL SYMPUT(”macro-variable-name”,value);

macro-variable-name是变量名，value可以是一个变量名，该变量的值将分配给macro-variable-name，也可以是一个用引号括起来的常量。

call symput通常在IF-THEN语句中使用：

IF Age>=18 THEN CALL SYMPUT(”status”,”Adult”);

ELSE CALL SYMPUT(”status”,”Minor”);

这个语句创建了宏变量&STATUS，并依据年龄情况分配值adult或minor。下面的代码使用变量来赋值：

IF TotalSales>1000000 THEN CALL SYMPUT(”bestseller”,BookTitle);

**注意** 用call symput创建的宏变量与赋值变量不能够用在同一个数据步中。因为直到数据步执行之后，SAS才会将一个值赋给宏变量。

 

​    **例子** 仍然是花店销售的数据：

   

现在想找到单个订单最大的客户，并打印出这个客户的所有订单。

   

第一段代码读取原始数据，proc sort按照quantity降序排序，最大单个订单将会出现在第一个观测值上。

第二段代码使用call symput，当_N_为1 的时候，分配变量CustomerID的值给宏变量&SELECTEDCUSTOMER，在数据步中，我们所需要的就是这么多，因此使用stop语句告诉SAS停止数据步。Stop语句也可以不要，但为了提高效率，它可以告诉SAS不要再读取下面的观测值了。

第三段代码，此时SAS直到数据步已经结束，因此执行数据步。宏变量&SELECTEDCUSTOMER的值为356W，结果如下：

   

 

### 7.7 排除宏错误的bug

**避免宏错误** 尽可能先用标准SAS代码写你的程序，当没有错误了，再转成宏代码，先一次增加一个宏逻辑特征。再增加%macro和%mend。再增加宏变量。

 

​    **引用问题** 宏处理器不能解决单引号内的宏，所以要使用双引号。比如下面的例子，单引号不能读取宏变量的值：

   

 

**排除宏错误****bug****的系统选项** 这五个系统选项会影响SAS写入日志的信息。粗体为默认的设置。

**MERROR**|NOMERROR          如果你调用了一个SAS不能找到的宏，则会报警。

**SERROR**|NOSERROR            如果你使用了一个SAS不能找到的宏，则会报警。

MLOGIC|**NOMLOGIC**           SAS会在日志里打印关于执行宏的详细信息。

MPRINT|**NOMPRINT**            SAS在日志里打印由宏产生的标准SAS代码。

SYMBOLGEN|**NOSYMBOLGEN**    SAS在日志里打印宏变量的值。

最好只在排除bug的时候才将MLOGIC,MPRINT和SYMBOLGEN打开，否则它会让你的日志阅读起来很困难。想要关闭，则用系统语句：

OPTIONS MPRINT NOSYMBOLGEN NOMLOGIC;

 

​    **Merror****信息** 如果SAS不能找到一个宏，并且Merror选项也是开着的，那么SAS会打印这样的信息：

WARNING: Apparent invocation of macro SAMPL not resolved.

确认宏名字的拼写是否正确。

 

​    **SERROR****信息** 如果SAS不能在开放代码中处理一个宏变量，并且serror选项是开着的，SAS会打印这样的信息：

WARNING: Apparent symbolic reference FLOWER not resolved.

首先确认是否拼写错误，再次查看视角，即是否在外部使用了一个局部变量。

 

​    **MLOGIC****信息** 如果这个选项开启，SAS会在日志中打印由宏产生的SAS语句。如果在MPRINT选项中运行了%SAMPLE，日志会如下所示;

   

​    **SYMBOLGEN****信息** 如果这个选项开启，SAS会在日志窗口中打印每个宏变量的值。如果在SYMBOLGEN选项中运行%SAMPLE，日志会如下所示：

   




## 第八章 使用基本统计过程

### 8.1 用PROC UNIVARIATE检验数据分布

PROC UNIVARIATE是Base SAS software的一部分，产生统计量以描述单个变量的分布。这些统计量包括均值、中位数、mode（众数）、标准差、偏度和峰度。

Proc UNIVARIATE的使用很简单，在proc语句之后，用var语句指定一个或多个变量：

PROC UNIVARIATE;

VAR variable-list;

没有var语句，SAS会计算所有数值变量的统计量。Proc语句中也可以指定其他选项，比如plot或normal：

PROC UNIVARIATE PLOT NORMAL;

Normal选项进行正态测试，PLOT画出数据的三个图(stem-and-leaf plot, box plot, and normal probability plot)，可以使用BY语句来对单个组进行分析。（前提是要进行sort排序）

 

**例子** 下面的数据是一个班级的学生分数,每一行是10位同学的分数:

   

下面代码读取数据并运行PROC UNIVARIATE:

   

结果为:

   

 

### 8.2 用proc means产生统计量

由Proc univariate产生的统计量，大部分都可以由proc means产生，前提是你要要求它产生。Proc univariate会默认打印所有的统计量：mean,variance,skewness,quantiles,extremes,t tests,standard error。而用proc means你可以要求打印你需要的统计量。

Means过程只需要一个语句：

PROC MEANS statistic-keywords;

​    默认means会产生均值、缺失值数、标准差、每一个数值变量的最小最大值，下面的list列出可以需要的统计量，可以将它们加入proc means语句中：

CLM        双侧置信区间             RANGE     范围

CSS        校正的平方和              SKEWNESS 偏度

CV         变异系数                  STDDEV    标准差

KURTOSIS  峰度                      STDERR    平均标准差

LCLM      单侧（低侧）置信区间      SUM       总和

MAX       最大值                    SUMWGT   权数变量之和

MEAN      平均数                    UCLM      单侧（高侧）置信区间

MIN        最小值                    USS        未校正的平方和

N 非缺失变量值的个数                  VAR 方差

NMISS缺失变量值个数                  PROBT probability for Student’s t

MEDIAN中位数                        T Student’s t

Q1(P25) 25%quantile                     Q3(P75) 75%quantile

P1 1%quantile                           P5 5%quantile

P10 10%quantile                         P90 90%quantile

P95 95%quantile                         P99 99%quantile

 

**置信区间** 默认置信区间的置信水平为0.05或95%，用在means语句中使用ALPHA=option可以得到不同的置信度。比如现在想要90%的置信区间，就要指定ALPHA=0.10，并要有CLM选项，语句为：

PROC MEANS ALPHA=.10 CLM;

VAR语句 means会默认为所有的数值型变量产生统计量，如果不需要，那么用var语句中指定你需要的变量，基本形式：

PROC MEANS options;

VAR variable-list;

 

​    **例子** 如下是书店中关于儿童读物的书本页数：

   

​    Means可以产生平均页数及90%的置信区间：

   

​    结果为：

   

 

### 8.3 用proc freq检验分类数据

PROC FREQ，是base SAS的一部分，可以产生很多统计量来检验分类数据的相关性。基本形式为：

PROC FREQ;

TABLES variable-combinations/options;

**选项** 这里有一些统计选项：

AGREE    检测分类性，包括McNemar’s test, Bowker’s test, Cochran’s Q test, and kappa statistics

CHISQ         用卡方统计量检测一致性和同类性

CL            一致性检测的置信区间

CMH          Cochran-Mantel-Haenszel statistics

EXACT         Fisher’s exact test for tables larger than 2X2

MEASURES   一致性测量，包括Pearson and Spearman correlation coefficients,gamma,Kendall’s tau-b,Stuart’s tau-c,Somer’s D

PLCORR         polychoric correlation coefficient

RELRISK         relative risk measures for 2X2 tables

TREND          the Cochran-Armitage test for trend

 

**例子** 有人抱怨公交班车总是到站太慢，而快速巴士却可以准时到达。现在想弄明白车的种类与是否准时之间的关系。现在有一组数据，包括两个变量：车类型（E for express or R for regular），是否准时（L for late or O for on time），每一行包含10个观测值：

   

下面的代码读取数据，用chisq选项运行proc freq，

   

结果为：（注意行列次序）假设车类型和到达时间是独立的，获得的卡方检验chi-square概率为 0.0071。因此，数据支持车类型和到达时间是有关联的。

   

 

### 8.4 用proc corr检测相关性

基本形式为：PROC CORR；

它告诉SAS计算最近创建的数据集中的所有数值变量两两相关系数。可以和VAR和with来指定变量：

VAR variable-list;

WITH variable-list;

VAR语句中的变量出现在交叉表顶部，而with的变量出现在左侧。

默认情况下，proc corr计算Pearson积差相关系数。可以增加选项要求非参数的相关系数。下面的SPEARMAN选项告诉SAS计算Spearman’s rank correlations，而不是Pearson’s correlations：

PROC CORR SPEARMAN;

其他还有如HOEFFDING(for Hoeffding’s D statistic)和KENDALL(for Kendall’stau-b coefficients)。

 

**例子** 有一份关于学生学习的数据，变量为考试分数，一周花在电视上的小时数，一周花在学习上的小时数，注意每行包括五个学生数据：

   

代码为：

   

   

结果为：

   

报告开始于每个变量的描述统计量，接着列出相关矩阵，包括：相关系数（pearson）、P值。

### 8.5 使用proc reg做简单的回归分析

REG过程使用最小二乘法拟合线性回归模型，是SAS/STAT 产品的一部分。Reg使用逐步法、前进法、后退法进行自变量的筛选。SAS/STAT其他的产品可以进行非线性（non-linear）、混合线性、logistic回归。SAS/ETS产品中有时间序列回归的分析。

Reg只需两步：用PROC REG语句开始，用MODEL语句指定分析模型。基本形式为：

PROC REG;

MODEL dependent=independent;

Model语句中，自变量在左边，因变量在右边。

Plot语句是reg过程中许多可选的语句之一。可以用plot语句产生数据的散点图。如果安装了SAS/GRAPH模块，PROC REG将使用这个模块来产生散点图。产生散点图语句：

PLOT dependent*independent;

如果没有SAS/GRAPH模块，则需要在proc reg语句中使用LINEPRINTER选项，以产生plots。由于没有SAS/GRAPH模块不能产生回归线，需要用预测值代替观测值来拟合出线。下面的代码显示了用reg过程产生数据的单个散点图和预测值：

PROC REG LINEPRINTER;

MODEL dependent=independent;

PLOT dependent*independent='symbol'P.*independent='symbol'/

OVERLAY;

Symbol的值指定SAS使用哪种标记来标注数据点，如果不指定，SAS会直接使用数字。P.是代表预测值的关键词。

有很多中选项可以选择，来绘出回归分析的结果。比如可以绘出残差值、学生化残差、Cook’s D influence statistics、置信区间。如果有SAS/GRAPH模块，那么有很多方法来高质量的控制输出的外观。

 

**例子** 在儿童垒球比赛上，有人说，选手多高，他就能将球击多远。想从统计角度来验证，收集了如下的数据，分别是身高（英尺）、三次击球最长的长度（英尺）。

   

下面代码读取数据并做回归：

   

在model和plot语句中，距离是自变量、高度是因变量。输出结果将在8.6讨论。

 

### 8.6 读取proc reg的输出

Reg的输出有几个部分，方差分析和参数估计通常输出在一页。有些选项语句，比如plot，在另外的页面中产生。

这部分的输出是由如下proc reg语句产生的结果：

   

第一部分是方差分析的结果，给出了模型对数据拟合的程度：

   

参数估计的结果如下：

   

参数分析的结果可以构建模型：

Distance=-11.00859+2.89466*Height

Root MSE即中文教材中的残差平方根。残差平方(SS残差)是总变异中无法用回归的协变量解释的部分。该数值越小，说明回归的效果越好；该数值越大，说明回归的效果越差。 它的平方根意义相同。 同时，其意义可以反映在回归假设检验的P值上。该数值越大，P值越大，该数值越小，P值越小。

除非是统计方面的研究论文，一般不报告Root of MSE。但它是评价回归效果好坏很有意义的指标。

下面的图形显示了plot语句的结果，如果有SAS/GRAPH模块，proc reg会描出数据点和回归线。上面打印出方程，右边显示统计量：

   

就这个例子来看，球飞出去的长度确实和击球人的身高有关系，模型是显著的，但是两者之间的关系不是很明显（R-square=0.3758），可能年龄、经验会是比身高更好的预测变量。

 

### 8.7 使用proc anova做单因素方差分析

Proc anova是SAS/STAT模块的一部分，许可证独立于BASE SAS。

方差分析有两个基本语句：CLASS 和MODEL，基本形式为：

PROC ANOVA;

CLASS variable-list;

MODEL dependent=effects;

Class描述分类变量，并要在model语句之前。对于单因素方差分析，只需要列出一个变量。Model语句描述了自变量和效应（effects）。对于单因素方差分析，效应就是分类变量。每组的观测值数要求一样，这样的数据为平衡的。

Proc anova有很多选择语句，最常用的是means，计算出model语句中任何一种主效应的自变量的均值。另外，means还可以做几种多重比较检验，包括Bonferroni t tests(BON)，Duncan’smultiple-rangetest(DUNCAN)，Scheffe’smultiple-comparison procedure(SCHEFFE)，pairwise t tests(T)，和Tukey’s studentized range test(TUKEY)。Means语句的基本形式为：

MEANS effects/options;

Effect可以为model语句中的主效应。选项为希望使用的多重比较检验的名字。

 

**例子** 有一份关于几个篮球队员身高的数据，变量为队名、身高，注意每行有六个观测值：

   

因为每组都有12个队员，所以数据是平衡的。现在想知道哪一组最高，因此还要用means语句，并选择Scheffe’s multiple-comparison过程来比较均值。代码为：

   

结果将在8.8中讨论。

 

### 8.8 读取proc anova的输出

Proc anova的输出至少有两个部分，首先打印出有一个表，给出分类变量的信息：水平数、变量值、观测值数。再次打印出变量表的分析。如果使用了类似means这样的语句，那么其结果将接在后面。

8.7中想要检验是否组与组之间的身高有区别，使用proc anova语句如下：

   

第一部分给出了分类变量的信息：

   

分类变量team有五个水平：blue, gold, gray, pink和red。第二部分是方差分析的表：

   

因为模型是显著的，因此可以认为不是所有组的队员身高都相同。Means语句中的SCHEFFE选项比较了不同组的身高。

   

### 8.9 统计分析的图形界面

统计分析的结果也可以用Graphical User Interfaces来完成。

SAS Enterprise Guide、分析家 、SAS/LAB和SAS/INSIGHT。




## 第九章 导出数据

### 9.1 导出数据的方法

**将数据导出到其他应用程序** 有三个基本方法将数据导出到其他应用程序：delimited files或文本这样其他软件都可以读取的文件。创建一个如html、rtf、或xml这样其他软件业可以读的文件。用其他软件的格式创建数据。

l  不论操作环境是什么，几乎都可以创建分隔文件（delimited files），且大部分软件都是可以读取的。数据步，可以让你很好的控制文件的格式，但是步骤比较多。导出向导（Export Wizard）和导出过程（EXPORT procedure），很好使用，但对结果的控制不是很好。ODS可以从任何输出中创建逗号分隔的文件（CSV）。

l  使用ODS，可以从任何输出中创建HTML、RTF、和XML文件，大部分软件都是可以读取这些文件的。

l  如果PC文件格式软件中有SAS/ACCESS模块，可以创建一些不同的文件类型，这些文件在PC程序中很常见。出向导（Export Wizard）和导出过程（EXPORT procedure）都可以产生PC文件。通过使用这些程序本身来创建，避免了创建完还要导入。如果没有SAS/ACCESS模块，且使用window系统，那么可以使用Dynamic Data Exchange(DDE)或 Open Database Connectivity(ODBC)来讲数据从SAS移动到PC程序中，且不需要创建中介的文件。

 

**导出****SAS****数据集到其他的操作系统中** 有三个有效的方法：交叉环境数据访问（CEDA），XPORT引擎或CPORT过程，XML引擎，以及SAS/CONNECT模块。

l  CEDA是迄今为止最简单的，将SAS数据集移动到其他操作系统的方法。但CEDA不能被SAS version 6使用，也不能在OS/390或z/OS中使用。

l  XPORT引擎和 CPORT过程都创建了可以移动到   其他操作系统的传送文件，再将其转回成SAS数据集。创建传送文件会导致数据精度的损失。但对于SAS version 和OS/390或z/OS，由于不能使用CEDA，故可能需要这个方法。

l  如果使用的是SAS 9.0或更高版本，那么你可以在LIBNAME语句中使用XML引擎，来创建XML文件。这个文件可以转移到其他电脑中，并且可以使用XML引擎来转回到SAS数据集。

l  SAS/CONNECT模块，连同一些其他的功能，可以让你将SAS数据集转移到其他操作系统中，而不需要创建中间文件。SAS/CONNECT模块也可以讲SAS数据集从一个较早版本移到一个较高版本，且反之也可以。

 

### 9.2 用导出向导写文件

导出向导是一个图形使用界面（GUI），如果你只需要一次性导出数据，那么这个方法比proc export简单。

在文件菜单中选择“导出数据…”，在第一个窗口中，选择要导出的library和menbs名。如果要导出一个临时SAS数据集，那么library就是work。Member就是SAS数据集的名字。

   

第二个窗口中，选择要创建的文件类型。这可以从standard data sources的下拉列表中选择，或勾选User-defined formats旁边的框框。

   

下一个窗口中 ，选择导出文件的路径。如果要导出分隔的文件，那么要在option中进行设置。

   

最后一个窗口中，用来储存由导出向导产生的proc export语句：

   

 

### 9.3 用EXPORT Procedure写分隔的文件

   

使用EXPORT Procedure的优点在于，它可以将代码融合到现有的SAS程序中，每一次创建文件时，不需要通过export Wizard。

**The EXPORT procedure** 基本形式为：

PROC EXPORT DATA=data-set OUTFILE='filename';

Data-set是要导出的数据集，filename是路径及名称，如下的代码告诉SAS读取名为HOTELS的临时SAS数据集，并写入名为HOTELs.csv的逗号分隔的文件中，路径为C盘下的MyRawData文件夹：

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.csv';

SAS根据文件的扩展名，来决定创建哪一种文件。也可以通过在PROC EXPORT语句中增加DBMS=option来指定文件类型。下面的表格显示了扩展名和对应的DBMS辨认器的辨认：

   

注意空格分隔的文件，是没有扩展名的。因此必须使用DBMS=option。下面的代码通过DBMS=option，告诉SAS创建一个空格分隔的文件，名为Hotels.spc，替代选项告诉SAS替代同名文件。

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.spc'

DBMS=DLM REPLACE;

如果想创建一个有分隔符的文件，不是逗号、tab或者空格分隔的，就需要DELIMITER语句。DELIMITER语句不在乎使用什么扩展名，也不在乎指定的哪种DBMS identifier，文件将会使用你在identifier中指定的分隔符。比如，下面的代码产生文件，Hotels.txt，用&作为分隔符：

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.txt'

DBMS=DLM REPLACE;

DELIMITER='&';

 

**例子** 有一份关于高尔夫课程的数据，变量为课程名、洞口数、par、yardage和

greens fees.

   

下面的代码使用infile和input语句读取数据并放入名为GOLF的永久SAS数据集中，存于C盘的MySASLib路径下。这个例子使用LIBNAME告诉SAS永久数据集储存在哪里，但也可是使用直接指代：

   

下面的代码写一个纯文本、tab-delimited文件，可以用任何文本编辑器来读取：

   

由于输出文件以txt结尾，且没有DELIMITER语句，SAS将写入一个tab-delimited文件，如果运行这段代码，日志将出现如下：

   

注意原始数据中只有六个观测值，多出的一行是变量名。如果用文字编辑器读取这个文件，那么将出现如下：

   

如果想要改变格式，运行proc export之前，在数据步中使用FORMAT语句。

 

### 9.4 用EXPORT Procedure写PC文件

如果使用的是windows或unix系统，且有SAS/ACCESS的PC文件格式软件，那么就可以使用EXPORT procedure来创建PC文件类型。如果用的是Windows系统，EXPORT procedure可以创建Microsoft Access,Microsoft Excel,dBase,和Lotus files。Unix系统则可以用SAS9.1或更高版本创建dBase files，也可以创建Microsoft Access和 Microsoft Excel files。

 

**Microsoft Excel,Lotus and dBase files** PROC EXPORT创建Microsoft Excel,Lotus 和dBase的基本形式为：

PROC EXPORT DATA=data-set OUTFILE='filename';

Data-set是导出的数据集，filename是输出文件的路径。下面的语句告诉SAS读取名为HOTELS的临时SAS数据集，并写入名为Hotels.xls的Microsoft Excel文件:

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.xls';

SAS通过扩展名来决定创建哪一种文件。可以通过DBMS=option来指定文件类型。下面的表显示了文件扩展名和DBMS标识符。

   

下面的语句包括DBMS=option，告诉SAS创建一个名为hotels.xls的Microsoft Excel 5文件，REPLACE选项意味着替换同名文件。

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.xls'

DBMS=EXCEL5 REPLACE;

默认情况下，Microsoft Excel sheet的名字与SAS数据集一样，通过SHEET=语句可以指定不同的名字（该语句对Microsoft Excel 4 or Microsoft Excel 5无效）。Sheet名中特殊的字符将转化为下划线，且$不允许放在sheet名字的后面。下面的代码创建了一个名为Golf_Hotels的工作薄：SHEET='Golf Hotels';

 

**Microsoft Access files** 创建Microsoft Access文件使用OUTTABLE=option，而不是OUTFILE=option，并且要增加DATABASE=语句。基本形式为：

PROC EXPORT DATA=data-set OUTTABLE='filename'DBMS=identifier;

DATABASE='filename';

DATABASE语句指定了哪一个Microsoft Access database文件希望修改或创建，OUTTABLE选项指定那个database的表名。必须要指定DBMS选项来创建Microsoft Access table，下表显示了DBMS的标识符：

   

**例子** 仍然是高尔夫课程的数据：

   

下面的代码使用INFILE和INPUT语句读取数据，并将其放入名为GOLF的永久数据集中：

   

如下代码将golfSAS数据集写入Microsoft Excel文件：

   

Excel的结果为如下图所示：

   

### 9.5用数据步写原始文件

​      

 

 

 

 

数据步可以创建原始文件，在数据步中使用file语句和put语句，可以写下任何一种形式的原始数据文件。虽然PROC EXPORT和Export Wizard在某种程度上更简单，但选项有限。而数据步可以更灵活的创建。

可以用读取原始数据的同样方式写入原始数据，只需几步改变——用file语句和put语句。也就是说infile和input语句是将原始数据文件导入SAS，而file和put语句是将原始数据导出。

   

与input一样，put语句可以用list,column或formatted风格。但由于SAS已经知道变量是否是数值或字符串，因此不需要在字符串变量后加$符号。如果使用list format风格，SAS会自动在变量之间加空格，创建一个空格分隔的文件。要用其他分隔符，在file语句中使用list-style put语句和DSD和DLM=options：

FILE ’file-specification’ DSD DLM=’delimiter’;

如果使用column或formatted风格的put语句，SAS将会把变量放在任何你指定的地方。可以用input语句中同样的指示器，用@n移动到第n列，用+n移动n列，用/移动到下一行，用#n滑动到第n行，@则停留在当前行，也可以通过引号来加入字符串。

 

**例子** 仍然是高尔夫球课程的数据，

   

下面的代码是读取数据的：

   

现在要将数据写入原始原件，但只有三个变量，按新的变量顺序排列，并且美元符号放入变量GreenFees后面。下面的代码读取数据并用FILE和PUT语句写入原始文件：

   

_NULL_是告诉SAS不要新建数据集，以节省电脑资源。

SET语句告诉SAS读取永久数据集GOLF，FILE语句告诉SAS写入的内容和路径，PUT语句告诉SAS要创建的输出变量的名字。Put语句包含了两个引用的字符串，“Golf Course”和“Par”，这两个将插入原始文件中。Put语句使用@列指示符告诉SAS变量的变量值放置在哪里。为GreenFees变量赋DOLLAR7.2格式。用put语句可以完全控制原始文件。

运行这段代码，日志窗口将出现下面的信息：

   

输出结果为：

   

 

### 9.6 用ODS写分隔和HTML文件

ODS是创造各种输出格式的强有力的工具。在各种输出格式中，ODS可以创建的有两种，CSV和HTML，使用它来将数据从SAS中传送到其他程序中，是很有用的方法。许多程序可以读取CSV或HTML格式，而且任何操作系统都可以使用这种方法。

由于所有的过程其输出都经过ODS，因此可以通过选择正确的目的地来用ODS导出数据，并用proc print来获取数据列表。如果不想让SAS打印缺失数据，可以使用MISSING=''系统选项。默认下，PROC PRINT打印观测序号，可以通过使用NOOBS让其不打印。

 

**CSV files** 从9.0开始，可以用ODS创建CSV文件。CSV文件用逗号将变量值分开，且变量值被括在双引号之内。双引号允许变量值包含逗号。创建一个CSV文件来转载数据，用下面的语句：

ODS CSV FILE='filename.csv';

Your PROC PRINT statements go here

RUN;

ODS CSV CLOSE;

filename.csv是要创建的CSV文件，并且下面要为你的数据插入正确的proc print语句。如果想要在CSV文件中包含标题和注脚，使用csvall，而不是csv。

HTML files 使用下面语句为你的数据产生HTML文件，可以在ODS HTML语句中增加STYLE=option语句来选择不同的风格。或者，如果不想使用任何风格，则使用CHTML输出目的地来代替HTML。

ODS HTML FILE='filename.html';

Your PROC PRINT statements go here

RUN;

ODS HTML CLOSE;

 

**例子** 此例使用SAS永久数据集GOLF，仅包括在hawaii的gofl课程。下面的代码使用ODS来创建CSV文件，golfinfo.csv：

   

CSV文件如果用记事本打开，如下所示：

   

如果使用excel打开，则如下所示:

   

下面的代码从golf数据创建一个HTML文件，golfinfo.html，并且在proc print语句中使用noobs选项来减少观测之列：

   

用excel打开：

   

 

### 9.7 和其他类型电脑分享SAS数据集

   

访问SAS数据集时候，SAS会自动检测数据以决定是否和与你使用的操作系统兼容。如果数据集处于不同的系统之中，SAS会自动使用交叉环境数据访问（CEDA），以动态传送数据至一种形式，这种形式下，SAS可以在你的系统中理解数据。有两种CEDA不能使用的情况，分别为：OS/390或z/OS，和SAS 6.0及以前的版本。

决定数据表现 CEDA是透明的，以至于你不知道什么时候它在被使用。如果想知道什么时候CEDA被使用，可以用下面的语句：OPTIONS MSGLEVEL=I;

则，无论什么时候SAS使用CEDA访问数据，日志窗口都会出现下面的类似信息：

   

为外部主机创建SAS数据集 创立一个SAS数据集，方便其他电脑系统访问，而又不需要浪费电脑资源转换格式，可以在libname语句中使用OUTREP=option，基本形式：

LIBNAME libref'path'OUTREP=data-representation;

如果想要那个库中所有数据集都有指定host representation，还可以：

data-set-name(OUTREP=data-representation)

data-representation基本来说是操作系统的名字，比如想要data representation是Microsoft Windows 64-Bit Edition，那么就应该为WINDOWS_64；如果想要data representation是Solaris 32-Bit Edition，那么应该为SOLARIS_32。

 

**例子** 你有关于HAWII高尔夫球课程的数据，储存在你的电脑里。可是你的朋友需要你的数据，而他的电脑是linux系统，现在需要把数据集转换成linux格式。下面的代码在数据步中使用SET语句读取sport逻辑库中的golf数据，Data语句中的OUTREP=data set选项告诉SAS用linux格式写下数据，并创建名为golflinux的数据集。

   

系统选项MSGLEVEL=I导致了下面的信息：

   

 

**移动****SAS****数据集** 如果两台电脑都访问同一个文件系统，那么用LIBNAME语句指向SAS数据集存放的路径就可以了，否则要用binary模式的FTP，或者使用外部媒介，比如软盘或CD。

 

**FAT****文件系统** 从SAS版本7开始，创建的数据集默认扩展名为.sas7bdat。有的使用FAT文件系统的windows系统只能有三个字符的扩展名，此时SAS数据集的扩展名为.sd7。如果接受三个字符的扩展名，创建一个三个字符扩展名的数据集，则需要再libname语句中使用SHORTFILEEXT选项：

LIBNNAME libref'path' SHORTFILEEXT;

 

**如果你不能使用****CEDA** 

 The Little SAS Book 学习笔记

目录

[The Little SAS Book 学习笔记... 1](#_Toc368324236)

[第一章 SAS软件入门... 5](#_Toc368324237)

[1.1 SAS语言... 5](#_Toc368324238)

[1.2 SAS数据集... 6](#_Toc368324239)

[1.3 SAS程序的两个过程... 7](#_Toc368324240)

[1.4 数据步的内置循环... 8](#_Toc368324241)

[1.5 选择一个提交程序的方式... 9](#_Toc368324242)

[1.6 SAS视窗环境中的视窗和命令... 10](#_Toc368324243)

[1.7 在SAS视窗环境中提交程序... 11](#_Toc368324244)

[1.8 阅读SAS日志... 13](#_Toc368324245)

[1.9 输出窗口中浏览结果... 15](#_Toc368324246)

[1.10 创建HTML输出... 17](#_Toc368324247)

[1.11 SAS数据的逻辑库... 19](#_Toc368324248)

[1.12 用SAS资源管理器访问SAS数据集... 21](#_Toc368324249)

[1.13 使用SAS系统选项... 23](#_Toc368324250)

[第二章 将你的数据放入SAS. 25](#_Toc368324251)

[2.1 将你的数据放入SAS的方法... 25](#_Toc368324252)

[2.2 用View table窗口输入数据... 25](#_Toc368324253)

[2.3 用导入向导（Import Wizard）读取文件... 27](#_Toc368324254)

[2.4 告诉SAS你的原始数据在哪... 29](#_Toc368324255)

[2.5 list input读取空格分开的原始数据... 31](#_Toc368324256)

[2.6 column input读取按固定列排列的原始数据... 32](#_Toc368324257)

[2.7 informats读取非标准格式的原始数据... 33](#_Toc368324258)

[2.8 可选择变量形式... 34](#_Toc368324259)

[2.9 混合读取方式... 36](#_Toc368324260)

[2.10 读取凌乱的原始数据... 38](#_Toc368324261)

[2.11 跨行观测值的读取方式... 39](#_Toc368324262)

[2.12 一行有多个观测值的原始文件读取... 40](#_Toc368324263)

[2.13 读取原始数据的部分观测值... 41](#_Toc368324264)

[2.14 用infile语句中的选项控制输入... 42](#_Toc368324265)

[2.15 用数据步读取分隔符文件（delimited files）... 44](#_Toc368324266)

[2.16 用导入过程（IMPORT procedure）读取分隔符文件... 45](#_Toc368324267)

[2.17 用导入过程（IMPORT procedure）读取PC文件... 46](#_Toc368324268)

[2.18 用DDE读取PC文件... 48](#_Toc368324269)

[2.19 临时和永久数据集... 49](#_Toc368324270)

[2.20 用LIBNAME语句使用永久数据集... 50](#_Toc368324271)

[2.21 通过直接指代使用永久数据集... 51](#_Toc368324272)

[2.22 列出SAS数据集目录... 52](#_Toc368324273)

[第三章 开发你的数据... 54](#_Toc368324274)

[3.1 创建并重新定义变量... 54](#_Toc368324275)

[3.2 使用SAS函数... 55](#_Toc368324276)

[3.3 选出的SAS字符函数... 56](#_Toc368324277)

[3.4 选出的SAS数值函数... 56](#_Toc368324278)

[3.5 使用IF-THEN语句... 56](#_Toc368324279)

[3.6 用IF-THEN语句将观测值分组... 57](#_Toc368324280)

[3.7 构造子集... 58](#_Toc368324281)

[3.8 处理SAS的日期数据... 59](#_Toc368324282)

[3.9 可选择的Date Informats、Functions和Formats. 60](#_Toc368324283)

[3.11 使用retain和sum语句... 61](#_Toc368324284)

[3.12 用数组简化程序... 62](#_Toc368324285)

[3.11 列出变量名的快捷方式... 63](#_Toc368324286)

[第四章 排序、打印并描述你的数据... 65](#_Toc368324287)

[4.1 使用SAS过程步... 65](#_Toc368324288)

[4.2 用where语句在过程中构造子集... 66](#_Toc368324289)

[4.3 用proc sort为数据排序... 67](#_Toc368324290)

[4.4 用proc print打印你的数据... 68](#_Toc368324291)

[4.5 用formats改变打印外观... 69](#_Toc368324292)

[4.6 可供选择的formats. 71](#_Toc368324293)

[4.7 使用proc format创建自己的格式... 72](#_Toc368324294)

[4.8 定制一个简单的报告... 74](#_Toc368324295)

[4.9 使用proc means描述数据... 75](#_Toc368324296)

[4.10 将描述性统计写入SAS数据集中... 76](#_Toc368324297)

[4.11 用proc freq为数据计数... 77](#_Toc368324298)

[4.12 用proc tabulate产生一个表格报告... 79](#_Toc368324299)

[4.13 为proc tabulate输出增加统计量... 80](#_Toc368324300)

[4.14 提升proc tabulate的输出外观... 81](#_Toc368324301)

[4.15 改变proc tabulate输出的表头... 83](#_Toc368324302)

[4.16 为proc tabulate输出的数据方格指定多种格式... 84](#_Toc368324303)

[4.17 用proc report产生一个简单的输出... 85](#_Toc368324304)

[4.18 在proc report中使用define语句... 87](#_Toc368324305)

[4.19 用proc report创建简易报告... 88](#_Toc368324306)

[4.20 给proc report输出增加summary break.. 90](#_Toc368324307)

[4.21 为proc report输出增加统计量... 91](#_Toc368324308)

[第五章 用ODS增强你的输出结果... 93](#_Toc368324309)

[5.1 ODS（Output Delivery System）的概念... 93](#_Toc368324310)

[5.2 追踪选择过程的输出... 94](#_Toc368324311)

[5.3 从过程输出中创建SAS数据集... 96](#_Toc368324312)

[5.4 使用ODS语句创建HTML输出... 97](#_Toc368324313)

[5.5 使用ODS语句创建RTF输出... 99](#_Toc368324314)

[5.6 使用ODS创建printer输出... 101](#_Toc368324315)

[5.7 定制标题和注脚... 102](#_Toc368324316)

[5.8 用style=option定制proc print输出... 103](#_Toc368324317)

[5.9 用style=option定制proc report输出... 105](#_Toc368324318)

[5.10 使用style=option定制proc tabulate输出... 108](#_Toc368324319)

[5.11 为你的输出增加交通信号灯... 110](#_Toc368324320)

[5.12 选择风格属性... 112](#_Toc368324321)

[第六章 修改组合SAS数据集... 114](#_Toc368324322)

[6.1 使用SET语句修改数据集... 114](#_Toc368324323)

[6.2 使用set语句堆叠数据... 115](#_Toc368324324)

[6.3 使用SET语句插入数据集... 116](#_Toc368324325)

[6.4 一对一匹配合并数据集... 118](#_Toc368324326)

[6.5 一对多匹配合并数据... 120](#_Toc368324327)

[6.6合并统计量与原始数据... 121](#_Toc368324328)

[6.7 合并total和原始数据... 122](#_Toc368324329)

[6.8 用交易数据（transactions）更新主数据集（master）... 123](#_Toc368324330)

[6.9 使用SAS数据集选项... 125](#_Toc368324331)

[6.10 用in=option追踪并选择观测值... 126](#_Toc368324332)

[6.11 使用output语句写多维数据集... 127](#_Toc368324333)

[6.12 使用output将一个观测值变成多个观测值... 129](#_Toc368324334)

[6.13 使用proc transpose将观测值转变为变量... 130](#_Toc368324335)

[6.14 使用SAS自动变量... 132](#_Toc368324336)

[第七章 使用SAS宏功能灵活写代码... 134](#_Toc368324337)

[7.1 宏概述... 134](#_Toc368324338)

[7.2 用宏变量提交文本... 134](#_Toc368324339)

[7.3 用宏创建一个模块化的代码... 135](#_Toc368324340)

[7.4 给宏增加参数... 136](#_Toc368324341)

[7.5 使用条件逻辑写宏代码... 138](#_Toc368324342)

[7.6 用call symput编写数据驱动的程序... 140](#_Toc368324343)

[7.7 排除宏错误的bug. 141](#_Toc368324344)

[第八章 使用基本统计过程... 143](#_Toc368324345)

[8.1 用PROC UNIVARIATE检验数据分布... 143](#_Toc368324346)

[8.2 用proc means产生统计量... 144](#_Toc368324347)

[8.3 用proc freq检验分类数据... 145](#_Toc368324348)

[8.4 用proc corr检测相关性... 147](#_Toc368324349)

[8.5 使用proc reg做简单的回归分析... 149](#_Toc368324350)

[8.6 读取proc reg的输出... 149](#_Toc368324351)

[8.7 使用proc anova做单因素方差分析... 151](#_Toc368324352)

[8.8 读取proc anova的输出... 152](#_Toc368324353)

[8.9 统计分析的图形界面... 153](#_Toc368324354)

[第九章 导出数据... 154](#_Toc368324355)

[9.1 导出数据的方法... 154](#_Toc368324356)

[9.2 用导出向导写文件... 154](#_Toc368324357)

[9.3 用EXPORT Procedure写分隔的文件... 157](#_Toc368324358)

[9.4 用EXPORT Procedure写PC文件... 158](#_Toc368324359)

[9.5 用数据步写原始文件... 160](#_Toc368324360)

[9.6 用ODS写分隔和HTML文件... 161](#_Toc368324361)

[9.7 和其他类型电脑分享SAS数据集... 163](#_Toc368324362)






## 第一章 SAS软件入门

### 1.1 SAS语言

许多软件要么是菜单驱动，要么是命令驱动（输入命令——看结果）。SAS两者都不是，在SAS中，你用一个叫做SAS程序的一系列指令语句，这些程序可以表达出你想做的事情，并用SAS语言写下来。SAS有菜单驱动栏，比如SAS企业向导模块，它使SAS看起来像一个点击的软件，但这些模块仍然使用SAS语言为你写程序。如果你试图用SAS写下你自己的程序，那就要具备一定的灵活性。

 

**SAS** **程序** 一个SAS程序就是一个按顺序执行的语句序列，一个语句给SAS下达信息和指令，且必须要正确的安放。一个常用来与SAS程序做类比的例子是去银行取款，你进入银行、排队、轮到你，那么你会对柜台谁你想做的事，叙述语句可能会是这样：

I would like to make a withdrawal.

My account number is 0937.

I would like$200.

Give me five 20s and two 50s.

注意第一句话说了你想做的事情，之后把相关信息传递给柜台并帮你完成要求。这里信息传递的顺序不重要，重要的是在你的叙述中，首先要说明你要做什么。你不能先说：“Give me five 20s and two 50s.”这会使柜台小姐一头雾水。此外，你必须确保后面的语句都围绕第一句展开。

 

**SAS****语句** 像任何语言一样，SAS语句的编写也需要遵守一些语法规则。幸运的是，相比英语来说，SAS语句的规则不仅少，而且简单。

最重要的规则是：

**每一个****SAS****语句都由一个分号结尾**

听起来很简单，但即使最富有经验的SAS程序员也会偶然忘记分号。如果你能记住这个规则，再来看看另外两个规则吧。

 

**SAS****程序布局** 让每一条语句看起来整洁、用缩进来表现语句的各个部分，这是很有用的，但不是必须的：

l  SAS语句不区分大小写。

l  一条语句可以持续到第二行（只要不把一个单词分开）。

l  几条语句可以用一行。

l  可以在任何一列中开始一条语句

 

**注释** 可以在你的程序中插入一些注释，让它更容易明白。即使你插入一些你喜欢的食物品名也不会对程序有所影响，因为SAS不会读取注释。但不要忘记注释是为了让某人更轻松地学习你的程序，并明白你为什么这么做。

*Read animals’ weights from file;

DATA animals;

INFILE ’c:\MyRawData\Zoo.dat’;

INPUT Lions Tigers;

PROC PRINT DATA=animals; /*Print the results*/

RUN;

有两种注释方法，一种是‘*’和‘；’一起使用；一种是用/* */表示，由于某些操作环境解释第一列中的斜线星号（/ *）作为工作结束的标志，使用这种风格的注释时要小心不要把它放在第一列。出于这个原因，我们选择了星号分号的风格为这本书的注释。

**错误** SAS程序通常将执行的错误标注为醒目的红色字母，你可能忘了分号，拼错了字母，按错了键盘，一个小错误会使得整个程序无法运行。当你看到红色部分多余黑色部分的时候，不要灰心。

 

### 1.2 SAS数据集

在你进行分析、撰写报告，对你的数据进行任何处理之前，SAS必须能够处理你的数据，你的数据必须是一种叫SAS数据集的特殊形式。因为SAS非常灵活，能够读取任何形式的数据，所以将你的数据变成SAS数据集是一件非常简单的事。

 

**变量和观测值** 在传统的SAS术语中，数据包括变量和观测值。采用相关的数据库的术语，SAS数据集也被叫做表、观测值也被叫做行、变量也被叫做列，你可以看到下面这个包含一些数据的表。

​                                                  

 

**数据类型** 未加工的数据有多种形式，但SAS将其简单化。在SAS中只有两种数据类型——数值型和字符型。数值型完全是数据，可以被加减乘除、可以是正负且是小数。字符变量是除数值之外的类型，可以是数值、字母、和一些特殊的字符（￥、！），最多可以占用32767个字节长度。

如果一个变量既包括数字又包括字符，那么它一定是字符变量。如果只包括数字，可能是字符变量也可能是数值变量。在上面这个表中，姓名是字符变量，身高和体重是数值变量，ID，既可能是数值有可能是字符，依据你的选择。

 

**缺失**值 数据有时会有些不完美，某些变量的个别观测值会缺失。字符变量的缺失值用空格表示，数值变量的缺失值用句号（.）表示。上表中，体重的第五个观测值缺失，用.表示。姓名的第六个观测值缺失，用空格表示。

 

**SAS****数据集的大小** 在SAS 9.1之前（prior to SAS 9.1），SAS数据集可以包含32767个变量，从SAS 9.1开始（beginning with SAS 9.1），SAS可包含的最多变量数由你的电脑可用资源决定（内存，CUP？）。但是超过32767个变量的SAS数据集不能用在早期的SAS版本上。

 

**SAS****命名规则** 为你的变量和数据集命名，使它们容易被辨别。A,B,C这样的名字可能看起来很完美，写程序的时候也很方便，但当你6个月后再使用这些数据时，你会发现name，height，weight这样的名字更有用。为变量和数据集命名时要遵守如下规则：

l  名字的长度要小于等于32个字节。（一个字母1个字节，一个汉字2个字节）

l  以字母或下划线开头。

l  可以包含字母、数字、或者是下划线，不能是%$!*&#@。

l  可以是小写或大写字母，且不区分大小写。

 

**SAS****数据集储存的文件** SAS数据集包含了一些类似名称、创建日期、创建用的SAS版本等信息。SAS也储存了每个变量的信息，包括名称、类型、长度、数据集中的位置。这些信息叫做数据集的描述部分，它使得数据集可以自我编制（self-documenting）。

 

### 1.3 SAS程序的两个过程

​     SAS程序有两个基本模块：数据步和过程步。一个典型的SAS程序，由数据步创建SAS数据集开始，再由过程步分析数据。这里有一个例子：数据步中将米转化成千米，过程步中输出结果

   

数据步和过程步由语句组成（废话），一个过程少至1条语句、多至几百条。新手常犯的错误是将两种过程语句用混，只要记住数据步负责读取、修改数据，过程步负责分析数据、输出报告和效用函数，就不会犯错。

数据步由DATA语句开始：data+数据名。上例中数据步处理了名为distance的数据。为了读取外部数据、未加工的数据，数据步提供了DO LOOPS,IF-THEN/ELSE，以及一些数值和字符函数。数据步也可以按照你想要的方式合并数据集，包括联接（concatenation）和合并（match-merge）。

过程步由proc语句开始：proc+过程名（print、sort、means…），SAS过程步可以处理从数据储存、输出到方差分析、3D图表的一切操作。

当程序遭遇DATA\PROC等标志着新程序开始的语句时，程序结束。如果运行的是批处理，则run代表语句的结束。Run告诉SAS去执行所有之前的程序行，全局变量不是DATA或PROC过程的部分。上图的那个程序，当proc出现时，代表data过程结束。

典型的程序是以DATA语句开头，输入或修改数据，然后将数据传递给PROC语句。但并不一定非要用这种模式来混合data和proc语句，你可以用任何顺序来排列data和proc两者的顺序，一个程序甚至可以仅有data语句或proc语句。

下表是data语句和proc语句的一些基本不同点:

   

这只是一个简化表，SAS软件非常灵活，所以data语句和proc语句之间真正的区别也是很模糊的。记住，这个表并不是说proc语句永远不能创建SAS数据集，或者DATA语句永远不能够分析生成报告。

 

### 1.4 数据步的内置循环

Data步读取并修改数据，让你以灵活的方式控制处理数据。Data步也有一个潜在的、内置的循环语句。你不用告诉SAS去执行这个循环，SAS会自动执行。

**数据步按照一行一行、一个观测值一个观测值的顺序执行**

这句话的表意并不明确，许多新手直到成了老手都没明白这句话的含义。

数据步“一行一行的执行”，这句话很好理解。但很多新手还是容易在这里出错，例如在没有创建一个变量之前就使用它，如果Z变量是X、Y两个变量组合的新变量，那么必须确定创建Z变量的语句在创建X、Y变量语句之后。

而“一个观测值一个观测值的执行”就不是那么容易理解。这意味着SAS先读取一个观测值，然后对这个观测值进行数据步的所有语句（当然也是一行一行的），然后再读取第二个观测值执行。每次执行SAS只有一个观测值。

我们将SAS执行的图景放慢：SAS从你的数据集中读取一个观测值。SAS对你的这个观测值执行数据步，如果数据步一直运行到结束而没有错误，SAS会把当前的观测值写入一个新的、输出数据集中，并返回到数据步开头，读取第二个观测值进行执行。当最后一个观测值都被写入输出数据集中之后，SAS结束数据步，进入下一个步。

   

有一个类比，数据步就像是一个投票程序。当你来到投票的地点，你会站在别人后面进行排队，排到你时，你会被问到：你叫什么名字，住在哪里。当你回答之后，你可以投票。在这里，排队的人就像是观测值，投票的程序就像是数据步。一次只能让一个人投票，每个人都相互独立。并且投票的程序是一步一步来的，你不能没说明自己的姓名和住址之前就投票。

 

### 1.5 选择一个提交程序的方式

目前为止我们讨论了写SAS程序，但仅仅写不能带给你任何结果，你必须要提交并执行。有数种方法可以执行SAS程序，但不是任何方法都适合于你的操作环境。查找一下SAS帮助文档，或者咨询下你的SAS顾问，看看哪种方法适合你的操作环境。

 

**SAS****视窗环境**      如果你使用SAS是按照系统提示，或者是点击SAS的图标，那么你适合使用SAS视窗环境。在这种交互式的环境中，你可以写入、编辑SAS程序，提交处理、浏览、输出结果的SAS程序。此外，视窗有许多功能可以处理不同的任务，如管理SAS文件、定制界面、访问SAS帮助文档、导入和导出数据。你的视窗环境的界面取决于你电脑的的类型、使用的终端、电脑操作系统和启动SAS时实际的选择。如果你使用的是个人电脑，那么SAS视窗环境的感觉和其他软件类似。

 

**SAS****企业向导** 如果你有SAS企业向导软件，这个软件在windows下即可运行。你可以用这个软件提交程序：使用插入菜单打开代码窗口，输入序或打开现有SAS程。之后你可以用本地电脑、或者在远程服务器上（需要安装）运行SAS程序。

 

 

 

 

​     **非交互式模式** 非交互式模式是SAS程序语句已先存于你系统的文件中，直接执行那个文件。非交互式模式可以让SAS立即执行程序，通过某个指令开始（$），后接文件名，如：

$ SAS Myfile.sas

 

​        
 **批处理或后台模式** 在批处理或后台模式下，你的程序存于一个文件中，SAS会自动执行，你不需要在电脑旁，如果程序多，SAS会将这个程序进行排队等待。这种模式通常用在大型电脑中，因此通常可以一次性处理多个任务。批处理或后台模式的成本比较低，适合于大型工作，工作完成后，结果会存于文件夹中，你可以任何时候输出查看。批处理未必适合你的操作环境，另外提交方式也会有不同，最好查看SAS帮助文档，或咨询SAS顾问。

 

​             
 **远程提交** 如果你安装了CONNECT模块，可以进行远程提交，即在一台电脑上（本地）编写程序，在另一台电脑上（远程）处理，结果会返回本地电脑。当你处理大型任务，而你的电脑性能又不够时，可以连接到远程的高性能电脑上，也可访问远程电脑的分享文件。

**交互行模式** 交互行模式下，SAS每次提示用户输入一个语句，想改正输入的语句不是那么容易的。因此除非你足够优秀和熟练，否则最好不要用这个模式。你可以用endsas并回车来退出这个模式：

Endsas；

如果你想知道为什么会进入这个模式，并且在以后避免进入，你需要咨询SAS顾问。

### 1.6 SAS视窗环境中的视窗和命令

**SAS****视窗** SAS有五种基本的视窗（窗口）：结果视窗、资源管理器视窗、和三种程序视窗：程序编辑、日志、输出。除此之外，在获得SAS帮助、改变SAS系统选项、定制SAS人机会话等情况时，可能还会用到其他的视窗，下图显示了Microsoft Windows SAS会话中默认的视图：

   

 

**编辑窗口** 编辑窗口中你可以输入、编辑、提交SAS程序。Windows操作环境默认的是增强型编辑窗口，它对语法更敏感，并用颜色标注程序，使得更容易理解和发现错误。其他操作环境默认的是程序编辑窗口，并随操作环境和SAS版本的不同，界面特征也不同。

 

**日志窗口** 日志窗口是关于SAS会话的说明。在提交SAS程序之后，任何的说明、错误、警告和程序语句都会显示在日志窗口上。

 

**输出窗口** 如果程序产生需输出的结果，那么会反映在在输出窗口中。

 

**结果窗口** 结果窗口就像输出窗口的一个目录表，以提纲形式列出了输出的每一个部分。

 

**SAS****命令**SAS命令是为了不同的任务，你有三种方式发出命令：菜单、工具栏、SAS命令栏，如下图：

   

**菜单** （大部分操作环境都会有一个下拉菜单要么在窗口上方要么在屏幕上方…..oh my god!略）

 

**工具栏**（不是所有的操作环境都有工具栏…略！）

 

**SAS****命令栏** 可以在这里输入SAS命令，一些操作环境中，命令栏坐落在工具栏中，另一些操作环境中，每个SAS窗口都有一个命令行（command line），通过语句command=>激活。大部分命令是可以直接用菜单进行选择的。

 

**控制你的视窗** 你可以通过菜单、命令栏、点击的方式激活任何一种程序窗口。

 

### 1.7 在SAS视窗环境中提交程序

**将你的程序放入编辑窗口中** 你可以通过输入，或者打开现有程序文件的方式将程序放入编辑窗口中。打开现有的程序文件，可以通过菜单-打开，也可以通过工具栏的图表，或者直接将文件拖放到编辑窗口中。

 

**提交你的程序** 你有几种方式来提交程序：

​     使用工具栏的提交图表

 

​     激活命令栏，输入submit命令回车。

 

从run运行的下拉菜单中选择submit提交

​        


左图显示了如何在windows视窗中提交增强型编辑窗口的程序。

​        
 **访问****SAS****日志和输出** 提交程序后，日志窗口和输出窗口会有相应的日志和结果显示，如果你使用的是增强型编辑窗口，之前的程序会保留，如果使用的是程序编辑窗口，之前的程序不会保留。如果你的程序产生了输出，那么结果窗口会显示这些输出的目录，下图是一个例子，显示了提交程序之后，增强型编辑窗口、日志窗口、结果窗口、输出窗口的样式。

   

取回你的程序 如果不幸你的程序出现了问题，你需要再次运行，对于程序编辑窗口，由于之前的程序不在保留，因此需要调回命令（recall），有两种方法：

​     

命令窗口中输入recall

 

​     

 

 

激活编辑窗口，从运行（run）下拉菜单中选择

 

 

如果不停的使用recall命令，SAS可以一直往前调回程序，知道所有提交的程序都被调回。

 

### 1.8 阅读SAS日志

**在哪找到****SAS****日志** SAS日志窗口的位置随着你使用的操作环境、选择的模式（视窗、非交互、批处理）、个人的设置的不同而不同。在视窗模式下，提交程序之后，日志窗口默认的位置如下图：

   

对于批处理和非交互模式的日志则会被写入一个文件中，你需要使用操作环境的命令来查看，一般日志文件的名字与对应的SAS程序名一直，如你的SAS程序命为abc.sas，那么日志文件的命则为abc.log

日志包含的内容 日志中虽然有很多琐碎，但也包含了重要的信息。这里有一个将英里转换为千米的程序：

*Create a SAS data set named distance;                                                                                                  

*Convert miles to kilometers;                                                                                                           

DATA distance;                                                                                                                          

Miles=26.22;                                                                                                                            

Kilometers=1.61*Miles;                                                                                                                  

*Print the results;                                                                                                                     

PROC PRINT DATA=distance;                                                                                                               

RUN;

运行之后，SAS的日志窗口会产生一个类似这样的日志：

   

① 说明了你使用的SAS版本和site。

② 是原始的SAS程序语句

③ 说明了数据步为你创建的数据集名称，观测值数和变量数。它可以帮助你确认你的程序没有丢失观测值，也没有创建你不需要的变量。

④ 这部分显示了数据步和过程步占用的电脑资源。当你使用的是多用户系统，或者处理大型数据而使得SAS运行占用大量时间时，这部分信息可以帮助你检查哪一步比较耗时。

如果SAS程序出现错误，错误信息也会反馈在日志窗口中，说明哪里出错及出错表现。

 

### 1.9 输出窗口中浏览结果

你使用的模式不同，产看输出结果的方法也会不同。如果是在视窗模式下提交SAS程序，那么直接在输出窗口查看，如果是批处理和非交互模式下，那么结果就会保存在一个文件里，需要用命令查看。比如使用UNIX系统下的非交互模式，结果会存在一个后缀为.lst的文件里，使用cat或其他更多命令来查看。

 

**输出窗口** 提交程序后，结果会出现在输出窗口中，下图是一个输出窗口的例子

   

**打印或保存输出窗口的目录** 激活输出窗口的目录，在菜单栏文件（file）下拉菜单中选择打印（print）或保存（save）即可。

 

**结果窗口** 结果窗口起到输出窗口的目录作用，当你的输出结果非常多时，结果窗口很有用。它可以让你很清楚的看到输出结果的每一部分。下图是一个方差分析（ANOVA）过程的结果。在这个图中，左边是输出结果的目录，点击+号将其展开，可以看见ANOVA结果的各个部分，双击某一部分，则该部分结果就会位于输出窗口顶部。

   

 

**打印或保存部分输出** 如果要打印结果窗口中显示的某一部分的输出，则需将鼠标移到该部分上，右击，选择打印或保存即可。或者点击一下，使其黑亮，再从菜单栏文件（file）的下拉菜单中选择输出或保存。

   

 

### 1.10 创建HTML输出

如果使用的是SAS视窗环境，那么可以为结果创建超文本标记语言（HTML）格式。

**参数选择窗口** 选择菜单栏中工具（tools）下拉菜单的选项（options）-参数选择（preferences）。选择结果（result）选项卡，如下图所示：

   

这个参数选择窗口上，有一个“创建列表（create listing）”选项，默认的输出就是列表输出。下面还有“创建HTML”选项，用来创建HTML。样式（style）选项用来为HTML选择一个风格样式。选择之后，点击OK。

 

**结果浏览窗口和结果窗口** （注意下面提到的三种窗口：结果浏览窗口result viewer，结果窗口results window，输出窗口output window）

一旦选择了HTML输出，每次运行程序的时候都会自动出现一个结果浏览窗口（result viewer），下图显示了在运行了一个均值和输出的程序后，出现两个窗口：结果浏览窗口——显示HTML输出，结果窗口——显示输出的目录。

   

结果浏览窗口一次只显示输出结果的一个部分，通过选择结果窗口的目录，可以查看其他的部分。值得注意的是，结果窗口给出的目录中，每一个部分都给出了两种相同的目录，一个是链接到输出窗口，一个是链接到结果浏览窗口

保存结果浏览窗口的输出（output of result viewer）的方法：激活结果浏览窗口，选择菜单栏文件（file）下拉菜单的保存（save as）、输出（print）。

可以在style中为输出选择不同的风格，如下图就是D3D的风格：

   

 

### 1.11 SAS数据的逻辑库

SAS逻辑库库只是数据集文件存放的地点。打开SAS视窗模式后，会看到SAS资源管理器窗口（explore），双击逻辑库图标，资源管理器窗口会显示出所有已定义的图标。要返回前一级窗口，选择查看（view）-向上一级（up one level），或者在工具栏中直接点击向上一级图标   。

 

**逻辑库窗口** 打开逻辑库窗口后，除了自己创建的库外，至少会呈现三个逻辑库：sashelp，sasuser，和work，如果安装了某些SAS模块，还有一些特别的逻辑库，比如SAS/GRAPH模块的Maps逻辑库。Sashelp包含了控制SAS会话以及样本数据集的一些信息。WORK是sas数据集的临时储存地点，创建的数据集如果没有指定库，则默认储存在这里，关闭程序时则自动删除数据集。也可以更改默认的库，从而不是临时库。

   

​     

**创建新逻辑库** 创建新逻辑库有两种方法：在逻辑库窗口中选择文件（file）下拉菜单的新建（new）；或者直接右键——新建。

 

 

 

 

 

 

在新建逻辑库（new library）窗口中，为你的逻辑库起一个名字，这里叫做Mylib,指定库的存放路径。如果不想每次启动SAS都要调用这个库，则勾选启动时启用（enable at startup）即可。

   

​     

这是一个新建的Mylib逻辑库的视图。

 

 

 

 

 

 

 

 

 

 

 

 

### 1.12 用SAS资源管理器访问SAS数据集

可以利用SAS资源管理器打开数据集、浏览、编辑，也可以列出数据集的信息，如创建时间和变量名。

​     

**目录窗口** 打开一个逻辑库，进入一个目录窗口，显示这个库中所有的文件和文件夹。右图的目录窗口中显示Mylib逻辑库有三个文件：Customers，Models，orders。双击某文件，则可以打开这个文件的可视视图。     

 

**可视视图** 这个窗口允许你创建、浏览、编辑数据集。

​     

**列出****SAS****数据集的属性** 用资源管理器还可以列出SAS数据集的一些属性情况，右击某文件，选择下拉菜单的属性（properties），属性窗口显示了SAS数据集的属性信息，如创建时间、行列数等。

 

 

 

 

 

 

 

 

 

 

 

 

​     

 

 

 

如果选择列（columns）选项卡，则出现数据的列信息

 

 

 

 

 

 

​     

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

### 1.13 使用SAS系统选项

SAS系统选项是影响SAS运行的一些参数，比如输出的显示、内存的占用、错误的处理等问题。这些小问题由SAS为你设定好，你也可以改变它。

SAS系统选项的参数不是所有都适合你的操作环境，适合于你的再SAS的帮助文档中给出。可以通过打开SAS系统选项窗口或使用option程序来查看你的SAS系统参数。Option程序的语句如下：

Proc options；

Run；

有四种方法可以指定系统选项的参数，SAS帮助文档会告诉你哪种适合你的操作系统：

\1. 系统管理员会创建一个包含了系统选项设定的配置文件，每次SAS启动时都会访问这个文件。

\2. 在启动SAS之后，根据系统提示指定系统选项。

\3. 如果使用SAS视窗环境，可以从SAS系统选项中改变已选择的选项。

\4. 使用OPTIONS语句。

这四种方法按照优先性排列，方法2优先于方法1，方法3优先于方法2，方法4优先于3。如果使用SAS视窗环境，方法3,4最好。

 

**OPTIONS****语句** OPTIONS语句是SAS程序的一部分，并可影响之后的所有语句。由OPTIONS关键词开头，后面是相关选项。比如：

OPTIONS LINESIZE=80 NODATE;

OPTIONS语句既不属于数据步也不属于过程步，这个全局变量可以出现在程序的任何部分，但放在开头最有意义，你可以很容易看到哪些选项在发挥作用。如果OPTIONS语句只出现在数据步或者过程步中，那么它会影响那个过程，和下面的过程（If the OPTIONS statement is in a DATA or PROC step,then it affects that stepand the following steps.）。注意，后面的OPTIONS语句会覆盖前面的，即以后面的OPTIONS为主。     

 

**SAS****系统选项窗口** 通过这个窗口也可以改变系统选项。可以通过在命令栏中输入“OPTIONS”，或从工具（tools）下拉菜单中选择. 

窗口出来后，找到要修改的部分，右击——修改值（modify the value）即可。

 

 

**一般选项** 下面是一些可能用到的一般系统选项

| CENTER\|NOCENTER                                            | 输出是否居中，还是左对齐。默认居中                           |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| DATE\|NODATE                                                | 今天的日期是否出现在输出的顶部。默认输出                     |
| LINESEZE=n                                                  | 控制输出行的最大长度，n可能的值为64到256                     |
| NUMBER\|NONUMBER                                            | 输出的页面页码是否需要。默认需要。                           |
| ORIENTATION=PORTRAIT；   ORIENTATION=LANDSCAPE；            | 指定打印输出的方向。默认竖向（portrait）                     |
| PAGENO=n                                                    | 输出页开始的页面。默认为1                                    |
| PAGESIZE=n                                                  | 每个页面输出的最大行数。可能的值为15到32767                  |
| RIGHTMARGIN=n   LEFTMARGIN=n   TOPMARGIN=n   BOTTOMMARGIN=n | 指定打印输出的边缘大小。默认0.00英寸（Specifies size of   margin(such as 0.75in or 2cm)to be used for printing output.Default:0.00in.） |
| YEARCUTOFF=yyyy                                             | 设定起始年份                                                 |




## 第二章 将你的数据放入SAS

### 2.1 将你的数据放入SAS的方法

你可能有各种形式的数据，包括手写在纸上、存放在电脑上、或是在数据库管理系统里，不论如何，总有一种方法可以让SAS来读取。

SAS读取的数据的方法主要有以下几种类型：

l  直接输入；

l  从原始数据文件中创建一个SAS数据集（creating SAS data sets from raw data files）；

l  将其他软件中的数据文件转换成SAS数据集；

l  直接读取其他软件的数据集；

 

**直接输入** 

l  View table窗口可以让你以表格形式输入数据，可以定义变量、设置属性，如name、length和 type(character or numeric).

l  SAS 企业向导模块，a Windows only application, has a data entry window that is very similar to the View table window. As with View table, you can define variables and give them attributes.

l  SAS/FSP 模块，是Full Screen Product的简称，可以设计定制的数据输入窗口，也有检测数据输入错误的功能（The SAS/FSP product is licensed separately from Base SAS software.）。

 

**从原始数据文件中创建一个****SAS****数据集** 你有两种方法读取原始数据文件：

l  数据步可以读取任何形式的原始数据文件，这种方法还将在2.4中详解。

l  导入向导（Import Wizard）、导入过程（IMPORT procedure）适用于UNIX、OpenVMS和 Windows操作环境的简单方法，可以读取CSV（comma-separated values）和其他一些限定的文件类型。

 

**将其他软件中的数据文件转换成****SAS****数据集** 如果数据在一个软件中以某种格式存放，但需要用另一种软件分析时，就会很麻烦。有几种方法可以将某种软件中的数据转换成SAS数据集：

l  如果安装SAS/ACCESS模块，可以用导入过程（import procedure）和导入向导（Import Wizard）将Excel、Lotus、dBase和Access文件导入SAS数据集，见2.3和2.17（？）。

l  如果没有安装，可以用存放数据的软件创建一个原始文件，并用数据步或导入过程（import procedure）读取。很多软件都可以创建CSV文件。

l  Windows操作环境下也可以用动态数据交换技术（Dynamic Data Exchange，DDE），见2.18。前提是必须有一个其他的Windows程序与SAS同时运行，再使用DDE和数据步。

 

**直接读取其他软件的数据集** 

l  SAS/ACCESS产品可以不用转换数据格式读取数据，并适用于大部分数据库管理系统，包括ORACLE,DB2,INGRES和 SYBASE（但使用方法本书没有介绍）。

l  使用Excel engine和Access engine来读取这两种类型的数据。（SAS帮助文档）

l  还有其他的一些数据引擎（data engines）来读取数据，如SPSS engine（附录D），查找帮助文档找到适合你操作环境的所有有效engine。

 

### 2.2 用View table窗口输入数据

调用View table窗口，在工具栏的下拉菜单中选择表编辑器（Table Editor）。

   

**列属性窗口** 每一列顶部的字母是默认的变量名，右击变量名，即可打开列属性（column attributes）窗口，设置属性之后，点击应用（apply），设置完后关闭即可。

   

**输入数据** 

   

**保存表** 选择文件（file）——另存为（save as），选择一个逻辑库保存，如果想保存在新的逻辑库，点击创建新逻辑库图表（New Library），输入逻辑库的名字和保存路径。

 

**打开一个已有的表** 首先打开表编辑器，选择文件（file）——打开（open）。打开之后，SAS默认的是浏览模式，如果要对数据进行编辑，则要在编辑（edit）菜单中选择编辑模式。也可以在资源管理器窗口中双击打开一个已有的表。

 

**其他功能** 其他一些功能包括排序、打印（printing）、增加和删除行、一次浏览一行（表单视图Form View）、一次浏览多行（表视图 Table View）。图标和菜单都可以选择这些功能。

 

**在****SAS****程序中使用表** 如下程序语句可以将表内容输出打印：

PROC PRINT DATA=Sasuser.coffee;

RUN；

### 2.3 用导入向导（Import Wizard）读取文件

导入向导会浏览你的文件以决定变量的类型，并默认数据表的第一行存放变量名。

第一步，从文件（file）下拉菜单中选择导入数据（import data）导入向导（Import Wizard）

   

第二步，从standard data sources中选择要导入的数据类型。以comma separated values（*.csv）为例。点击下一步

第三步，指定要导入的文件位置，SAS默认第一行存放变量名，从第二行开始存放数据。Options可以改变这种默认选择。

   

第四步，选择数据集要存放的逻辑库，并为数据集取一个名字（member）

   

最后，导入向导创造一个proc import语句，可以是SAS再次导入这个数据。

   

另外，对于一些类型的数据文件还有额外的步骤，比如Microsoft Access文件，你需要输入数据库名和药导入的表名，有时甚至还要输入user的ID号和密码。

 

**在****SAS****程序中使用导入数据** 比如你将数据存放在work逻辑库，并署名为flowers，那么你可以这样来输入它：

PROC PRINT DATA=WORK.flowers;

RUN;

由于work是默认的逻辑库，所以也可以直接这样：

PROC PRINT DATA=flowers;

RUN;

 

### 2.4 告诉SAS你的原始数据在哪

如果数据是原始数据（比如text, ASCII, sequential, flat files），那么用数据步来读取能带给你最大的灵活性。但首先你要告诉SAS你的原始数据在哪。

原始数据可以通过文本编辑器（text editors）或系统命令。对PC使用者来说，原始数据没有相关联的应用程序（就像doc文件与word相关联，双击doc程序就默认调用word程序以打开），有时他们会与像Microsoft Notepad这样的简单编辑器相关联。

**内部原始数据** 如果直接将数据输入SAS程序中，那么数据就是SAS内部数据。DATALINES是一个指示，告诉SAS下面跟着是数据行，直到分号结尾，这个分号可以另起一行，也可以接在数据的后面。也可以用card代替DATALINES。下面是一个程序，这个程序创建了一个USPRESIDENTS数据集。（Input语句还将在2.5和2.15中讨论）

   

**外部原始数据** 数据外SAS程序外部时，使用INFILE语句告诉SAS外部数据的文件名和存放路径，它在data语句之后，在INPUT语句之前。INFILE后面的文件名和路径要用引号，各种系统的引用方式各不同：

   

假设有一个President.dat数据在你的C盘的MyRawData目录中，

   

那么可以用如下方式引用这个外部数据：

   

**SAS****日志** 读取外部数据时，SAS日志会给一些很有用的信息，检查这些信息可以解决一些问题，比如对比INFILE语句读取的记录数和数据集中实际观测值，可以确定SAS是否正确的读取了数据。上面程序的日志如下图所示，

   

**过长记录** 在一些操作环境中，SAS假定外部数据文件的记录长度为256或更少（记录长度是指某行中的字符数，包括空格），如果长度过长，SAS不能读取全部，此时需要在INFILE语句中使用LRECL=来指定长度，这个长度必须是数据中最长行的长度，如：

INFILE ’c:\MyRawData\President.dat’ LRECL=2000;

可以通过SAS日志来查看最大记录长度。

### 2.5 list input读取空格分开的原始数据

如果原始数据都至少被一个空格分开，那么用list input读取数据可能是正确的。List input是一个很简单的读取数据的方式，但是会受到很多限制。你必须读取所有的数据记录，不能跳过某些值、缺失值必须用句号“.”代替。字符串数据不能包含空格、长度不能超过8个字符。而且如果数据文件包含日期变量或者其他需要特别处理的变量，list input将不再适用。虽然很多限制，但仍有大量的文件可以用这种方式读取。

INPUT语句是数据步的一部分，它告诉SAS如何读取原始数据。使用List input来写input语句：在INPUT关键词之后列出变量名（按照变量在文件中出现的顺序），变量名长度在32个字节（含）以下，只能包含字母、下划线和数据，并必须以字母或者下划线开头。如果变量是字符串，后面要价“$”号，值与值之间至少有一个空格，语句要以分号结束。如：

   

这表明输入三个变量，其中name是字符串，age和height是数值变量。

**例子** 你想组织一次青蛙跳跃比赛，现在你记录了每只参赛青蛙的名字、体重、和三次跳跃的距离，如果某次的跳跃距离不合格，那么就用“.”代替，数据文件ToadJump.dat形式如下：

   

虽然不是很整洁、但满足list input的所有要求（字符串长度小于8个字节、不包含空格、值之间都有至少一个空格，缺失数据也用句号代替）。Nosiy的数据溢出到第二行了，但这不影响，SAS会按照变量顺序自动跳到下一行读取。如下是读取这个数据的SAS程序：

   

Input后面是变量名，ToadName是字符串变量，其他是数值变量；proc print过程用来输出数据集中所有的变量和观测值；title语句用告诉SAS输出顶部的标题，如果不指定标题，SAS将以“the SAS system”作为标题在每一页的顶部。输出的形式如下：

   

由于Noisy的数据溢出到下一行，因此下面的说明会出现在SAS日志上：

   

 

### 2.6 column input读取按固定列排列的原始数据

当一些原始数据的值之间没有空格分开，或者没用用句号代替缺失值时，list input就不能用。但当每个变量的值都出现在数据行的相同位置时，并且变量值是字符串或者标准数值（只包含数据、小数点、正负号、和科学标注的E。逗号和日期都不能算）时，可以使用column input来读取。

相比list input，column input有如下优势：

l  不要求变量值之间的空格；

l  缺失值可以直接用空格代替；

l  字符串中可以包含空格；

l  可以跳过不需要的变量。

调查数据使用column input，因为调查答案的记录都是用单个数字（0-9），如果每个答案之间再用空格分开，就会使整个文件会扩大两倍。有地址的数据文件也使用 column input，因为地址之中常常包含空格，比如街道Martin Luther King Jr.Boulevard在column input中就可以当成一个变量而不是五个。可能用column input读取的数据也可以用formatted input读取或者几种方式组合。

Column input的input语句格式如下：input关键字后接变量名、再接变量的列位置（列位置是字符或者数值在一行中的位置）。字符串变量名后仍要用“空格+$”，变量名之间仍要用空格隔开。示例如下：

   

这个语句表明，Name变量，在行中占据第1列第10列，为字符串变量，age占据第11-13列，为数值变量，height占据第14-18列，数值变量。

**例子** 原始数据记录如下：

   

读取这个数据的column input程序如下：

   

第一个变量visitingteam占据第1-20列，为字符变量；concessionsales占据第21-24列，为数值变量，下面几个变量均占据固定的列。输出结果如下：

   

 

### 2.7 informats读取非标准格式的原始数据

有时候原始数据不全是字符串或者数值，比如类似1,00,001这样包括逗号的字符串值，电脑就不能读取，其他诸如包含美元符号、十六进制、压缩十进制的数据都是非标准数据。SAS中，informats可以用来告诉电脑如何读取这样的数值。

日期是最普通的非标准数据，SAS informats会把类似10-31-2003或者31OCT03转换成数字，日期的起点为1960年1月1日，即这一天的数字为0。

Informats的三种普遍格式为：字符串、数值、日期。这三种格式的形式如下：

   

$代表是字符串、informats代表形式（比如日期的MMDDYY）、w是宽度、d是小数点的位数、最后是句号“.”，缺少句号会使得SAS把形式（如MMDDYY）当做变量名。一个简单formatted input的简单INPUT语句如下：

   

Name为字符串变量，占据10个宽度，即列位置从1-10；age为数值变量，占据3个宽度，列位置从11到13；height也为数值变量，占据5个宽度，包括了1位小数点和小数点本身，列位置从14-18（如150.3）；最后是日期变量，从第19列开始，形式为MMDDYY。

**例子** 原始数据如下：

   

读取这个数据的informat程序如下：

   

年龄后面的+1代表跳过一列，即原始数据中年龄后面有一个空格。最后的5个变量score1-score5，都要求有同样的形式，4.1。将变量名和形式分别放在两个括号集中，可以一次性定义很多变量。输出结果如下：

   

 

### 2.8 可选择变量形式

一般使用的变量形式的定义，以及它们的宽度范围和默认宽度如下：

   

   

 

### 2.9 混合读取方式

每种数据读取方式都有其优势，list最简单，column和formatted虽然复杂但是不要求变量之间的空格，并且变量名中可以包含变量，而且formatted可以读取特殊的数据比如日期。SAS可以灵活的让你搭配不同的读取方式，以达到最大的方便。 

例子 如下的原始数据记录了美国国家公园的信息：姓名（name）、所属州（state）、建立时间（year established）、占地面积（size in acreage）：

   

有多种方式进行数据读取，下面的程序是方式之一：

   

其中ParkName是column方式读取，State和Year是list方式读取，Acreage是formatted方式读取，输出结果如下所示：

   

混合读取方式有时会遇到问题：SAS通过一个指示器标注位置，来读取原始数据的一行，但每种读取方式对指示器的使用稍有不同。List方式下，SAS自动找到非空格区域并开始读取；column方式下，SAS读取你所指定的特定位置；informatted方式下，SAS不理会指示器的标准，只是依次的读取。这时，就会需要列指示器@n，来人为的让SAS的读取直接跳至某列。

在上面的程序中，列指示器@40告诉SAS在读取Acerage变量之前，移动到第40列去，如果移去指示器，程序为：

   

输出结果如下图所示：

   

之所以出现这样的结果，要看原始文件的列坐标排列：

   

Comma9告诉SAS读取9列，SAS就会读取包括空格在内的9列，这便会导致输出结果的问题。

 

### 2.10 读取凌乱的原始数据

有的数据排列混乱，长度不一。这样的数据需要新的工具处理：@’character’ 列指示器和colon modifier。

**@’character’** **列指示器** 2.9中提到@column列指示器可以让SAS直接从某列开始读取数据。但有时候你不知道要读取的数据是从哪列开始，此时你只要知道要读取的数据的前面那个字符或单词即可。比如有一个关于狗的原始文件，你想要读取狗的品种号，但文件排列很凌乱，只知道品种号跟随在单词breed后面，那么可以用如下方式读取：

Input @’Breed:’ DogBreed $;

**colon modifier** 由于input读取字符串变量默认为8个字符，因此在上例中如果狗的品种名（dogbreed）超过8个字符，则需要定义长度，定义为$length，在该长度中，空格也算在内。如果要使SAS读取过程中遇到空格则不再继续读取，则要在$length.前面加冒号“:”。比如原始数据中有这么一行：

My dog Sam Breed:Rottweiler Vet Bills:$478

如果用上述不同方法读取，会有不同结果：

   

例子 web日志是凌乱数据的一个很好例子，下面是一个网站的web日志，数据开始于访问IP，后面有访问日期、访问文件名等信息。

   

现在想要读取访问日期和访问的文件名，但是它们每行中所占据的列的位置都不同，而且文件名的长度每行都不一样，那么SAS读取这种文件通过如下方式：

   

@’[’作为列指示器，告诉SAS读取[之后的内容，@’GET’告诉SAS读取GET之后的内容，由于文件名作为字符串变量，这里基本都会超过8个字节，因此后面附加:$20。输出结果如下：

   

 

### 2.11 跨行观测值的读取方式

一般原始文件中一行代表一个观测值，有时会出现一个观测值跨行的情况。由于SAS会自动转到下一行读取数据，直到读取这个观测的所有变量（input语句中给出），所以你需要告诉SAS什么时候不要换行，以便在日志中不出现SAS-went-to-a-new-line的暂停说明，此时需要在INPUT语句中加行指示器。

行指示器，斜线/：告诉SAS跳至原始数据的第二行；#n：跳至第n行，n代表原始数据中某观测值的行数（#2则让SAS跳至某观测值的第二行），#n不能用来回跳。

**例子** 有一组关于温度的数据，temperature.dat第一行代表城市和州，第二行代表本日最高温和最低温，第三行代表史上最高温和最低温。

   

用如下的程度来读取这份数据：

   

Input后面告诉SAS读取第一行的city变量和state变量，斜线/告诉SAS移动到下一行的第一列，以便读取normalhigh和normallow。#3告诉SAS移动到第三行的第一列以便继续读取观测值的recordhigh变量和recordlow变量。这里/可以用#2代替，也可以用/代替#3。

日志记录如下：

   

从日志中可以看出，虽然原始原件占了9行，但只有三个观测值。

输出结果如下：

   

 

### 2.12 一行有多个观测值的原始文件读取

​     

当一行出现多个观测值时，可以在input语句结尾加一个停止符号@@

**例子** 有一个关于降水量的数据，precipitation.dat，文件包含城市名、州名、月平均降水量、月平均降水天数：

   

这个数据文件中，第一行包含了两个观测值，可以用@@的程序读取：

   

 

日志记录如下：

   

中间的说明，SAS went to a new line when INPUT statement reached past the end of a line.是指读取第二个值时达到第一行末尾，并转到下一行继续读取。通常这些信息会预示一个问题出现，但在这里它们都是你所想要的（为什么？）

输出结果如下：

   

 

### 2.13 读取原始数据的部分观测值

​     

有时候只需要读取原始数据的部分观测值，比如只需要年鉴中的女性数据、收入超过10万的人口数据等。

此时的数据读取方式如下：在SAS读取某一行观测值时，首先读取足够的变量以便决定是否需要保留此行的观测值。然后在input语句结尾加符号@，叫做a trailing at（called a trailing at），这告诉SAS先停在（hold）此行，同时用IF语句检测此观测值是否满足需要，如果是，那么可以再用一个input语句来读取现有的变量。

例子 有一个关于当地交通的数据，traffic.dat数据包含街道的类型（freeways和surface）、街道名称、早晨每小时的机动车流动量、晚上每小时机动车流动量。

   

如果现在你只需要freeway的数据，可以用下述程序：

   

第一个input读取字符串变量，@是SAS停留在观测值上并用IF检测，第二个input读取input后面的变量值。

程序执行后日志包括两部分说明，一个说明读取了8个记录，另一个说明新数据集中只包含三个观测值。

   

输入结果如下所示：

   

 

**@ vs @@** @的作用类似于@@，都是行停留指示符（line-hold specifiers），不同地方在于停留多久，@能使SAS停留到下一个input语句（也不换行），@@能使停留的时间到下一个data步（也不换行）。

比如这段代码：

data test;                                                                                                                              

​    infile cards ;                                                                                                                      

​    input x @; 

​    input y; 

​    input z @@; 

cards;                                                                                                                                  

1 2 3 4 5 6                                                                                                                             

7 8 9 10 11 12                                                                                                                          

13 14 15 16 17                                                                                                                          

;                                                                                                                                       

run;

test输出结果就是：

​     

 

 

 

### 2.14 用infile语句中的选项控制输入

读取原始(raw)数据时，SAS做了某些假设，比如从第一行开始读取数据，对于跨行观测值，会自动转到下一行继续读取。但有的特殊数据不满足这些假设，infile语句的选项可以让SAS读取这些特殊数据。

**FIRSTOBS=** FIRSTOBS= 选项告诉SAS从哪一行开始读取数据，当数据开头有些说明信息，或者想要跳过某些行时，这个选项很有用。例如，如下原始数据文件中，开头两行是关于数据的描述：

   

那么用如下程序可以让SAS从第三行开始读取数据：

   

**OBS=** OBS=告诉SAS一直读取到哪一行位置，注意是行而不是观测值（有的观测值占据多行）比如，如下的原始数据文件中，结尾处还有一句不需要的数据说明时。就需要这个选项：

   

用FIRSTOBS=3和OBS=5就可以读取第三行到第五行的数据：

   

**MISSOVER** 在input语句中输入的几个变量，SAS在观测值中就读取几个变量，如果一行未读完，则进入下一行直到输入的变量都读取了变量值。missover可以让SAS不进入下一行读取，未赋值的变量就使其成为缺失值。当如下这种数据，就需要missover选项，一个学生应该有5门课的成绩，但由于最后两门是自学课程，不是所有学生都完成，故而缺失：

   

如下的程序可以让SAS将Nguyen第五门课的成绩设为缺失值，从而不牵扯到下一行：

   

**Truncover** 使用column input或formatted input输入时可能会需要这个选项，因为这时有的数据行比其他的短。如下的原始数据中，由于三行的长度都不一样，input中只能指定最长的一行：

   

程序如下：

   

这里指定了第二行的长度street $ 22-37，但是第一行maple ave.并没占够至第37列（注意后面是没有空格的），故而必须用truncover，否则会转到下一行继续读取，第三行情况也是。

 

### 2.15 用数据步读取分隔符文件（delimited files）

分隔符文件中，变量值之间会用一些特殊的字符隔开，比如逗号或制表符。DLM=和DSD选项可以让SAS容易地读取这些分隔符文件。

**DLM=**  用list input读取文件时，变量值之间应该用空格隔开。对于其他的分隔符，可以用DLM=/DELIMITER=选项来指定，从而可以读取文件。

**例子** 如下的数据中，学生姓名、每周读书数目是用逗号隔开的：

   

用选项来指定分隔符即可：

   

如果原始数据是用制表符隔开的，那么可以使用DLM=’09’X来指定，因为制表符的十六进制值是09，如果你电脑使用EBCDIC（扩充的二进制编码的十进制交换码），那么应该用DLM=’05’X。

```
DSD选项 DSD (Delimiter-Sensitive Data)有三个作用：忽略引号中数据的分隔符，例如一个观测Joseph,76,"Red Racers, Washington"非引号中的逗号能识别成分隔符，而引号中的逗号不能识别；自动将字符串中的引号去掉；将两个相邻的分隔符当作缺失值来处理。并且，DSD默认分隔符为逗号，如果数据中的分隔符不是逗号，那么要用DLM来指定。比如，读取一个制表符为分隔符、并且用两个制表符代表缺失值的数据文件，则要用下面的语句：
```

INFILE ’file-specification’ DLM=’09’X DSD;

**CSV****文件** CSV文件，Comma-separated values files(逗号分隔的文件)，是可以用DSD选项的文件类型。Excel可以储存CSV格式的文件。

**例子** 某咖啡馆，老板每晚请不同的乐队表演来吸引顾客，他记录了乐队名称、演出日期、晚上8点、9点、10点、11点的顾客数量：

   

注意，其中有一个乐队的名字中用逗号来分隔，并且使用了引号。最后一条记录中还有一个缺失值，用两个连续的逗号表示。INFILE语句中的DSD选项可以用来读取这个文件，并且，由于每个记录长度不一样，还需要用missover：

   

注意bandname和GigDate两个变量使用了**冒号修改器**，冒号修改器告诉SAS读取信息的长度（BandName为30，GigDate为10）。如果不加冒号修改器，将会默认每个变量的长度为该变量取值最长的那个值的长度，输出结果如下：

   

 

### 2.16 用导入过程（IMPORT procedure）读取分隔符文件

Proc import会浏览你的数据文件，自动决定变量类型（字符串或数值），为字符串变量分配正确的长度，辨认出日期变量。Proc import会将两个连续的分隔符视为缺失值，会读取引号中的变量值。一行读完后，会自动分配缺失值给未赋值的变量。此外，如果你愿意，你可以使用你的数据文件中的第一行作为变量名。导入过程（IMPORT procedure）自动为你写下数据步，这可以在提交之后的日志窗口中查看。

一个导入过程（IMPORT procedure）的最简单形式：

PROC IMPORT DATAFILE=’filename’ OUT=data-set;

用语句DATAFILE=’filename’读取文件名，用OUT=data-set创建SAS数据集。SAS会通过文件的扩展名来检测文件的类型：

   

如果文件没有正确的扩展名，或者是DLM格式的，必须在proc import语句中用DBMS=option。如果想要创建的数据集名字已经存在，那么要用replace选项代替。一个使用replace和dbms的例子。

PROC IMPORT DATAFILE=’filename’ OUT=data-set DBMS=identifier REPLACE;

导入过程（IMPORT procedure）从数据文件中的第一行获取变量名，可以通过在PROC IMPORT后面增加GETNAMES=NO语句来改变这种默认，PROC IMPORT会分配给变量名字：VAR1，VAR2，VAR3等。如果你的数据文件是DLM类型的，PROC IMPORT会假定分隔符为空格，用DELIMITER=可以改变默认（空格）的分隔符。

DATAROWS = n;  Start reading data in row n. Default is 1. 

GUESSINGROWS = n; Use nrows to determine variable types. Default is 20.

如下是一段有上述代码的程序：

   

**例子** 下面还是使用咖啡馆中，乐队表演的例子（2.15），注意其中有一个乐队的名字中用逗号来分隔，并且使用了引号：

   

用proc import读取数据的代码如下：

   

输出结果如下，注意GigDate的日期格式能够被proc import辨认出来：

   

 

### 2.17 用导入过程（IMPORT procedure）读取PC文件

如果安装了SAS/ACCESS模块，导入过程（IMPORT procedure）可以导入一些PC文件类型。它会浏览你的文件以决定变量类型，并默认使用数据的第一行来分配变量名。Windows操作环境中可以导入excel、Lotus、dBase、和Access文件。Unix系统中可以导入dBase文件，并且从SAS9.1开始，Unix系统也可以导入excel和access文件。在windows环境中有一个不需要SAS/ACCESS模块的方法——Dynamic Data Exchange(DDE)，将在2.18中讲解。

**Microsoft Excel****，****Lotus****，和****dBase****文件** 下面是用导入过程（IMPORT procedure）读取PC文件的一般过程：

PROC IMPORT DATAFILE=’filename’ OUT=data-set DBMS=identifier REPLACE;

如果读取的文件是如下类型，就不用DBMS=OPTION。

   

在读取excel时，有时需要指定要读取的是哪一个工作薄——sheet

SHEET=name-of-sheet;

默认情况下，导入过程（IMPORT procedure）会从工作薄的第一行中读取变量名。如果不需要，可以用如下代码使得SAS给变量赋名为F1，F2等。

GETNAMES=NO;

**Microsoft Access Files** 读取这种文件需要用DATABASE=和DATATABLE=，而不是DATAFILE=option。

   

下面的是DBMS可以辨认的Access文件

   

**例子** 有如下的EXCEL数据：

   

读取的proc import程序：

   

输出结果如下：

   

### 2.18 用DDE读取PC文件

DDE，动态数据交换（Dynamic Data Exchange），读取PC文件的优点为：可以直接访问存于PC文件中的数据，不要求购买其他SAS产品；缺点为：只能用在windows环境下，只能在程序运行时（比如excel），SAS才能进行读取。

有几种方式可以用DDE访问数据：

l  复制数据到剪贴板

l  指定DDE三元组

l  从SAS中启动PC程序，然后读取数据。

**复制数据到剪贴板** 可以直接复制数据至剪贴板，然后在SAS程序的DDE FILENAME 语句中是使用CLIPBOARD关键字。比如，excel中有如下的工作薄：

   

复制A2到G5，然后在不关闭excel的状态下，提交如下SAS程序：

   

FILENAME语句将指代的文件（BASEBALL）定义成DDE类型，并指定从剪贴板（CLIPBOARD）中去读取它。DDE默认空格为分隔符，如果变量值之间有空格，则要在INFILE语句中用NOTAB选项和DLM=’09’X选项，前者告诉SAS在变量值之间放置制表符，后者告诉SAS将制表符定义为分隔符。如果数据中有缺失值，则要在INFILE中加入DSD和MISSOVER选项，前者将两个连续的分隔符视为缺失值，后者告诉SAS如果此行读完，不要进入下一行给未赋值的变量赋值。

**指定****DDE****三元组** 这种方法可以不用复制数据，直接指定出文件的DDE三元组。DDE三元组的形式为：**application|topic!item****。**

有一种方法可以在SAS中直接查看文件的DDE三元组，方法为：复制数据至剪贴板里，触发SAS会话，从解决方案（Solution）菜单中选择附件（Accessories）——DDE三元组。一个窗口会出现你复制文件的DDE三元组。比如，一个工作薄的DDE三元组为：

Excel|C:\MyFiles\[BaseBall.xls]sheet1!R2C1:R5C7

读取这个文件的FILENAME语句为：

FILENAME baseball DDE 'Excel|C:\MyFiles\[BaseBall.xls]sheet1!R2C1:R5C7';

**从****SAS****中启动应用程序** 这种方法可以不用在运行SAS之前启动数据程序。想要从SAS中启动程序，然后读取数据，则首先需要NOXWAIT和NOXSYNC系统选项，然后使用X语句，一个例子：

   

NOXSYNC和NOXWAIT语句告诉SAS不要等待用户输入。X语句告诉windows执行或打开引号中路径的文件，注意这里路径设置了两个引号，如果路径中有空格，则要设置两个引号。使用这种方法，必须要在FILENAME语句中指定DDE三元组。

### 2.19 临时和永久数据集

SAS临时数据集只在目前工作或会话中存在，关闭SAS或结束工作时则删除；永久数据集当关闭SAS或结束工作时仍然存在。

**SAS****数据集名** 所有的SAS数据集都有用句号分开的两层数据集名，如work.a。第一层前缀work是逻辑库名，第二层是在逻辑库中用于辨别自己的成员名。

名字的规则是，以字母或下划线开头，并且名字中只能包含字母、数字和下划线。而且，库名不能超过8个字节，而成员名却可以达到32个字节。

大部分数据集通过数据步创建，过程步也可以创建。如果指定了一个前缀不为work的两层数据集名，则这个数据集就是永久的。如果不指定前缀，则默认数据集是临时的，自动分配到work逻辑库中。下面是一些数据集名对应的逻辑库，成员名，类型：

   

**临时数据集** 如下的程序创建并打印了一个名为DISTANCE的临时数据集：

   

这里，只指定了成员名distance，自动分配到work库中，日志窗口中有说明：

NOTE: The data set **WORK.DISTANCE** has 1 observations and 2 variables.

**永久数据集** 可以在资源管理器窗口中定义一个新库使用：

   

也可以通过如下程序：

   

那么日志窗口就会出现如下说明：

NOTE: The data set **MYLIB.DISTANCE** has 1 observations and 2 variables.

这是一个永久数据集，因为前缀不是work。

### 2.20 用LIBNAME语句使用永久数据集

LIBNAME语句的基本形式为：LIBNAME libref ’your-SAS-data-library’;

LIBNAME的后面，需要指定库名和存放的路径，在个人操作环境下LIBNAME语句的基本形式为：

   

**创建永久数据集** 如下的例子创建了一个永久SAS数据集，包含了magnolia trees的一些信息。每一种树，原始文件都包含它的科学名、普通名、最大高度、第一次开花的年龄、是evergreen还是deciduous、以及花的颜色。

   

下面的代码将会创建一个PLANTS的逻辑库，路径为C盘下的MySASLib。然后从原始文件Mag.dat中读取数据，并创建一个名为MAGNOLIA的永久数据集，存在PLANTS库中。

   

日志窗口会出现如下说明：

NOTE: The data set **PLANTS.MAGNOLIA** has 5 observations and 6 variables.

如果在电脑中打印文件的地址目录，会发现文件名不是PLANTS.MAGNOLIA。这是因为操作系统有自己对文件命名的方式，这个文件，在Windows, UNIX和OpenVMS操作环境中名字为magnolia.sas7bdat，在OS/390或者z/OS环境中，文件名就会如LIBNAME语句中定义的data-set-name形式。

**读取永久数据集** 如果你想打印出上例中创建的数据集，可以用如下语句：

   

这次LIBNAME语句中的库名为example，但却是同样的路径，逻辑库名可以改变，但成员名MAGNOLIA却一样。输出如下：

   

 

### 2.21 通过直接指代使用永久数据集

可以通过直接指代来使用SAS数据集，且不需要自己定义，SAS为你做好。

直接指代，依据系统不同，使用方法也不同，如下：

   

可以看到，一些系统的语句中需要指出路径，但如果遗漏了路径，SAS自动使用当前路径，比如这样一个创建名为trees的永久数据集的代码：

DATA ‘trees’;

UNIX和OPENVMS操作环境下，当前的路径默认为启动SAS的路径，可以通过工具（TOOLS）下拉菜单的选项（OPTIOPN）菜单来改变这种默认，windows环境下当前路径会显示在SAS窗口底部。可以通过双击这个路径来改变默认。

**例子** 如下还是关于magnolia trees的这个例子，

   

下面的代码将从原始文件mag.dat中读取数据，创建一个名为MAGNOLIA的永久数据集，存放在C盘的Mysaslib路径中：

​        

相应的输出窗口显示如下：

NOTE: The data set c:\MySASLib\magnolia has 5 observations and 6 variables.

如果打开MySASLib文件夹，会发现一个名为magnolia.sas7bdat的文件。在没指定库的情况下，SAS会自动为你创建一个库，在资源管理器窗口中可以看到，右图是SAS为magnolia创建的库。

用直接指代读取SAS数据集可以直接用引号+路径的方式读取永久数据集，比如打印magnolia数据集可以：

 

 

   

输出窗口如下：

   

 

### 2.22 列出SAS数据集目录

由于SAS是自文档化，即在自动储存了数据集的信息，因此可以通过contents过程来查看SAS数据集的描述。

Proc contents data=data-set

如果遗漏了data=的语句，SAS自动列出最近创建的数据集。

**例子** 如下的程序创建了一个数据集，并且使用proc contents。数据步中使用了label语句，label语句为变量打上标签，并储存在数据集中，在打印时会显示。过程步中也可以使用label，但只在proc contents中有效，不会储存在数据集中。Informat和format可以指定信息和格式，储存在数据集中，也可以在过程步中使用，但不储存在数据集中。

   

输出如下：

   

输出先显示了数据集的信息，然后介绍了每个变量。

   




## 第三章 开发你的数据

### 3.1 创建并重新定义变量

可以通过分配语句来创建并重新定义变量，基本形式为：

Variable=expression

Variable是变量名，expression可以是常量、其他变量、或者数学表达式。分配语句的基本类型有：

   

Expression是数学表达式时，需要遵循运算法则，先算指数、再算乘除、之后是加减。可以用括号改变运算等级。

**例子** 如下是一个农产品估重数据，每位农民要求对他们的番茄、南瓜、豌豆、葡萄进行估重：

   

下面代码从garden.dat原始文件中读取数据，并进行修改：

   

这个程序包含了5句分配语句，第一个将14赋值给zone，第二个使type等于一个字符串常量……打印出的结果中，既包括旧变量，又包括新变量：

   

由于观测值susan的peas变量出现了缺失值，因此这个观测值的total和pertom变量也出现了缺失值。日志窗口的说明如下：

NOTE:Missing values were generated as a result of performing an operation on missing values.

### 3.2 使用SAS函数

SAS有400多个函数，主要涵盖如下领域:

   

函数基本形式：function-name(argument,argument,…)，所有的函数都需要括号，即使没有参数。下面的程序计算使用MDY函数，MDY函数需要三个参数：月、日、年。

Birthday=MDY(MonthBorn,DayBorn,YearBorn);

函数可以嵌套，即一个函数可以是另一个函数的参数。比如：NewValue=INT(LOG(10));

**例子** 有一个南瓜雕刻比赛的数据，pumpkin.dat数据包含了参赛者的名字、年龄、雕刻的南瓜类型、报名日期、五位裁判给出的分数。

   

下面的代码读取了数据、创建了两个新变量、转换了一个大小写：

   

AvgScore 使用均值函数创建的变量，计算参数的均值，这与直接相加再除以5不同的地方在于，当参数中出现缺失值时，直接相加再除的方法返回缺失值，而均值函数计算非缺失参数的均值。

DayEntered变量使用DAY函数，返回日期在一个月里的天数。

Type用大写转换函数将原来的字母转换成大写字母。

结果是：

   

 

### 3.3 选出的SAS字符函数

### 3.4 选出的SAS数值函数

### 3.5 使用IF-THEN语句

条件语句IF-THEN的基本形式为：IF 条件 THEN 执行;

比如：IF Model='Mustang' THEN Make='Ford';

条件语句中的一些基本比较符号：

   

还有IN比较符，比如这句中IF Model IN('Corvette','Camaro') THEN Make='Chevrolet';代表当Model为Corvette或Camaro的时候，将Chevrolet赋给Make。

一个条件只能有一个执行，如果要多个执行，则需要DO和END关键字。

   

可以用AND和OR来定义多个条件：IF Model='Mustang' AND Year<1975 THEN Status='classic';

   

**例子** 如下的数据包含了模型的名字、年份、制造商和颜色：

   

下面的代码从cars.dat的原始文件中读取数据，使用IF-THEN语句填满缺失值，并创建一个新变量Status

   

输出结果如下：

   

 

### 3.6 用IF-THEN语句将观测值分组

IF THEN/ELSE的一般形式为：

IF condition THEN action;

ELSE IF condition THEN action;

ELSE IF condition THEN action;

用else语句与直接用多个IF-THEN语句比起来，有两个优势，第一是更有效率，电脑将占用更少的时间；第二是else可以确保你的两个condition之间互斥。

有时候最后一个ELSE只有action，没有IF-THEN：

   

**例子** 有一个住房改善的数据，home.dat，包括了姓名、改善工作、改善成本：

   

下面的代码读取数据，并新建了一个CostGroup的变量。根据Cost的值将数据分成high、medium、low和missing三类：

   

输出结果是：

   

 

### 3.7 构造子集

IF语句可以构造子集，取数据集中的部分数据。

基本形式为：IF+expression;  比如：IF Sex='f';

如果IF条件中的数据是真，则数据步将继续执行。

还可以使用DELETE语句，来删除哪些不要的数据： IF expression THEN DELETE;

这两句话是等价的：IF Sex='f'; IF Sex='m' THEN DELETE;

**例子** 有关于莎士比亚歌剧的清单，Shakespeare.dat，包含歌剧名、首次表演年份、类型：

   

下面的代码读取数据，并且用IF语句构造一个只包含喜剧（comedies）的子集：

   

输出结果如下：

   

观察日志有时能很好的保证我们截取了我们要的数据：

   

在这个例子中，用DELETE等价的语句为：

IF Type='tragedy' OR Type='romance' OR Type='history' THEN DELETE;

### 3.8 处理SAS的日期数据

日期数据的处理很棘手，有的月份有31天、有的30天、有的28天。SAS简化的日期数据，将所有的日期转化成一个以1960年1月1日为起点的数。比如：

   

SAS处理日期数据的三个工具为：读取数据的informats，使用数据的函数（functions），打印数据的formats。

**Informats** 读取日期数据需要用formatted input。比如，如何告诉SAS用MMDDYY10. informats读取名为BirthDate的变量：

INPUT BirthDate MMDDYY10.;

**设定默认的百年** 07/04/76这样的数据可能是1976，也可能是2076、1776。因此需要YEARCUTOFF=来指定一个一百年的第一年，默认的是1920年。下面的语句就是告诉SAS将一个两位年份的日期解释为1960年到2049年之间：

OPTIONS YEARCUTOFF=1950;

**SAS****表达式中的日期** 一旦被以SAS日期格式读取之后，可以将此数据想其他数值数据一样用在表达式中。比如像为图书馆的书设定21天的还书日期，只需要在结束日期上加上21：

DueDate = CheckDate + 21;

通过在表达式中加入引号和字母D，可以将一个日期当做常数来使用，如下的代码创建了一个EarthDay05的变量，并且等于April 22,2005

EarthDay05='22APR2005'D;

函数 SAS日期函数使得操作大大简便，比如today（）返回今天的日期。

语句DaysOverDue=TODAY()-DateDue;可以计算一本书应归还的剩余期限。

**Formats**打印日期数据时，还需要将数值换成日期，下面的FORMAT语句告诉SAS用WORDATE18.格式打印变量BirthDate。

FORMAT BirthDate WORDATE18.;

**例子** 图书馆有借书卡数据，Dates.dat，包含持卡人姓名、出生日期、卡办理日期。

   

下面的代码读取数据，计算变量使用期限（expiredate），使用期限为3年；变量expirequarter计算使用期限的四分之一，使用函数QTR（）。接着用IF语句来判断一个卡是否为新卡，在2003年1月1日之后办理的，为新卡：

   

输出结果为：

   

注意BirthDate没有用日期格式。

### 3.9 可选择的Date Informats、Functions和Formats

   

   

   

 

下面是例子：

   

   

   

 

### 3.11 使用retain和sum语句

当开始数据步的每一个观测值迭代时，SAS会先将所有变量值设为缺失，再通过input和分配语句改变。Ratain和sum语句可以改变这种方式。

**Retain****语句** retain语句可以让SAS保存前一次变量的值。它可以出现在数据步的任何位置，基本形式为： 

RETAIN variable-list;

也可以指定一个初始值，而不是用缺失值或前一次的值代替初始值

RETAIN variable-list initial-value;

**Sum****语句** SUM语句用于你想将一个表达式的值累加到一个变量上去时，基本形式为：

variable+expression;

这个语句将表达式的值赋给变量，同时将变量的值保留到下一次迭代。这个变量必须是数值型，且初始值为0。因此，语句等价于如下形式：

RETAIN variable 0;

variable=SUM(variable,expression);

例子 有一个关于本赛季棒球比赛的数据，games.dat，包含比赛日期、参赛队伍、hit数据、runs数据

   

现在需要增加两个变量，一个反应本赛季的总runs数，一个反应一场比赛中最大的runs数。下面的代码用sum语句实现总run数，用retain和max函数实现最大runs数：

   

变量maxruns取前面迭代的maxruns和runs中最大值；变量runstodate将每一场比赛的runs都加到自己身上。结果如下：

   

 

### 3.12 用数组简化程序

对于太多变量要处理的程序，数组将大大简化程序。

SAS中，数组是一组变量，变量可以是已存在的，也可以是新创建的。

数组在数据步中用ARRAY来定义，基本形式为：

ARRAY name(n) $ variable-list;

Name是数组名，n是变量数，()也可以用[]和{}代替。如果变量是字符串，则需要$，且变量是新创建的字符串时，$是必须的。变量名依照顺序排列，如数组：

ARRAY store(4) Macys Penneys Sears Target;

则store(1)是Macys，store(2)是Penneys，store(3)是Sear，store(4)是Target。

数组本身不储存在数据集中，只有在数据步中才被定义。命名规则与变量一样（不超过32字节，以字母、下划线开头，只能包含字母、数字、下划线）

**例子** 广播电台wbrk做了一份关于歌曲的听众调查，对10首歌进行打分，分值在1-5，如果没听过则填9。数据文件wbrk.dat包括了被访者姓名、年龄、以及十首歌的打分。

   

下面的代码将所有打分为9的改为缺失值：

   

十首歌被放入song的数组中。输出结果如下：

   

注意这里数组没有被保存到数据集中，而i被保存了。

 

### 3.11 列出变量名的快捷方式

如果想把100个变量放入数组，并不需要一个一个变量名的输入，有快捷方式可以列出变量名。

**Number range lists** 开始于同一个单词，结尾于连续的数字的，可以使用Number range list。比如：

   

**Name range lists** 这种列表是依据变量在数据集中的排列顺序来的，比如，创建如下数据步：

   

则变量的排列顺序就为：Y A C H R

那么可以依照这个顺序用“put 第一个变量--最后一个变量”来简化：

   

如果不能确定数据集中变量的顺序，可以用proc contents的postion选项来查看。下面的代码列出了永久数据集distance的变量顺序：

   

**Special sas name list** 特别的名字列表，_ALL_、_CHARACTER_、_NUMERIC_可以用于任何你想使用的地方，所有的变量，所有的字符变量，或所有的数值变量。当你想要做某些事的时候，例如计算一个观测的数值型变量的平均值（MEAN（of _NUMERIC_）），或列出的所有观测中的变量值（PUT_ALL_;)，这些名单是有用的。

 

**例子** 广播电台WBRK想要修改前面的代码（将9改为缺失值），使用mean函数计算平均分数：

   

程序中，当原始变量（domk-ttr）值为9时，song变量值为缺失值，否则就把原始变量的值赋给song变量。另外avgscore计算平均值：

   




## 第四章 排序、打印并描述你的数据

### 4.1 使用SAS过程步

​     使用过程步就像填写一个如左图的表格，当然每个过程步都有独特的地方，本部分主要讨论各过程步相同的地方。

大部分过程步都有一个必须的语句，也有可选的语句，比如打印语句：proc print，这两个词是必须的，但可选的语句也有很多。

 

**Proc****语句** 所有的语句的必须部分为proc+过程名，比如print、contents等。后面接一些可选项。比如proc print data=banana；

data=banana选项告诉SAS打印哪个文件，如果不加，则SAS默认打印最近使用的数据。前面还可以加libname语句，建立一个对本地文件的链接（2.20），比如：

LIBNAME tropical 'c:\MySASLib';

​       PROC CONTENTS DATA=tropical.banana;

或者直接引用（2.21）：PROC CONTENTS DATA='c:\MySASLib\banana';

 

**BY****语句** BY语句只在过程proc sort中是必须的，它用来对观测值排序。其他过程BY告诉过程对变量进行分别分析，且是可选的。比如要对每个州进行分别分析，则为：BY State

另外，除了proc sort，其他过程都假设了数据已经进行了排序，所以如果数据还没有排序，那么在分析之前要用proc sort排序。

 

**TITLE** **和****FOOTNOTE****语句** 这是为输出加上标题和脚注。最基本的title语句为：title ‘标题’，双引号、单引号皆可，比如：

TITLE 'This is a title';

如果标题中带有撇号，则需用双引号，或者将撇号换为双撇号：

TITLE ”Here’s another title”;

TITLE ’Here’’s another title’;

可以通过在title、footnote后面加上数字来添加多个标题和脚注：

FOOTNOTE3 ’This is the third footnote’;

但是小数字的标题会代替大数字的标题，如title2会代替title3。

标题的去除可以用title+空值：TITLE; footnote+空值：footnote;

 

**Label****语句** 它可以为输出的变量加上标签，一个标签最大256字节，下面的代码为receivedate和shipdate创建了标签：

LABEL ReceiveDate=’Date order was received’

ShipDate=’Date merchandise was shipped’;

注意的是，在数据步中使用label语句，则标签会保存在数据集中；在过程步中使用，标签只在这个过程中有效。

 

**定制输出** 使用系统选项，可以为输出设置诸如居中、日期、单行长度、页长度等。使用Output Delivery System，还可以改变输出的风格，以不同的格式输出（HTML、RTF），甚至改变输出的任何细节。

 

**输出数据集** 可以用ODS OUTPUT语句为输出结果创立一个数据集（5.3），一些过程中也可以用out=option。

 

### 4.2 用where语句在过程中构造子集

也可以用where构造子集，它方便快捷，因为他不创建新的数据集。且能够用在过程步中。

Where语句的基本形式为：

WHERE condition;

只有满足条件的观测值才进行proc过程。

一些使用最多的操作符及例子：

   

**例子** 有一份关于画家的数据，artists.dat，包含画家的姓名、主要风格、国籍：

   

第一步首先是数据步，读取数据、使用直接指代在C盘mysaslib目录下创建一个名为style的数据集。

   

某天如果想打印出印象派impressionism画家的情况，那么可以使用where语句

   

输出结果为：

   

 

### 4.3 用proc sort为数据排序

基本形式为：

PROC SORT;

​           BY variable-1...variable-n;

SAS首先会按照第一个变量排序，再对后面的排序。

Data=，out=用来指定输入和输出数据，如果缺失out=，则SAS会将排序后的数据集代替原来的数据集。下面的代码告诉SAS对数据messy排序，并将排序后的数据存在neat中：

PROC SORT DATA=messy OUT=neat;

选项nodupkey告诉SAS排序时删除重复值，比如：

PROC SORT DATA=messy OUT=neat NODUPKEY;

SAS默认是升序，可以用选项DESCENDING来变成降序，将DESCENDING加在要降序的变量前面：

BY State DESCENDING City;

**例子** 下面的数据显示了一些鲸鱼和鲨鱼品种的平均长度：

   

下面的代码读取并排序数据

   

输出结果为：

   

因为SAS认为缺失值是比字符串和数值都小，所以排在了第一位。另外，由于whale shark 40的数据有两个，故因为nodupkey选项而被删除一个。说明可见日志：

   

 

### 4.4 用proc print打印你的数据

基本形式：PROC PRINT;

SAS默认打印最近使用的数据集，DATA=可以指定数据集：

PROC PRINT DATA=data-set;

SAS默认打印观测值数，noobs选项可以取消。SAS默认打印时用变量标签代替变量，用label可以改变取消：

PROC PRINT DATA=data-set NOOBS LABEL;

还有下面的选项：

BY variable-list; 前提是数据必须进行排序

ID variable-list; 指定观测变量

SUM variable-list; 打印变量总数

VAR variable-list; 指定打印哪部分变量以及打印顺序，默认打印全部。

 

**例子** 有学生卖糖果的数据，Candy.dat，记录学生名、所属班级、销售日期、卖的糖果类型、卖出的糖果数。

   

下面的程序读取数据、计算每个学生赚得的利润（每买一块赚1.25美元），并用proc sort按班级排序。接着在proc print语句中加入by，以分班级打印，加入sum，计算每个班级总利润：

   

输出结果为：

   

 

### 4.5 用formats改变打印外观

打印数据时，SAS会自动为你安排最好的格式，小数点位数、空格等。

当不需要默认格式时，可以用SAS formats改变打印的外观。

对于字符串、数值、日期变量，SAS有很多格式。比如可以用commaw.d格式打印有逗号的数字，用$w.格式控制打印的字符数，用MMDDYYw.格式将日期（以1960.1.1为基点的数字）打印成12/03/2003这样的格式。甚至可以将格式打印成十六进制、区位十进制、压缩十进制等。

SAS格式的普通形式为：

   

符号说明：$说明了是字符串、format是格式名、w是包括在小数点在内的长度、d是小数位数。句号非常重要，它用来区分格式名和变量名。

 

**Format****语句** 可以用format语句同时将格式和变量联系起来，用format+变量名+格式名，比如想要将格式DOLLAR8.2和变量profit、loss联系起来，把格式MMDDYY8.和格变量saledate联系起来：

FORMAT Profit Loss DOLLAR8.2 SaleDate MMDDYY8.;

Format可以用在数据步和过程步中，前者将把格式永久储存，后者只是临时储存。

注：DOLLAR8.2表示打印的结果字符数不超过8（数值+$）。

 

**Put****语句** 当写原始数据或者报告时，也可以在put语句中使用formats，在每个变量后面加上格式：

PUT Profit DOLLAR8.2 Loss DOLLAR8.2 SaleDate MMDDYY8.;

 

**例子** 在上面的学生卖糖果的案例中，可以看到输出的日期是SAS日期值，这里用format变换成日期格式，并且用DOLLAR6.2将利润换成货币格式，

   

输出结果为：

   

 

### 4.6 可供选择的formats

   

   

下面是

​      

 

### 4.7 使用proc format创建自己的格式

有时候用数字代表实际的变量值，比如1代表男性，2代表女性，这种代码在打印的时候不好解读，可以用proc format使得打印出想要的值。

基本形式为：

   

Value语句中的name是格式的名字，如果格式是位字符串设计，则必须以$开头，长度不能超过32个字节（包括$），不能以数字结尾，除了下划线不能包含其他任何特殊符号。且名字不能与已有的格式名冲突。Range是分配给等号右边文本的变量值，文本可以达到32767个字节，有的过程只会打印前面8或16个字节。下面是一个例子：

   

变量值是字符串时要加上引号，range不止一个值要用逗号隔开，连续的range要用-，关键字low和high可以用来指代变量中最小和最大的非缺失值。也可以用<来排除或指代某些范围，但"<"来表示不包括范围的结尾值。other可以给任何没有列在value语句中的变量分配格式。

 

**例子** 有一份关于汽车公司客户的调查信息。包括客户年龄、性别（1为男性，2为女性）、每年收入、偏爱的汽车颜色（yellow,gray,blue,or white）：

   

下面的代码读取数据，并使用format过程为颜色、性别和汽车创建格式，并在打印数据时用format为变量指定这些输出格式：

   

输出结果为：

   

 

### 4.8 定制一个简单的报告

数据步可以帮助在报告中完成一些个性的需求，比如一页打印一个观测值等。

用file语句和put语句 ，基本形式为：

FILE‘file-specification’PRINT;

如input，put语句也有list，column，formatted方式，但因为SAS已经知道变量类型，因此不用符号$。且如果使用list，SAS会自动在两个变量之间加上空格；使用column或者formatted，SAS将会把变量放在任何你指定的地方。使用指示器@n指定移动到第n列，+n指定移动n列，/跳动到下一行，#n跳动到第n行。用@hold住当前行。

 

**例子** 再一次使用学生卖糖果的案例，Candy.dat，记录学生名、所属班级、销售日期、卖的糖果类型、卖出的糖果数。

   

老师想看每位学生的销售情况，故要每页分别打印一位学生的情况，代码如下：

   

   

Data _null_是告诉SAS不要写数据集名，以便使得程序更快。File语句创建了一个输出文件，空标题title语句告诉SAS去除所有的自动标题。

第一个put语句以一个指示器开头，@5，告诉SAS移动到第5列，接着打印出“candy sales report for”，后面是姓名name。变量name、class和quantity都是以list方式打印，而profit是使用formatted方式打印，并给定格式dollar6.2。一个斜杠是指跳到下一行，两个斜杠是跳到下两行。最后，语句put_page_是在每个学生报告下面插上页码，程序运行后，日志说明如下：

   

前三页报告如下：

   

   

   

 

### 4.9 使用proc means描述数据

可以用proc means查看一些简单的统计量，Means过程开始于关键词proc means，后面接需要打印的统计量，基本形式：

PROC MEANS options;

如果不加选项，则默认打印出非缺失值个数、均值、标准差、以及最大最小值，下面是用选项可以查看的统计量：

   

如果没有其他语句，proc means语句会给你数据集中所有观测值和所有数值变量的统计量，这里是一些可以用到的语句：

l  BY variable-list; 分变量单独分析，但数据必须先按照variable-list的变量顺序排序（proc sort）。

l  CLASS variable-list; 也是分变量单独分析，看起来会更集中一些，且不需要排序。

l  VAR variable-list; 指定分析中使用哪种数值变量，默认则使用所有的数值变量。

 

**例子** 有一个花朵销售的数据，Flowers.dat，包括顾客ID，销售日期，petunias，snapdragons，marigolds三种花的销售量：

   

下面的代码读取数据，计算新变量销售月份month，并使用proc sort按照月份排序，并使用proc means的by语句来按照月份描述数据：

   

输出结果为：

   

 

### 4.10 将描述性统计写入SAS数据集中

有两种方法可以在SAS数据集中储存描述性统计量，Output Delivery System(ODS)，或者output语句。前者在5.3，后者的基本形式为：

OUTPUT OUT=data-set output-statistic-list;

Data-set是要储存结果的数据集名，output-statistic-list则界定需要保存哪些统计量和名称，可能的形式为：

statistic(variable-list)=name-list

statistic可能是proc means语句中的任何一种统计量（sum，n，mean…），variable-list则界定VAR语句中哪些变量需要输出，name-list则定义统计量的新名字。比如，proc means语句产生了一个数据集ZOOSUM，包括一个观测值和变量lionweight（the mean of the lions’ weights），BearWeight（the mean of the bears’ weights）。

   

Noprint是告诉SAS不需要产生任何打印结果，因为已经将结果存入数据集中。

 

**例子** 仍然是花朵销售的数据

   

要描述数据，每个顾客只有一个观测值，包括SUM和MEAN，并且将结果储存到数据集中以便日后分析。下面的程序读取程序，按照CustomerID排序，使用means过程，结果存在totals数据集中。以原始名Petunia,SnapDragon,Marigold给出sum，以新变量名MeanPetunia,

MeanSnapDragon,and MeanMarigold给出mean。

   

结果如下：

   

 

### 4.11 用proc freq为数据计数

对一个变量计算频数叫做one-way，两个叫做two-way，多个叫做交叉表。使用proc freq最明显的目的是现实分类数据的分布情况，基本形式为：

PROC FREQ;

​      TABLES variable-combinations;

产生一维频率表，只要列出变量名。下面的语句列出了变量yearseducation的每一个值的个数。

TABLES YearsEducation;

建立两个变量的交叉表需要一个*号，下面的语句显示变量Sex by YearsEducation的频数情况：

TABLES Sex*YearsEducation;

这个语句之后可以用/option的形式添加选项，主要下面几个：

LIST：用list形式打印交叉表（而不是网格）

MISSING：频率统计量中包含缺失值

NOCOL：强制在交叉表中不打印列百分比

NOROW：强制在交叉表中不打印行百分比

OUT=data-set：输出数据集

比如说，使用第二个选项：TABLES Sex*YearsEducation/MISSING;

 

**例子** 有一家咖啡店的销售数据，记录了销售的咖啡种类（cappuccino,espresso,kona,or iced coffee），以及每次购买的顾客是打包还是原地就饮：

   

下面的代码就产生了一个one-way和two-way的频率表：

   

代码告诉SAS打印两个表，一个是one-way的频率表，一个是交叉表。交叉表的每个小方格内，SAS打印了频数、百分比、行百分比和列百分比。左边和右边是累积百分比。注意计算频数时没有考虑缺失值。

   

 

### 4.12 用proc tabulate产生一个表格报告

比起print means和print freq，Proc tabulate过程产生的报告更耐看。

Proc tabulate的基本形式为：

PROC TABULATE;

CLASS classification-variable-list;

TABLE page-dimension,row-dimension,column-dimension;

Class语句告诉SAS哪些变量将数据分成不同部分。

Table语句可以定义一个表，可以用多个table语句定义多个表，

 

**维度** table语句可以在报告中指定三个维度：页、行、列。如果只指定一个维度，则默认是列维度；如果指定两个，则是行和列。

 

**缺失数据** 默认下不考虑缺失数据，在proc语句后面增加missing选项可以改变这种默认：

PROC TABULATE MISSING;

 

**例子** 有关于船的一些数据，Boats.dat，记录了每艘船的姓名、港口、移动方式（sailing或者power vesse），类型（schooner,catamaran,or yacht），使用它远行的价格

   

你想得到一份报告，包含了每一个港口的、sailing或者power vessel的、每一种类型的、船的数量，下面的代码用proc tabulate创建了一个三维报告：港口作为页、移动方式作为行、类型作为列：

   

报告分两页，港口的每个值情况为一页：

   

 

### 4.13 为proc tabulate输出增加统计量

Class语句列出分类变量，而VAR语句告诉SAS那些变量包含连续数据。基本形式为：

PROC TABULATE;

VAR analysis-variable-list;

CLASS classification-variable-list;

TABLE page-dimension row-dimension column-dimension;

 

**关键词** 下面是tabulate可以计算的值：

ALL:增加行、列或页，显示总数

Max：最高值

Min：最低值

Mean：算术均值

Median：中位数

N：非缺失值个数

Nmiss：缺失值数

P90：90th分位数

Pctn：某类的观测值百分数

Pctsum：某类值总和的百分数

STDDEV：标准差

SUM：求和

 

**Concatenating,crossing,and grouping** 一个维度中，变量或关键词可以被连接、交叉、分组。连接变量或关键词，只需用空格分开列出即可；变量或关键字交叉只需要用*分开列出即可；分组只需要用括号括住变量或关键词。

Concatenating:                          TABLE Locomotion Type ALL;

Crossing:                               TABLE MEAN*Price;

Crossing,grouping,and concatenating:        TABLE PCTN*(Locomotion Type);

 

**例子** 仍然是船的例子，

   

下面的代码类似4.12，但多了VAR语句，table只包括两维，但使用了Concatenate,cross,and group：

   

输出结果如下：

   

 

### 4.14 提升proc tabulate的输出外观

三种方式可以提升输出的外观：

**Format=** **选项** 可以改变数据的格式，比如，在表中使得数字有逗号，并不含小数，则使用：

PROC TABULATE FORMAT=COMMA10.0;

**Box=****和****misstext=** **选项** format只能用在proc语句中，而box=和misstext=只能用在table语句中。box=的作用是在tabulete报告的左上角的空格中写下一句简洁的语句（作用类似标题）。Misstext则是为空数据格指定一个值，默认是一个句号，比如下句：

TABLE Region,MEAN*Sales/BOX='Mean Sales by Region' MISSTEXT='No Sales';

这是告诉SAS在左上角打印“Mean Sales by Region”，并且在没有数据的方格内打印“No Sales”

 

**例子** 仍然是船的数：

   

如下代码比前面多了format、box、misstext语句。注意format要出现在proc语句中，而box和misstext语句则出现在table语句中。

   

这是“被提升了的”外观，由于format指定dollar9.2，因此都用货币格式输出。左上角的full day excursions是由于box语句，空方格内的none是由于misstext语句。

   

 

### 4.15 改变proc tabulate输出的表头

有两种方法可以改变顶部信息

**Class** **变量** **变量值** 要改变class语句列出的变量值的表头，使用format创建一个用户定义的格式，然后用format语句将格式赋给变量。

**变量名和关键字** 改变变量名和关键字的表头，用=’text’赋值即可，可以用等号加空值的方法去除表头，即=’’，语句为：

TABLE Region='',MEAN=''*Sales='Mean Sales by Region';

这是告诉SAS移去region和mean的顶部，并且将sale的表头换为“Mean Sales by Region”

有时候当行顶部被赋为空格时，会留下一个空白空格，可以用row=float强制去除这种空白空格：TABLE MEAN=''*Sales='Mean Sales by Region',Region=''/ROW=FLOAT;

 

**例子** 仍然是船的数据：

   

下面的代码和以前一样，多了对表头的改变，format语句创建了一个用户定义的格式$typ，并用format语句把这个格式赋给变量type，table语句中locomotion、mean、type的表头被赋为空格，price的表头被赋值“Mean Price by Type of Boat.”

   

输出结果为：

   

这样的结果看起来清晰且紧凑。

 

### 4.16 为proc tabulate输出的数据方格指定多种格式

可以为不同变量指定不同格式，基本形式为：

variable-name*FORMAT=formatw.d

比如在table语句中插入这个复杂的语句：

TABLE Region,MEAN*(Sales*FORMAT=COMMA8.0 Profit*FORMAT=DOLLAR10.2);

这是给变量sales指定格式comma8.0，给变量profit指定格式dollar0.2。

 

**例子** 仍然是船的数据，新增加了一个变量，以显示船的长度：

   

假如你想在报告中同时show出平均价格和平均长度，仅为价格指定货币格式。下面的代码这样实现，为变量price指定格式dollar6.2，为length指定格式6.0：

   

输出结果如下，注意价格和长度的格式不一样：

   

 

### 4.17 用proc report产生一个简单的输出

Report包含print、means和tabulate、sort的所有功能，可以用一本书来介绍，基本形式为：

​      PROC REPORT NOWINDOWS;

COLUMN variable-list;

Column语句类似于proc print的var语句，告诉SAS哪些变量该包括并以何种顺序，如果遗漏语句column，SAS默认在数据集中包括所有变量，如果遗漏选项NOWINDOWS，SAS默认启用交互report窗口。

默认情况下，PROC报告立即在列标题下方打印数据。为使数据和顶部能很好的区分开来，可以使用headline和headskip：

PROC REPORT NOWINDOWS HEADLINE HEADSKIP;

Headline在顶部下面拉了一条线，headskip在顶部下面留了一段空白。

 

**数值变量****VS****字符串变量** 从proc report得到的报告类型，部分依据于使用的数值类型。只要报告中起码有一个字符串变量，默认的报告就是每个观测值一行。但如果报告全是数值变量，默认proc report将会加总这些变量，即使是日期变量也会被加总。

 

**例子** 有一份关于美国国家公园（national parks）和国家纪念碑（monuments）的数据，Parks.dat，变量包括名字、类型（NP for national park or NM for national monument），地区（East or West），博物馆的数量，野营地的数量：

   

下面的代码形成了两份报告，第一份没有column语句，SAS使用所有变量，第二份使用column语句，选择部分变量：

   

第一份报告与proc print相似，第二份报告，由于只选择museum变量和camping两个数值型变量，默认直接显示加总情况：

   

 

### 4.18 在proc report中使用define语句

Define用来为单个变量指定一些选项，基本形式为：

DEFINE variable/options’column-header’;

 

**Usage****选项** 这个选项告诉SAS如何使用这个变量，可能的usage选项包括：

Across：为变量的每一个变量值都创建一个列

Analysis：为变量创建统计量，数值变量默认有这个usage选项，且统计量默认为sum。

Display：为数据集中的每一个观测值都创建一行，对于字符串变量，这个选项是默认的。

Group：为每个变量的变量值都创建一行。

Order：为每个观测值都创建一行，且行值的排列是按照指定的变量来顺序。

 

**改变列表头** proc report中几种方法可以改变列表头，4.1中的label语句，或者用define语句指定列表头，下面的代码使得SAS的report按照age排序，并且以“Age at Admission”作为列顶部：

DEFINE Age / ORDER 'Age at/Admission' WIDTH=9;

您可能需要指定的width选项，使您的列表头适合它。在这个例子中，Admission这个词有9个字符，所以宽度必须至少为9。

 

**缺失数据** 默认在order，group，和across variables中不考虑缺失值，用missing选项可以改变这种默认：

PROC REPORT NOWINDOWS MISSING;

 

**例子** 仍然是关于国家公园和纪念碑的数据：

   

下面的代码包含两个define语句，第一个用order选项来定义region，第二个为变量camping定义列表头。Camping是一个数值变量，默认有analysis选项。Missing选项也出现在了proc语句中，因此缺失值也会被考虑在报告中：

   

输出结果为：

   

Region有三个变量值，第一个是missing缺失值。

 

### 4.19 用proc report创建简易报告

Group创建简易行，across创建简易列。

 

**Group** **变量** 下面的代码告诉SAS创建一个显示每个部门工资总和、奖金总和（数值变量将默认被加总）的报告：

   

 

**Across****变量** 为了定义acorss变量，也需要define语句，不同的是，SAS默认不是对变量值求和，而是计数。如果要加总，则需要在across变量和analysis变量之间加逗号，告诉SAS哪个变量要加总，下面的代码告诉SAS用列来显示出每个部门工资和奖金的总和：

   

 

**例子** 仍然是国家公园和纪念碑的例子，

   

下面的代码包含两个proc report，第一个中，region和type都被定义成group变量，第二个中，region仍然是个group变量，但type是across变量。注意两个column语句基本一样，除了第二个中增加了逗号将across变量和analysis 变量交叉。

   

输出结果为

   

 

### 4.20 给proc report输出增加summary break

Break语句可以为报告增加停顿，为每个指定的变量的变量值增加停顿。基本形式如下：

​     BREAK location variable/options;

RBREAK location/options;

Location有两种可能值——before和after，决定是之前停顿还是之后停顿。斜杠之后的选项告诉SAS插入哪种停顿，主要类型有：

OL        停顿的地方加入横线

Page       开始一个新的页面

Skip       插入一个空行

Summarize  插入数值变量之和

UL         在停顿下面划线

需要注意的是，break要求指定一个变量，而rbreak不需要。因为rbreak只产生一个停顿（开始或结尾），而break语句为指定的变量的每一个变量值都产生停顿。这个变量必须是group变量或order变量，并且要在define语句中定义过。可以在任何报告中使用rbreak语句，但只能在有最起码一个group或者order变量的报告中使用break语句。

 

**例子** 仍然是国家公园和纪念碑的例子：

   

下面的代码将region定义为order变量，使用break和rbreak语句和after选项，summarize加总数值变量的和：

   

输出结果为：

   

 

### 4.21 为proc report输出增加统计量

简单的方法是在column语句中加入统计量的关键字，常用的有：

Max、min、mean、median、n、nmiss、p90、pctn、pctsum、std、sum

 

**给变量应用统计量** 给变量应用统计量，在变量和统计量之间插入逗号即可，统计量N不需要逗号。如：

COLUMN Age, MEDIAN N;

为多个变量应用多个统计量，需要括号，如下面代码要求一个变量age应用两个统计量min和max；两个变量height和weight应用一个统计量mean：

COLUMN Age, (MIN MAX); (Height Weight),MEAN;

**例子** 仍然是国家公园和纪念碑的数据：

   

下面的代码包括了两个proc report，都应用了统计量N和mean，但第一个定义type为group变量，第二个定义type为across变量。

   

输出结果为：

   




## 第五章 用ODS增强你的输出结果

### 5.1 ODS（Output Delivery System）的概念

过程步不会产生输出，它只会产生数据，然后把数据发送给ODS，以决定输出的样式等。所以，不要考虑是否使用ODS，而考虑怎么使用，是接受默认输出还是改变设置。

ODS就像一家商务飞机，游客乘坐car和bus赶来，在机场确认行李、安检、最终登机，飞往目的地。ODS中，数据就像游客，通过各种过程步而来，ODS处理每一个数据集并发送到目的地。实际上，不同的ODS类型就是目的地，当达到目的地时，数据的样式是由模板决定。模板是一个告诉ODS如何格式化您的数据的指令集。目的地和模板这两个概念的是你了解可以用ODS做什么的基础。

 

**目的地** 如果没有指定目的地，那么你的数据默认发往“列表listing”，这里有几种可选的目的地：

LISTING   标准SAS输出

Output     SAS输出数据集

Html      超文本标记语言

RTF       富文本格式

PRINTER  高分辨率的打印机输出（PS, PCL, and PD）

PS        附言

PCL       Printer Control Language 打印机控制语言

PDF       Portable Document Format

MARKUP  markup languages including XML

DOCUMENT output document

 

**风格和表模板** 模板描述ODS如何制定数据格式并呈现数据。最普通的两个模板类型和是表模板类型和风格模板类型。表模板类型制定基本的输出结构，而风格模板类型制定输出将如何呈现。ODS将过程产生的数据和表模板结合成输出对象，输出对象接着与风格模板结合，并发送到目的地，创建输出。

   

可以使用template过程创建自己的风格模板，但proc template过程晦涩难懂。幸运的是，有一个最简单和最快速的方法控制修改输出，即使用内置风格模板。可用proc template语句来访问内置模板：

 

​        PROC TEMPLATE;

​     LIST STYLES;

RUN;

一些内置模板如下：

   

注意RTF和PRINTER既是目的地名又是风格名。DEFAULT是HTML的默认风格，RTF是RTF输出的默认风格，PRINTER是PRINTER的默认风格。

Print、report、TABULATE三个过程中，可以使用style=option来直接控制输出特征，而不需要创建一个新的模板。

 

### 5.2 追踪选择过程的输出

​     当ODS接受来自过程步的数据时，它将数据与表模板结合。对应的表模板和数据就叫做输出对象。如果使用by语句，SAS会为每一个BY组产生一个输出对象。每一个输出对象都有名字，可以用ODS TRACE语句来查找，并用ODS SELECT语句来选择。

 

**ODS TRACE****语句** ODS TRACE语句告诉SAS打印出SAS日志中输出对象的信息。这里有两个ODS TRACE的语句，一个是打开trace，一个是关闭。使用方法实例如下：

   

注意关闭语句要在run后面，否则在程序运行之前就关闭了trace。

 

**例子** 有关于番茄种类的数据，包括每种番茄的名字、颜色、从播种到收获的天数、典型重量：

   

下面代码创建了一个名为giant的数据集，并使用ODS TRACE ON和ODS TRACE OFF语句来追踪proc means过程。

   

程序运行后，日志窗口中就会有如下的追踪（由于使用了BY语句，故按照BY的组来追踪）：

   

 

**ODS select****语句** 知道输出对象的名字之后，可以用ODS SELECT语句来选择需要的输出对象。基本形式为：

   

Output-object-list是名字、标签、一个或更多的输出对象的路径。

 

**例子** 下面代码对giant运行了proc means，并用ODS SELECT语句选择了第一个输出对象，mean：

   

输出结果为：

   

 

### 5.3 从过程输出中创建SAS数据集

​     有时需要把一个过程的结果弄到SAS数据集中，有的过程用output或out=实现。但用ODS，可以储存从过程输出的任何一部分。首先要使用ODS TRACE语句决定选择输出对象名。然后使用ODS OUTPUT语句将输出对象发送到OUTPUT目的地中。 

 

**ODS OUTPUT****语句** 基本形式为：

ODS OUTPUT output-object=new-data-set;

这个语句不属于数据步和过程步。ODS OUTPUT打开SAS数据集并等待正确的过程输出，数据集保持开放，直到过程步的结尾。因为ODS OUTPUT是立即执行的，它将应用于proc正在处理的数据，或者应用于下一个proc（如果目前没有proc）。为确保得到正确的输出，建议将ODS OUTPUT语句放在PROC语句之后，下一个PROC 、DATA或RUN语句之前。

 

**例子** 仍然是关于番茄的数据：

   

下面是引用与SAS日志，显示由proc tabulate产生的追踪（trace），tabulate产生一个叫做table的输出：

   

下面的代码读取数据、使用ODS OUTPUT语句来创建叫做TABOUT（来自TABLE输出对象）的SAS数据集，然后用proc print打印出新数据集。

   

有两部分输出结果，第一部分是标准tabular结果，有proc tabulate产生。下面是TABOUT数据集，由ODS OUTPUT语句产生，并有proc print打印。

   

 

### 5.4 使用ODS语句创建HTML输出

将输出发送到HTML目的地，将得到HTML格式的文件。这个文件也可以被读入spreadsheets，甚至被打印或导入到文字处理软件中（有些格式会发生变化）。总之，产生一个HTML文件只需两步语句——打开HTML文件、关闭。

**ODS****语句** 将输出发送到HTML目的地，使用ODS HTML语句，基本形式为：

ODS HTML BODY='body-filename.html' options;

Option是用来改变HTML的类型(contents,page,or frame)，

l  Contents=   contents文件是一个链接到主体文件的一个目录表，它将会列出输出的每个部分，点击表中某个条目，相关输出会出现。

l  Page=       page文件类似于contents文件，不同的是，contents通过标签列出输出的每个部分，而page文件通过页码列出。

l  Frame=      frame允许同时访问在不同区域、框架或浏览器窗口中，访问主体文件、contents文件和page文件。

l  Style=       这个选项允许指定一个风格模板，默认的模板名为default。

下面的语句告诉SAS发送一个输出给HTML目的地，储存一个名为AnnualReport.html的主体文件，并使用D3D风格。

ODS HTML BODY='AnnualReport.html' STYLE=D3D;

ODS 语句不属于数据步也不属于过程步，摆放它的好位置是proc过程步之前，这个过程步的输出正是你希望捕捉的。

关闭HTML文件的ODS语句为：

ODS HTML CLOSE;

将这个语句放在proc之后，接在 run语句之后。

输出中包括有些程序（如PROC means和PROC FREQ）过程的名称。您可以使用ODS NOPROCTITLE语句删除程序名称，该语句可放在data步之前。

ODS NOPROCTITLE;

 

**例子** 下面的数据是关于选择的鲸鱼或鲨鱼的平均长度（英尺）

   

下面的代码创建了两个输出，一个是来自means过程，一个来自print过程。并且有两个ODS语句，一个创建了四个HTML文件：body,contents,page,and frame，一个是关闭HTML文件。

   

输出结果如下：

   

 

### 5.5 使用ODS语句创建RTF输出

当你创建了富文本格式，可以将其发送到word中，并像word表格一样编辑修改。语句与HTML语句差不多，区别在于option：

**ODS****语句** ODS打开RTF文件的基本形式为：

ODS RTF FILE='filename.rtf' options;

不像HTML，RTF文件只有一种类型，一些option如下：

l  COLUMNS=n  要求一个柱状输出，n是第几列。

l  Bodytitle

l  Sasdate      这个选项告诉SAS当前的SAS会话开始运行时，使用日期和时间。

l  Style=       指定一个风格模板

下面的代码告诉SAS将输出发送到RTF目的地，储存一个名为AnnualReport.rtf的主体文件，并使用FANCYPRINTER风格。

ODS RTF FILE='AnnualReport.rtf' STYLE=FANCYPRINTER;

放置这个代码的较好位置也是在proc之前，而关闭语句也是放置在proc语句之后，接在run之后。

ODS RTF CLOSE;

 

**例子** 仍然是鲸鱼和鲨鱼平均重量的数据：

   

如下的代码从means和print中产生输出，程序中有两个ODS语句，一个打开RTF文件，一个关闭RTF文件。

   

Marine.RTF文件在word中的结果如下，每一部分的输出结果在不同页面中出现：

   

   

 

### 5.6 使用ODS创建printer输出

**ODS****语句** 打开printer目的地的ODS语句最基本形式为：

ODS PRINTER;

如果使用这个简单的语句，SAS将创建你先在系统需要的输出类型，并自动打印输出，而不是储存文件。可以用add=option来储存输出。类似RTF，只有一种PRINTER类型文件。创建指定的输出类型的基本形式如下面几种：

l  Default printer:      ODS PRINTER FILE='filename.extension'options;

l  PCL:              ODS PCL FILE='filename.pcl'options;

l  PDF:              ODS PDF FILE='filename.pdf'options;

l  PostScript:          ODS PS FILE='filename.ps'options;

目的地一些有效的选项如下

l  COLUMNS=n    要求一个柱状输出，n是第几列。

l  STYLE=         指定一个风格模板

下面的代码告诉SAS创建PostScript output，将结果存在AnnualReport.ps中，并使用FANCYPRINTER风格。

ODS PS FILE='AnnualReport.ps' STYLE=FANCYPRINTER;

放置它的位置也是在proc之前。关闭一个printer文件 ODS语句基本形式为;

ODS destination-name CLOSE;

destination-name可能是PRINTER,PCL,PDF,或者 PS，视开启语句中的目的地而定。放置在proc的run语句之后。

 

**例子** 仍然是鲸鱼和鲨鱼平均重量的数据：

   

如下的代码从means和print中产生输出，程序中有两个ODS语句，一个打开PDF文件，一个关闭PDF文件。

   

在Adobe Acrobat中的输出结果如下，每一部分的输出结果在不同页面中出现：

   

   

 

### 5.7 定制标题和注脚

通过在在title和footnote语句中插入一个简单的选项，可以改变注脚和标题的样式，title和footnote语句的基本形式为:

TITLE options 'text-string-1' options 'text-string-2'…options 'text-string-n';

FOOTNOTE options 'text-string-1' options 'text-string-2 '…options'text-string-n';

可以将一段文字分成不同的部分，每个部分应用不同的样式，可以选择的主要选项如下表：

l  COLOR=   为文本指定一种颜色

l  BCOLOR=  为背景指定一种颜色

l  HEIGHT=   为文本指定高度

l  JUSTIFY=  要求对齐

l  Font=      为文本指定字体

l  Bold       粗体

l  ITALIC    斜体

 

**颜色**  为一段文本不同部分指定不同的颜色

 TITLE COLOR=BLACK 'Black' COLOR=GRAY 'Gray' COLOR=LTGRAY 'Light Gray';

显示为：

   

SAS支持几百种颜色，但有的不能被web等识别，所以安全的颜色为: BLACK,BLUE,

BROWN,CHARCOAL,CREAM,CYAN,GOLD,GRAY,GREEN,LILAC,LIME,MAGENTA,MAROON,OLIVE,ORANGE,PINK,PURPLE,RED,ROSE,SALMON,STEEL,TAN,VIOLET,WHITE,and YELLOW.

 

**背景颜色** 下面是用十六进制码来指定背景颜色：

TITLE BCOLOR='#C0C0C0' 'This Title Has a Gray Background';

显示为：

   

 

**高度** 下面设置高度：

TITLE HEIGHT=12pt 'Small' HEIGHT=.25in 'Medium' HEIGHT=1cm 'Large';

单位分别为像素、英尺、厘米，显示为：

   

**对齐** 下面分别设置左对齐、居中、右对齐：

TITLE JUSTIFY=LEFT 'Left' JUSTIFY=CENTER 'vs.' JUSTIFY=RIGHT 'Right';

显示为：

   

**字体** 示例：

TITLE 'Default' FONT=Arial'Arial'

FONT='Times New Roman' 'Times New Roman' FONT=Courier'Courier';

显示为：

   

**加粗与斜体** 默认下，标题是加粗且斜体的。关闭粗体和斜体要用FONT=option，示例：

TITLE FONT=Courier'Courier'

BOLD'Bold'BOLD ITALIC'Bold and Italic';

显示为：

   

 

### 5.8 用style=option定制proc print输出

用ODS中的style=option可以改变输出的整体外观，但是如果要只改变头部，或者其中一列，要在print、report和tabulate过程中用style=option。

Proc print语句中使用Style=option的基本形式为：

PROC PRINT STYLE(location-list)={style-attribute=value};

location-list说明了表中的哪一部分将应用风格，style-attribute是要改变的风格属性，value是属性值。下面的代码将data部分的background属性设为pink：

PROC PRINT STYLE(DATA)={BACKGROUND=pink};

下面是可以指定改变风格的部分：

DATA           所有的数据单元

HEADER        列标题（变量名）

OBS            OBS列，或者ID列（如果使用ID语句）的数据

OBSHEADER    OBS列或ID列的标题

TOTAL         有sum语句产生的总和行的数据

GRANDTOTAL   

在print中放置style=改变的是全表。比如header会改变全表的头部，如果只想改变某列的头部，需要在VAR语句中使用style：

VAR variable-list/STYLE(location-list)={style-attribute=value};

仅有variable-list中的变量会被改变风格。想要不同的变量有不同的风格，可以使用复合VAR语句。

 

**例子** 下面是关于女子5000米滑冰奥运会金牌获得者的数据，变量依次为：奥运年年份、国家、时间、比赛记录（有WR的表示是世界记录）。

   

下面的代码用proc print创建了HTML文件，使用的是默认风格模板。

   

结果如下：

   

下面的代码使用了style来改变所有数据单元的背景：

   

结果如下：

   

下面的代码增加VAR语句，将record列的字体改为斜体和粗体：

   

结果为

   

 

### 5.9 用style=option定制proc report输出

与5.8类似，基本语句为：

PROC REPORT STYLE(location-list)={style-attribute=value};

比如，如果想创建一个名为MYSALES的报告，并将列标题设置为绿色：

PROC REPORT DATA=mysales STYLE(HEADER)={BACKGROUND=green};

如果只需要改变报告中的某一列属性，则需要define语句，下面的语句告诉SAS使用month作为组变量，将其数据和标题的背景改为蓝色：

DEFINE Month/GROUP STYLE(HEADER COLUMN)={BACKGROUND=blue};

还可以用break和rbreak语句为摘要（summary）指定一个风格。下面的语句告诉SAS，对于month的每一个值，为摘要使用红色背景，为总体报告摘要使用橙色背景：

   

 

**例子** 下面是不同的女子5000米滑冰奥运会金牌获得者的数据，变量依次为：姓名、国家、年份、金牌数。每一行包括了两条记录：

   

下面的代码使用proc report创建了一个HTML文件，使用默认模板：

   

结果为：

   

下面的代码使用default风格模板，但在proc report中增加style选项以改变所有数据的背景颜色，并居中：

   

结果为:

   

现在将style添加到define语句中，只改变name这一列：

   

结果为：

   

 

### 5.10 使用style=option定制proc tabulate输出

下面显示了proc tabulate语句中可以应用style的地方，并且影响的表区域：

   

**Proc tabulate****语句** 如果想要来自数据集MYSALES的表的所有数据单元都变成黄色背景：

PROC TABULATE DATA=mysales STYLE={BACKGROUND=yellow};

**Table****语句** 下面的代码使得all列都有红色背景：

TABLE City,Month ALL*{STYLE={BACKGROUND=red}};

CLASSLEV,VAR,和CLASS statements CLASSLEV,VAR,和CLASS语句都是在斜杠/后面应用style语句。注意的是，classlev语句中的变量必须出现在class语句中，下面的代码是将月份month变量的每个值（Jan,Feb,Mar…）的前背景应用为绿色，使用classlev语句如下：

CLASSLEV Month/STYLE={FOREGROUND=green};

 

**例子** 下面是一份关于奥运会男子滑冰的数据，OR是奥运会纪录，WR是世界记录，NONE既不是奥运会记录，也不是世界记录。注意一行有四个观测值：

   

Tabulate过程建立了一个表，以年份作为行，记录作为列。年份和N的顶部都通过设置为null将其消除。ODS语句创建了HTML文件，使用默认模板：

   

结果如下：

   

现在将数据单元的数据居中，并将背景设置为白色：

   

显示结果为：

   

 

### 5.11 为你的输出增加交通信号灯

交通信号灯是基于单元格的值，来控制格的风格。它可以使得重要值变得醒目，它可以在print、report、tabulate中被使用。

使用之前需要做两件事：首先创建用户定义的格式。其次，在style=中将风格属性等于你定义的格式，比如，你创建了一个格式：

   

在print的VAR语句中，将属性值等于这个格式：

VAR Balance/STYLE={FOREGROUND=posneg.};

现在所有balance变量风格都发生变化。

例子 下面的数据是2002年冬奥会中，男子5000米滑冰前五名的数据，包括姓名、国家、成绩（用时）

   

下面代码读取打印数据，生成HTML文件，使用default模板：

   

结果为：

   

想要用信号灯显示每个成绩与世界记录的378.72、奥运记录382.20比较的结果，先创建用户自定义的格式REC，快于世界记录的用红色显示，橙色显示快于奥运记录的，其他颜色设置白色。接着在print语句中增加var语句，使用style=option为时间变量分配风格。最后，将定义的格式REC赋给background。

   

结果如下：

   

 

### 5.12 选择风格属性

​            

 

## 第六章 修改组合SAS数据集

### 6.1 使用SET语句修改数据集

SET语句可以增加新变量、创建子集、修改数据集。SET语句是一次一个变量地，将一个数据集放入数据步中予以分析。基本形式为：

​     DATA new-data-set;

SET data-set;

Data语句指定了新数据集名，set指定要读取的老数据集名。如果不想创建新的，则也可以在data中指定老数据集。

下面的代码创建了一个Friday的新数据集将sales数据集中的day属于Friday的观测值复制，并创建了新变量total：

   

 

**例子** 有一份关于火车运汽车的数据，汽车主为了在高峰期节省时间，或者为了节省汽油，选择让火车运汽车的方法，变量为一天中发车的时间、火车上的汽车数、火车中的人数：

   

数据被读入一个永久数据集trains中，储存在MYSASLIB目录文件夹下：

   

由于每辆车的最大乘客数为6人，现在想知道一列火车上，平均每辆汽车的乘客数是多少，可以在数据中插入一列，但这不在原始数据中计算，而是在一个新数据集中计算：

   

结果如下：

   

 

### 6.2 使用set语句堆叠数据

​     运用set语句可以把一个数据集堆在另一个数据集上，适用于两个变量相同的两个数据集。

基本形式为：

DATA new-data-set;

​     SET data-set-1 data-set-n;

首先指定一个新的数据集，然后列出需要合并的旧数据集。

如果一个数据集包含了另一个数据集没有的变量，那么合并后，该变量下将会出现缺失值。

 

**例子** 有如下两份南北数据，北方数据比南方多了一行变量（最后一行），其他变量均相同：

   

下面有三段代码，前两段将南方和北方的数据各输入数据集，并打印。第三段使用SET语句将南北方数据合并，并创建了新变量，AmountPaid：

   

   

输出结果如下：

   

 

### 6.3 使用SET语句插入数据集

​     前面的堆叠数据，可能把数据顺序打乱，当然可以再用proc sort再将数据排序。但这可能效率低下。在set语句中使用by语句可以高效率的将数据按顺序合并，基本形式为;

DATA new-data-set;

SET data-set-1 data-set-n;

BY variable-list;

BY语句中，可以指定一个或多个变量，让SAS进行排序。

注意，在合并几个数据之前，每个数据都要用BY进行排序，如果没有，则要用proc sort完成。

 

**例子** 仍然是刚才的例子：

   

注意南方的数据已经按照pass number（第二个变量）进行了排序，北方的没有。下面还是三段代码，第一段对南方的数据输入，打印。第二段对北方的数据输入、排序、打印。第三段进行合并，并创建新变量INTERLEAVE。

​      

下面是输出结果：

   

 

### 6.4 一对一匹配合并数据集

​     合并数据集，首先，如果数据没有排序，使用sort过程按照匹配变量排序。之后，在data语句中对新SAS数据集命名，再使用merge语句列出要合并的数据集名。使用BY语句说明共同变量。

  DATA new-data-set;

​               MERGE data-set-1 data-set-2;

   BY variable-list;

注意，如果两个数据集有重叠的变量——除了BY变量，那么第二个数据集中的此变量会覆盖第一个数据集中的。

 

**例子** 有一个巧克力店记录了每天所卖巧克力的类型以及数量，第一个文件sales data记录了所卖的巧克力代码和数量，第二个记录了巧克力代码、所代表的类型、描述。

   

下面有三段代码，前两段读取sales数据，description数据。后者已经对codenum变量进行排序，前者需要用proc sort进行排序。否则会出现错误的信息：ERROR:BY variables are

not properly sorted。

   

结果如下：

   

注意M315的销售记录缺失，因为sales data中 没有关于其的记录。

### 6.5 一对多匹配合并数据

​     一对多合并是指一个数据集中的一个观测值可以与另一个数据集中的多个观测值匹配。

基本形式与一对一一样：

DATA new-data-set;

MERGE data-set-1 data-set-2;

BY variable-list;

注意数据集的顺序，一对多的一要放在前面。在进行合并之前，仍然要对两个数据集按照匹配变量进行排序。其他注意与6.4差不多。

 

**例子** 有一份关于鞋子打折的数据，其中训练鞋、跑步鞋、走路鞋的折扣各不同。第一份数据是关于鞋子的风格、类型、价格。第二份数据是关于每个类型鞋子的折扣：

   

下面的代码用多对一合并了两个数据：

   

结果如下：

   

 

### 6.6合并统计量与原始数据

​     当你想比较每一个观测值和一组变量的均值时，可以先使用proc means计算统计量，并保存输出文件，再与原始文件合并。

 

 

 

**例子** 有一份关于鞋子销量的数据，变量为鞋子风格、类型、销量。现在想列出每种类型鞋子里，各风格的销售量所占的百分比：

   

代码：

   

描述统计量的结果summarydata如下：

   

合并后的数据如下：

   

 

### 6.7 合并total和原始数据

​     可以通过means过程创建一个包含总计（不是分组总计）的数据集。但不能直接与原始数据合并，因为没有匹配变量。幸运的是，可以用两个set语句：

 

 

DATA new-data-set;

​               IF _N_=1 THEN SET summary-data-set;

SET original-data-set;

原始数据包含了不止一个观测值，而summary数据集只有一个观测值。只在数据步的第一次迭代中，SAS读取了summary数据集，之后为新数据的所有变量记住这个变量值。它的工作原理在于SET语句是自动记住的。往常之中，记住的变量会被下一个观测值改写，但这里变量只在第一次迭代的时候读取，并为所有观测值记住，这一技术适用于没有匹配变量的情况下，将一个单个观测值合并到多个观测值中。（注意两个set语句的其他使用）

 

**例子** 与上节同样的例子，现在想看每种类型的鞋子销量占总销量的百分比：

   

代码为：

   

输出结果为：

   

 

### 6.8 用交易数据（transactions）更新主数据集（master）

​     update语句用来更新大量新数据信息。

与merge语句一样，都是按照匹配变量来合并数据，不同点在于：

l  匹配变量的变量值有唯一性。

l  交易数据的缺失值不会改写主数据中存在的值。

基本形式为:

DATA master-data-set;

​                          UPDATE master-data-set transaction-data-set;

 BY variable-list;

只能指定两个数据集，一个是主数据集一个是交易数据，都需要按照匹配变量排序。且BY变量必须具有唯一性。

 

**例子** 一家医院有一份关于病人的主数据。变量依次为病人账户号码、名字、地址、出生日期、性别、保险代码、信息最后被更新的时间。

   

当有新病人，或其他病人再进医院时，信息会被更新，比如，第一个病人的保险代码被更换了、最后一个病人的缺失数据被填补上、有新病人加入：

   

下面的代码将这个数据放入一个名为patientmaster的永久数据集中，目录为C盘下的MySASLib：

   

下面的代码读取交易数据并排序，使用updata语句将交易数据更新到主数据中。

   

输出结果如下：

   

注意FORTMAT定义格式：多个变量 格式名。

### 6.9 使用SAS数据集选项

前面已经见过很多选项，SAS语言主要有三种选项：系统选项、语句选项、数据集选项。系统选项有全局影响力，而数据集选项的影响力有限。

系统选项在SAS会话或工作期间都有效，包括center选项，它告诉SAS，center所有的输出。以及LINESIZE=option，设置输出中每一行的最大长度。

语句选项出现在某个语句中，影响某一个数据步或者过程步。

数据集选项影响的只是SAS如何读取和写入一个单个的数据集，可以在数据步（DATA,SET,MERGE,or UPDATE 语句）和过程步（conjuction with a DATA=statement option）中使用。用法是，接在数据集名之后，用括号括起来。有些最常见的选项：

KEEP=variable-list          告诉SAS保留哪个变量

DROP=variable-list         告诉SAS丢弃哪个变量

RENAME=(oldvar=newvar)   重命名某个变量

 FIRSTOBS=n              从观测值n开始读取变量

OBS=n                    到观测值n停止读取

IN=new-var-name

 

**选择并重命名变量** 下面是关于KEEP=,DROP=，和RENAME=的数据集选项的例子

   

KEEP=,DROP=，和RENAME=的作用与keep、drop、rename很相似。区别在于，后者适用于数据步中的所有变量，而前者仅使用与语句前面的那个数据集。而且，后者仅可以在数据步中使用，而前者除了数据步和过程步，还可以在输入和输出数据集中使用。

 

**用****observation number****选择观测值** 可以使用FIRSTOBS=和obs=来选择读取哪些观测值

   

这也类似于同名的语句选项和同名的系统选项，语句选项只适用于infile语句。数据集选项是用于数据步和过程步中存在的数据集，而系统选项适用于所有的文件和数据集。如果同时使用同样的系统选项和数据集选项，那么后者将覆盖前者。

 

**追踪观测值** 这里提到的选项都是针对现有的变量，而in=option则自己创建一个新变量。这个新变量是临时的，并且有自己在选项中指定。下面的例子，SAS创建了两个临时变量：InAnimals和InHabitat:：

   

该变量只存在于现在的过程步中。

 

### 6.10 用in=option追踪并选择观测值

​     如果合并了两个数据集，可以用in=option来追踪原始数据集对应新数据集中的哪个观测值。

In=data选项可以被用在数据步中的任何地方——SET,MERGE,或者UPDATE——但大部分用在merge语句上，接在要追踪的数据集后面。

下面的数据步创建了一个both数据集，合并两个数据集，state和ounty。并用in=Option创建了两个变量InState和 InCounty：

 

 

   

创建的变量是临时的，只存在于数据步期间。SAS给新变量赋值为0和1。比如county数据集没有关于Louisiana的数据（Louisiana只有parishes，没有counties），因此上例中，两个数据集都含有一个关于Louisiana的观测值，InState变量下的这个观测值为1，InCounty的为0。

这个被用在IF或IF-THEN语句中最多：

Subsetting IF:    IF InState=1;

IF InCounty=0;

IF InState=1 AND InCounty=1;

IF-THEN:       IF InCounty=1 THEN Origin=1;

IF InState=1 THEN State='Yes';

 

**例子** 一家运动品厂商有两份数据，一个包括所有客户的数据，一份包括了第三季度订单的数据。现在想要了解哪些客户在第三季度没有任何订单，即可以用in=option选项。客户数据包括客户编号、姓名、地址；订单数据包括客户编号、总价格：

   

发现没有订单客户的代码如下，数据步中创建了新变量recent，如果出现在客户数据中的观测值没有出现在order中，则recent赋为0，否则赋为1。

 

   

结果如下：

   

 

### 6.11 使用output语句写多维数据集

​     有时候想在一个数据步中创建多个数据，可以在DATA语句后面多接几个数据集名即可，如下语句告诉SAS创建三个数据集：LIONS、

TIGERS、和 BEARS:

DATA lions tigers bears;

这样仅仅是创建了三个一样的数据集，如果想创建不同的，可以用output语句

 

每一个数据步的结尾都有一个暗含的output语句，它告诉SAS在处理下一个观测值之前，将当前的观测值写入输出数据集中。可以用自己的output语句来推翻这个暗含的output语句，基本形式为：

OUTPUT data-set-name;

如果遗漏了数据集名，则将被写入数据步中所有的数据集中去，output可以单独使用，也可以使用在IF-THEN或DO-loop过程中：

IF family='Ursidae' THEN OUTPUT bears;

**例子** 有一份关于动物园给动物喂食的数据，变量为动物类型、生物学分类、居住区域、喂食是否在早上/下午/两者：

   

下面的代码创建了两个列表，一个是早上喂食，一个是下午喂食：

   

日志：

   

输出报告为：

   

 

 

### 6.12 使用output将一个观测值变成多个观测值

​     SAS通常在数据步结尾将一个观测值写入数据中，但可以写入多个观测值，在DO loop中或单独使用output语句。Output语句控制何时将观测值写入SAS数据集中。如果数据集中没有OUTPUT语句，则暗含在结尾，放置了output之后，则结尾的就不再暗含存在。当SAS出现OUTPUT语句时，则写入一个观测值。

 

 

 

**例子** 下面的代码阐述如何在DO LOOD语句中使用output语句来产生一个数据集。

   

这个代码没有INPUT或SET语句，故整个数据步中只有一次迭代——但包括了DO LOOP中的六次循环。由于OUTPUT语句在DO LOOP循环中，因此每次循环都会创建一个观测值：

   

如果没有OUTPUT语句，SAS仅会写入一个观测值，因为结尾处暗含的OUTPUT语句。

 

**例子** 有一份关于三个电影院的门票销售数据，记录了月份、电影院名称、门票销售额：

   

现在需要将电影院名作为一个变量、销售额作为一个变量、月份重复三次。

下面的代码使用三次input语句读取同一个原始文件。第一个读取变量month、location和tickets，并用@停留住数据行，接着用OUTPUT语句输出这个观测值。下一个INPUT读取这行后面的名、销售额，并再停留住行。接着读取，但释放行，进入下一个迭代。这个代码用output语句使每一行创建了三个观测值：

   

结果为:

   

 

### 6.13 使用proc transpose将观测值转变为变量

​     transpose过程可以转置数据集，将观测值转变为变量或将变量转变为观测值。部分情况下，将观测值转变为变量，可以使用下面代码：

 

 

PROC TRANSPOSE DATA=old-data-set OUT=new-data-set;

BY variable-list;

ID variable;

VAR variable-list;

 

**BY****语句** 可以使用BY语句，如果您有任何分组变量要保持作为变量。这些变量包括在已转置的数据集内，但它们本身并不转置。转置的数据集每个转置的变量在BY水平下都有一个观测。例如，在图中所示的变量X是BY变量。该数据集必须在转置前按这些变量排序。

 

**ID****语句** ID语句命名变量，这些变量值将变成新的变量名，ID变量在一个数据集中只能发生一次，如果有BY语句，那么在一个by-group中，变量值必须是唯一的。如果ID变量是数值型变量，新的变量名必须有一个下划线作为前缀（_1 or_2,for example）。如果不适用ID语句，新变量将命名为COL1，COL2等。

 

**VAR****语句** VAR语句命名变量，这个变量的变量值是要转置的。

 

**例子** 有一份关于儿童棒球联盟选手的数据，包括队名、选手编号、数据类型(salary or batting average)、以及entry：

   

现在想考察平均打击数与salary之间的关系，首先要将salary和平均打击数变量变量。下面的代码读取数据、按照队伍、选手排序数据，再转置数据：

   

在proc transpose这步中，BY变量是team和player。ID变量是type，它的值salary和batavg将是新变量名，将要转置的变量entry在VAR语句中指定。注意原来是变量名的entry，现在作为_name_变量下面的变量值。结果为：

   

 

### 6.14 使用SAS自动变量

SAS有一些自动变量，这些变量看不到，是临时的并不会被储存。但在数据步中，可以任意使用。

 

**_N_****和****_ERROR_** _N_记录了SAS在数据步中循环的次数，它不一定等于观测数。因为诸如IF语句就可以使迭代次数与观测数不一致。如果一个观测值的数据出现错误，_ERROR_会被赋值为1，否则赋值为0。错误数据包括无效数据（数值型格式变量却赋为字符串值），转换错误（0作为除数），函数中不合法的自变量（log（0））。

 

**FIRST.variable****和****LAST.variable** 当使用BY语句时，这两个变量才有效。SAS处理一个观测值时，如果某个变量的新变量值是第一次出现，first.variable被赋值为1，其他观测值中被赋为0。LAST.variable是同理的某变量的变量值是最后一次出现时，赋为1，其他赋为0。

 

**例子** 有一份不知道绕着镇中心走路比赛的数据，变量为entry number、age group和 finishing time。注意每行不止一个观测值：

   

第一件要做的事情是为完成情况创建一个新变量。下面代码读取数据，按照finishing time排序，另一个数据步创建新变量place，并赋给它当前的_N_值，print过程产生finishers列表：

   

   

第二段代码给出了每个年龄组的第一名：BY语句中自动产生了first.variable，后面的IF语句保留了每个年龄组的第一个观测值，由于数据是按照年龄组agegroup和time排序的，因此第一个观测值就是第一名。结果为：

   




## 第七章 使用SAS宏功能灵活写代码

### 7.1 宏概述

宏以前被认为是经验老道的SAS程序员使用的高级技术。但现在新手也能够了解一些。幸运的是，宏的基本功能不是那么难理解。本章介绍的最普遍使用的SAS宏语言的特征。

 

​    **宏处理器** 标准SAS程序中，提交程序后，SAS就编译并立即执行。但宏语句多了一步，在提交之后，SAS会将宏语句传送到宏处理器上，将其转变为SAS标准代码，通常叫做“变换代码”（meta-programming.）

 

​    **宏和宏变量** SAS宏代码包括两个基本部分：宏命令和宏变量。宏变量通常加一个“&”作为前缀，而宏命令通常加一个“%”作为前缀。

 

​    **局部****VS****全局** 宏变量有局部宏变量和全局宏变量。如果在宏的内部定义则为局部宏变量，只能在内部使用。如果在开放代码中定义则为全局宏变量。避免两种错误：在宏之外（开放代码）使用局部变量；创建同名的局部变量和全局变量。

 

​    **启动宏处理器** 使用宏指令之前必须将宏系统选项打开，尽管有时默认是打开的。可以用下面代码查看是否打开： PROC OPTIONS OPTION=MACRO; RUN;查看日志，如果看到MACRO，则打开了；如果看到NOMACRO，则没有打开。

 

**避免宏错误** 宏会让人很头痛，可以通过分段形式避免。首先，用SAS标准语言写下程序；接着，将其转变为宏代码。

 

### 7.2 用宏变量提交文本

​    **用****%let****创建一个宏变量** 最简单给宏变量分配一个值的方法是%let，基本形式为：

%LET macro-variable-name=value;

宏变量名必须符合SAS命名法则，（少于等于32字节、以字母或下划线开头、只能包括字母、数字和下划线），下面创建了宏变量：

  %LET iterations=10;

  %LET country=New Zealand;

当赋值字符串时，不需要加引号。除非在开头和结尾有空格，否则从等号到分号的全部内容都是变量值。

 

**使用宏变量** 宏变量前面要加前缀&，注意宏处理器找不到单引号内的宏变量，只能用双引号。如下的例子：

DO i=1 to &iterations;

TITLE ”Addresses in &country”;

经宏处理器编译后，语句变成：

DO i=1 to 10;

TITLE ”Addresses in New Zealand”;

 

​    **例子** 一份关于花店销售的数据，变量为顾客ID，销售日期，花的种类，数量：

   

想要一份反映某一种类型花的销售情况数据，宏变量就可以不用编辑数据步和过程步来选择一种花种：

   

结果如下：

   

 

### 7.3 用宏创建一个模块化的代码

宏可以使一段代码在一个或多个程序中被反复使用，而不需要重复地去编写相同或相似的代码。基本形式为：

%MACRO macro-name;

macro-text

%MEND macro-name;

%MACRO语句告诉SAS这是宏开始，而%MEND则意味着结束。macro-name是自己命名的，但mend后面的macro-name则是可选的，但加入会使得句子好很多（easier to debug and maintain）。

 

**启动宏** 定义了宏之后，可以通过在宏名称前面增加%来启动宏：%macro-name，注意这里可以不用分号。

 

​    **例子** 使用前面花店销售的数据：

   

下面的代码创建了一个名为%SAMPLE的宏，来将数据按照Quantity排序，打印出最大销售额的五个观测值（先降序排列，然后用OBS指定最后一行）。然后用标准数据步读取数据，并启动宏：

   

结果为：

   

这样的宏有些限制，因为它只能做一件事。现在结合%let语句，并增加参数使得其更加灵活

 

​    **宏自动呼叫库** 本书中的宏仅在一个程序内部定义和启动。也可以将宏储存在一个中心位置，叫做自动呼叫库，被各个程序分享。具体来说，将宏作为文件储存在某路径中，或作为分区数据集中的一员。使用MAUTOSOURCE和SASAUTOS=系统选项告诉SAS在哪里查找宏。之后，即使宏没有出现在程序中，也可以启动它了。

### 7.4 给宏增加参数

参数就是宏的变量，给宏增加参数，在%MACRO语句中的括号内列出宏变量的名字。基本形式为：

%MACRO macro-name(parameter-1=,parameter-2=,...parameter-n=);

macro-text

%MEND macro-name;

比如，一个叫做%QUARTERLYREPORT的宏可能这样开始：

%MACRO quarterlyreport(quarter=,salesrep=);

这个宏有两个参数&QUARTER 和&SALESREP。启用这个宏可以用这样的语句：

%quarterlyreport(quarter=3,salesrep=Smith)

 

​    **例子** 仍然是花店销售例子：

   

现在需要一份报告，反映每位对每位顾客的销售。下面的代码定义了宏%SELECT，并启动两次。这个宏排序并打印数据FlowerSales，使用参数创造了两位命为&CUSTOMER和&SORTVAR的宏变量：

   

   

   

结果为：

   

 

### 7.5 使用条件逻辑写宏代码

在宏中使用条件逻辑的基本形式为：

%IF condition %THEN action;

%ELSE %IF condition %THEN action;

%ELSE action;

%IF condition %THEN %DO;

SAS statements

%END;

 

​    **自动宏变量** 每一次启动SAS，宏处理器自动创建一些宏变量，可以使用在程序中。最常见的有：

   

比如，可以像这样结合自动宏变量和条件逻辑语句：

%IF &SYSDAY=Tuesday %THEN %LET country=Belgium;

%ELSE %LET country=France;

 

​    **例子** 仍然是花店销售数据：

   

现在想在周一和周四的时候打印报告，代码如下：

   

当程序提交之后，宏处理器将会写下如下代码：

   

如果这段代码是周四写的，那么结果如下：

   

### 7.6 用call symput编写数据驱动的程序

分配一个值给宏变量，可以使用call symput：

CALL SYMPUT(”macro-variable-name”,value);

macro-variable-name是变量名，value可以是一个变量名，该变量的值将分配给macro-variable-name，也可以是一个用引号括起来的常量。

call symput通常在IF-THEN语句中使用：

IF Age>=18 THEN CALL SYMPUT(”status”,”Adult”);

ELSE CALL SYMPUT(”status”,”Minor”);

这个语句创建了宏变量&STATUS，并依据年龄情况分配值adult或minor。下面的代码使用变量来赋值：

IF TotalSales>1000000 THEN CALL SYMPUT(”bestseller”,BookTitle);

**注意** 用call symput创建的宏变量与赋值变量不能够用在同一个数据步中。因为直到数据步执行之后，SAS才会将一个值赋给宏变量。

 

​    **例子** 仍然是花店销售的数据：

   

现在想找到单个订单最大的客户，并打印出这个客户的所有订单。

   

第一段代码读取原始数据，proc sort按照quantity降序排序，最大单个订单将会出现在第一个观测值上。

第二段代码使用call symput，当_N_为1 的时候，分配变量CustomerID的值给宏变量&SELECTEDCUSTOMER，在数据步中，我们所需要的就是这么多，因此使用stop语句告诉SAS停止数据步。Stop语句也可以不要，但为了提高效率，它可以告诉SAS不要再读取下面的观测值了。

第三段代码，此时SAS直到数据步已经结束，因此执行数据步。宏变量&SELECTEDCUSTOMER的值为356W，结果如下：

   

 

### 7.7 排除宏错误的bug

**避免宏错误** 尽可能先用标准SAS代码写你的程序，当没有错误了，再转成宏代码，先一次增加一个宏逻辑特征。再增加%macro和%mend。再增加宏变量。

 

​    **引用问题** 宏处理器不能解决单引号内的宏，所以要使用双引号。比如下面的例子，单引号不能读取宏变量的值：

   

 

**排除宏错误****bug****的系统选项** 这五个系统选项会影响SAS写入日志的信息。粗体为默认的设置。

**MERROR**|NOMERROR          如果你调用了一个SAS不能找到的宏，则会报警。

**SERROR**|NOSERROR            如果你使用了一个SAS不能找到的宏，则会报警。

MLOGIC|**NOMLOGIC**           SAS会在日志里打印关于执行宏的详细信息。

MPRINT|**NOMPRINT**            SAS在日志里打印由宏产生的标准SAS代码。

SYMBOLGEN|**NOSYMBOLGEN**    SAS在日志里打印宏变量的值。

最好只在排除bug的时候才将MLOGIC,MPRINT和SYMBOLGEN打开，否则它会让你的日志阅读起来很困难。想要关闭，则用系统语句：

OPTIONS MPRINT NOSYMBOLGEN NOMLOGIC;

 

​    **Merror****信息** 如果SAS不能找到一个宏，并且Merror选项也是开着的，那么SAS会打印这样的信息：

WARNING: Apparent invocation of macro SAMPL not resolved.

确认宏名字的拼写是否正确。

 

​    **SERROR****信息** 如果SAS不能在开放代码中处理一个宏变量，并且serror选项是开着的，SAS会打印这样的信息：

WARNING: Apparent symbolic reference FLOWER not resolved.

首先确认是否拼写错误，再次查看视角，即是否在外部使用了一个局部变量。

 

​    **MLOGIC****信息** 如果这个选项开启，SAS会在日志中打印由宏产生的SAS语句。如果在MPRINT选项中运行了%SAMPLE，日志会如下所示;

   

​    **SYMBOLGEN****信息** 如果这个选项开启，SAS会在日志窗口中打印每个宏变量的值。如果在SYMBOLGEN选项中运行%SAMPLE，日志会如下所示：

   




## 第八章 使用基本统计过程

### 8.1 用PROC UNIVARIATE检验数据分布

PROC UNIVARIATE是Base SAS software的一部分，产生统计量以描述单个变量的分布。这些统计量包括均值、中位数、mode（众数）、标准差、偏度和峰度。

Proc UNIVARIATE的使用很简单，在proc语句之后，用var语句指定一个或多个变量：

PROC UNIVARIATE;

VAR variable-list;

没有var语句，SAS会计算所有数值变量的统计量。Proc语句中也可以指定其他选项，比如plot或normal：

PROC UNIVARIATE PLOT NORMAL;

Normal选项进行正态测试，PLOT画出数据的三个图(stem-and-leaf plot, box plot, and normal probability plot)，可以使用BY语句来对单个组进行分析。（前提是要进行sort排序）

 

**例子** 下面的数据是一个班级的学生分数,每一行是10位同学的分数:

   

下面代码读取数据并运行PROC UNIVARIATE:

   

结果为:

   

 

### 8.2 用proc means产生统计量

由Proc univariate产生的统计量，大部分都可以由proc means产生，前提是你要要求它产生。Proc univariate会默认打印所有的统计量：mean,variance,skewness,quantiles,extremes,t tests,standard error。而用proc means你可以要求打印你需要的统计量。

Means过程只需要一个语句：

PROC MEANS statistic-keywords;

​    默认means会产生均值、缺失值数、标准差、每一个数值变量的最小最大值，下面的list列出可以需要的统计量，可以将它们加入proc means语句中：

CLM        双侧置信区间             RANGE     范围

CSS        校正的平方和              SKEWNESS 偏度

CV         变异系数                  STDDEV    标准差

KURTOSIS  峰度                      STDERR    平均标准差

LCLM      单侧（低侧）置信区间      SUM       总和

MAX       最大值                    SUMWGT   权数变量之和

MEAN      平均数                    UCLM      单侧（高侧）置信区间

MIN        最小值                    USS        未校正的平方和

N 非缺失变量值的个数                  VAR 方差

NMISS缺失变量值个数                  PROBT probability for Student’s t

MEDIAN中位数                        T Student’s t

Q1(P25) 25%quantile                     Q3(P75) 75%quantile

P1 1%quantile                           P5 5%quantile

P10 10%quantile                         P90 90%quantile

P95 95%quantile                         P99 99%quantile

 

**置信区间** 默认置信区间的置信水平为0.05或95%，用在means语句中使用ALPHA=option可以得到不同的置信度。比如现在想要90%的置信区间，就要指定ALPHA=0.10，并要有CLM选项，语句为：

PROC MEANS ALPHA=.10 CLM;

VAR语句 means会默认为所有的数值型变量产生统计量，如果不需要，那么用var语句中指定你需要的变量，基本形式：

PROC MEANS options;

VAR variable-list;

 

​    **例子** 如下是书店中关于儿童读物的书本页数：

   

​    Means可以产生平均页数及90%的置信区间：

   

​    结果为：

   

 

### 8.3 用proc freq检验分类数据

PROC FREQ，是base SAS的一部分，可以产生很多统计量来检验分类数据的相关性。基本形式为：

PROC FREQ;

TABLES variable-combinations/options;

**选项** 这里有一些统计选项：

AGREE    检测分类性，包括McNemar’s test, Bowker’s test, Cochran’s Q test, and kappa statistics

CHISQ         用卡方统计量检测一致性和同类性

CL            一致性检测的置信区间

CMH          Cochran-Mantel-Haenszel statistics

EXACT         Fisher’s exact test for tables larger than 2X2

MEASURES   一致性测量，包括Pearson and Spearman correlation coefficients,gamma,Kendall’s tau-b,Stuart’s tau-c,Somer’s D

PLCORR         polychoric correlation coefficient

RELRISK         relative risk measures for 2X2 tables

TREND          the Cochran-Armitage test for trend

 

**例子** 有人抱怨公交班车总是到站太慢，而快速巴士却可以准时到达。现在想弄明白车的种类与是否准时之间的关系。现在有一组数据，包括两个变量：车类型（E for express or R for regular），是否准时（L for late or O for on time），每一行包含10个观测值：

   

下面的代码读取数据，用chisq选项运行proc freq，

   

结果为：（注意行列次序）假设车类型和到达时间是独立的，获得的卡方检验chi-square概率为 0.0071。因此，数据支持车类型和到达时间是有关联的。

   

 

### 8.4 用proc corr检测相关性

基本形式为：PROC CORR；

它告诉SAS计算最近创建的数据集中的所有数值变量两两相关系数。可以和VAR和with来指定变量：

VAR variable-list;

WITH variable-list;

VAR语句中的变量出现在交叉表顶部，而with的变量出现在左侧。

默认情况下，proc corr计算Pearson积差相关系数。可以增加选项要求非参数的相关系数。下面的SPEARMAN选项告诉SAS计算Spearman’s rank correlations，而不是Pearson’s correlations：

PROC CORR SPEARMAN;

其他还有如HOEFFDING(for Hoeffding’s D statistic)和KENDALL(for Kendall’stau-b coefficients)。

 

**例子** 有一份关于学生学习的数据，变量为考试分数，一周花在电视上的小时数，一周花在学习上的小时数，注意每行包括五个学生数据：

   

代码为：

   

   

结果为：

   

报告开始于每个变量的描述统计量，接着列出相关矩阵，包括：相关系数（pearson）、P值。

### 8.5 使用proc reg做简单的回归分析

REG过程使用最小二乘法拟合线性回归模型，是SAS/STAT 产品的一部分。Reg使用逐步法、前进法、后退法进行自变量的筛选。SAS/STAT其他的产品可以进行非线性（non-linear）、混合线性、logistic回归。SAS/ETS产品中有时间序列回归的分析。

Reg只需两步：用PROC REG语句开始，用MODEL语句指定分析模型。基本形式为：

PROC REG;

MODEL dependent=independent;

Model语句中，自变量在左边，因变量在右边。

Plot语句是reg过程中许多可选的语句之一。可以用plot语句产生数据的散点图。如果安装了SAS/GRAPH模块，PROC REG将使用这个模块来产生散点图。产生散点图语句：

PLOT dependent*independent;

如果没有SAS/GRAPH模块，则需要在proc reg语句中使用LINEPRINTER选项，以产生plots。由于没有SAS/GRAPH模块不能产生回归线，需要用预测值代替观测值来拟合出线。下面的代码显示了用reg过程产生数据的单个散点图和预测值：

PROC REG LINEPRINTER;

MODEL dependent=independent;

PLOT dependent*independent='symbol'P.*independent='symbol'/

OVERLAY;

Symbol的值指定SAS使用哪种标记来标注数据点，如果不指定，SAS会直接使用数字。P.是代表预测值的关键词。

有很多中选项可以选择，来绘出回归分析的结果。比如可以绘出残差值、学生化残差、Cook’s D influence statistics、置信区间。如果有SAS/GRAPH模块，那么有很多方法来高质量的控制输出的外观。

 

**例子** 在儿童垒球比赛上，有人说，选手多高，他就能将球击多远。想从统计角度来验证，收集了如下的数据，分别是身高（英尺）、三次击球最长的长度（英尺）。

   

下面代码读取数据并做回归：

   

在model和plot语句中，距离是自变量、高度是因变量。输出结果将在8.6讨论。

 

### 8.6 读取proc reg的输出

Reg的输出有几个部分，方差分析和参数估计通常输出在一页。有些选项语句，比如plot，在另外的页面中产生。

这部分的输出是由如下proc reg语句产生的结果：

   

第一部分是方差分析的结果，给出了模型对数据拟合的程度：

   

参数估计的结果如下：

   

参数分析的结果可以构建模型：

Distance=-11.00859+2.89466*Height

Root MSE即中文教材中的残差平方根。残差平方(SS残差)是总变异中无法用回归的协变量解释的部分。该数值越小，说明回归的效果越好；该数值越大，说明回归的效果越差。 它的平方根意义相同。 同时，其意义可以反映在回归假设检验的P值上。该数值越大，P值越大，该数值越小，P值越小。

除非是统计方面的研究论文，一般不报告Root of MSE。但它是评价回归效果好坏很有意义的指标。

下面的图形显示了plot语句的结果，如果有SAS/GRAPH模块，proc reg会描出数据点和回归线。上面打印出方程，右边显示统计量：

   

就这个例子来看，球飞出去的长度确实和击球人的身高有关系，模型是显著的，但是两者之间的关系不是很明显（R-square=0.3758），可能年龄、经验会是比身高更好的预测变量。

 

### 8.7 使用proc anova做单因素方差分析

Proc anova是SAS/STAT模块的一部分，许可证独立于BASE SAS。

方差分析有两个基本语句：CLASS 和MODEL，基本形式为：

PROC ANOVA;

CLASS variable-list;

MODEL dependent=effects;

Class描述分类变量，并要在model语句之前。对于单因素方差分析，只需要列出一个变量。Model语句描述了自变量和效应（effects）。对于单因素方差分析，效应就是分类变量。每组的观测值数要求一样，这样的数据为平衡的。

Proc anova有很多选择语句，最常用的是means，计算出model语句中任何一种主效应的自变量的均值。另外，means还可以做几种多重比较检验，包括Bonferroni t tests(BON)，Duncan’smultiple-rangetest(DUNCAN)，Scheffe’smultiple-comparison procedure(SCHEFFE)，pairwise t tests(T)，和Tukey’s studentized range test(TUKEY)。Means语句的基本形式为：

MEANS effects/options;

Effect可以为model语句中的主效应。选项为希望使用的多重比较检验的名字。

 

**例子** 有一份关于几个篮球队员身高的数据，变量为队名、身高，注意每行有六个观测值：

   

因为每组都有12个队员，所以数据是平衡的。现在想知道哪一组最高，因此还要用means语句，并选择Scheffe’s multiple-comparison过程来比较均值。代码为：

   

结果将在8.8中讨论。

 

### 8.8 读取proc anova的输出

Proc anova的输出至少有两个部分，首先打印出有一个表，给出分类变量的信息：水平数、变量值、观测值数。再次打印出变量表的分析。如果使用了类似means这样的语句，那么其结果将接在后面。

8.7中想要检验是否组与组之间的身高有区别，使用proc anova语句如下：

   

第一部分给出了分类变量的信息：

   

分类变量team有五个水平：blue, gold, gray, pink和red。第二部分是方差分析的表：

   

因为模型是显著的，因此可以认为不是所有组的队员身高都相同。Means语句中的SCHEFFE选项比较了不同组的身高。

   

### 8.9 统计分析的图形界面

统计分析的结果也可以用Graphical User Interfaces来完成。

SAS Enterprise Guide、分析家 、SAS/LAB和SAS/INSIGHT。




## 第九章 导出数据

### 9.1 导出数据的方法

**将数据导出到其他应用程序** 有三个基本方法将数据导出到其他应用程序：delimited files或文本这样其他软件都可以读取的文件。创建一个如html、rtf、或xml这样其他软件业可以读的文件。用其他软件的格式创建数据。

l  不论操作环境是什么，几乎都可以创建分隔文件（delimited files），且大部分软件都是可以读取的。数据步，可以让你很好的控制文件的格式，但是步骤比较多。导出向导（Export Wizard）和导出过程（EXPORT procedure），很好使用，但对结果的控制不是很好。ODS可以从任何输出中创建逗号分隔的文件（CSV）。

l  使用ODS，可以从任何输出中创建HTML、RTF、和XML文件，大部分软件都是可以读取这些文件的。

l  如果PC文件格式软件中有SAS/ACCESS模块，可以创建一些不同的文件类型，这些文件在PC程序中很常见。出向导（Export Wizard）和导出过程（EXPORT procedure）都可以产生PC文件。通过使用这些程序本身来创建，避免了创建完还要导入。如果没有SAS/ACCESS模块，且使用window系统，那么可以使用Dynamic Data Exchange(DDE)或 Open Database Connectivity(ODBC)来讲数据从SAS移动到PC程序中，且不需要创建中介的文件。

 

**导出****SAS****数据集到其他的操作系统中** 有三个有效的方法：交叉环境数据访问（CEDA），XPORT引擎或CPORT过程，XML引擎，以及SAS/CONNECT模块。

l  CEDA是迄今为止最简单的，将SAS数据集移动到其他操作系统的方法。但CEDA不能被SAS version 6使用，也不能在OS/390或z/OS中使用。

l  XPORT引擎和 CPORT过程都创建了可以移动到   其他操作系统的传送文件，再将其转回成SAS数据集。创建传送文件会导致数据精度的损失。但对于SAS version 和OS/390或z/OS，由于不能使用CEDA，故可能需要这个方法。

l  如果使用的是SAS 9.0或更高版本，那么你可以在LIBNAME语句中使用XML引擎，来创建XML文件。这个文件可以转移到其他电脑中，并且可以使用XML引擎来转回到SAS数据集。

l  SAS/CONNECT模块，连同一些其他的功能，可以让你将SAS数据集转移到其他操作系统中，而不需要创建中间文件。SAS/CONNECT模块也可以讲SAS数据集从一个较早版本移到一个较高版本，且反之也可以。

 

### 9.2 用导出向导写文件

导出向导是一个图形使用界面（GUI），如果你只需要一次性导出数据，那么这个方法比proc export简单。

在文件菜单中选择“导出数据…”，在第一个窗口中，选择要导出的library和menbs名。如果要导出一个临时SAS数据集，那么library就是work。Member就是SAS数据集的名字。

   

第二个窗口中，选择要创建的文件类型。这可以从standard data sources的下拉列表中选择，或勾选User-defined formats旁边的框框。

   

下一个窗口中 ，选择导出文件的路径。如果要导出分隔的文件，那么要在option中进行设置。

   

最后一个窗口中，用来储存由导出向导产生的proc export语句：

   

 

### 9.3 用EXPORT Procedure写分隔的文件

   

使用EXPORT Procedure的优点在于，它可以将代码融合到现有的SAS程序中，每一次创建文件时，不需要通过export Wizard。

**The EXPORT procedure** 基本形式为：

PROC EXPORT DATA=data-set OUTFILE='filename';

Data-set是要导出的数据集，filename是路径及名称，如下的代码告诉SAS读取名为HOTELS的临时SAS数据集，并写入名为HOTELs.csv的逗号分隔的文件中，路径为C盘下的MyRawData文件夹：

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.csv';

SAS根据文件的扩展名，来决定创建哪一种文件。也可以通过在PROC EXPORT语句中增加DBMS=option来指定文件类型。下面的表格显示了扩展名和对应的DBMS辨认器的辨认：

   

注意空格分隔的文件，是没有扩展名的。因此必须使用DBMS=option。下面的代码通过DBMS=option，告诉SAS创建一个空格分隔的文件，名为Hotels.spc，替代选项告诉SAS替代同名文件。

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.spc'

DBMS=DLM REPLACE;

如果想创建一个有分隔符的文件，不是逗号、tab或者空格分隔的，就需要DELIMITER语句。DELIMITER语句不在乎使用什么扩展名，也不在乎指定的哪种DBMS identifier，文件将会使用你在identifier中指定的分隔符。比如，下面的代码产生文件，Hotels.txt，用&作为分隔符：

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.txt'

DBMS=DLM REPLACE;

DELIMITER='&';

 

**例子** 有一份关于高尔夫课程的数据，变量为课程名、洞口数、par、yardage和

greens fees.

   

下面的代码使用infile和input语句读取数据并放入名为GOLF的永久SAS数据集中，存于C盘的MySASLib路径下。这个例子使用LIBNAME告诉SAS永久数据集储存在哪里，但也可是使用直接指代：

   

下面的代码写一个纯文本、tab-delimited文件，可以用任何文本编辑器来读取：

   

由于输出文件以txt结尾，且没有DELIMITER语句，SAS将写入一个tab-delimited文件，如果运行这段代码，日志将出现如下：

   

注意原始数据中只有六个观测值，多出的一行是变量名。如果用文字编辑器读取这个文件，那么将出现如下：

   

如果想要改变格式，运行proc export之前，在数据步中使用FORMAT语句。

 

### 9.4 用EXPORT Procedure写PC文件

如果使用的是windows或unix系统，且有SAS/ACCESS的PC文件格式软件，那么就可以使用EXPORT procedure来创建PC文件类型。如果用的是Windows系统，EXPORT procedure可以创建Microsoft Access,Microsoft Excel,dBase,和Lotus files。Unix系统则可以用SAS9.1或更高版本创建dBase files，也可以创建Microsoft Access和 Microsoft Excel files。

 

**Microsoft Excel,Lotus and dBase files** PROC EXPORT创建Microsoft Excel,Lotus 和dBase的基本形式为：

PROC EXPORT DATA=data-set OUTFILE='filename';

Data-set是导出的数据集，filename是输出文件的路径。下面的语句告诉SAS读取名为HOTELS的临时SAS数据集，并写入名为Hotels.xls的Microsoft Excel文件:

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.xls';

SAS通过扩展名来决定创建哪一种文件。可以通过DBMS=option来指定文件类型。下面的表显示了文件扩展名和DBMS标识符。

   

下面的语句包括DBMS=option，告诉SAS创建一个名为hotels.xls的Microsoft Excel 5文件，REPLACE选项意味着替换同名文件。

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.xls'

DBMS=EXCEL5 REPLACE;

默认情况下，Microsoft Excel sheet的名字与SAS数据集一样，通过SHEET=语句可以指定不同的名字（该语句对Microsoft Excel 4 or Microsoft Excel 5无效）。Sheet名中特殊的字符将转化为下划线，且$不允许放在sheet名字的后面。下面的代码创建了一个名为Golf_Hotels的工作薄：SHEET='Golf Hotels';

 

**Microsoft Access files** 创建Microsoft Access文件使用OUTTABLE=option，而不是OUTFILE=option，并且要增加DATABASE=语句。基本形式为：

PROC EXPORT DATA=data-set OUTTABLE='filename'DBMS=identifier;

DATABASE='filename';

DATABASE语句指定了哪一个Microsoft Access database文件希望修改或创建，OUTTABLE选项指定那个database的表名。必须要指定DBMS选项来创建Microsoft Access table，下表显示了DBMS的标识符：

   

**例子** 仍然是高尔夫课程的数据：

   

下面的代码使用INFILE和INPUT语句读取数据，并将其放入名为GOLF的永久数据集中：

   

如下代码将golfSAS数据集写入Microsoft Excel文件：

   

Excel的结果为如下图所示：

   

### 9.5用数据步写原始文件

​      

 

 

 

 

数据步可以创建原始文件，在数据步中使用file语句和put语句，可以写下任何一种形式的原始数据文件。虽然PROC EXPORT和Export Wizard在某种程度上更简单，但选项有限。而数据步可以更灵活的创建。

可以用读取原始数据的同样方式写入原始数据，只需几步改变——用file语句和put语句。也就是说infile和input语句是将原始数据文件导入SAS，而file和put语句是将原始数据导出。

   

与input一样，put语句可以用list,column或formatted风格。但由于SAS已经知道变量是否是数值或字符串，因此不需要在字符串变量后加$符号。如果使用list format风格，SAS会自动在变量之间加空格，创建一个空格分隔的文件。要用其他分隔符，在file语句中使用list-style put语句和DSD和DLM=options：

FILE ’file-specification’ DSD DLM=’delimiter’;

如果使用column或formatted风格的put语句，SAS将会把变量放在任何你指定的地方。可以用input语句中同样的指示器，用@n移动到第n列，用+n移动n列，用/移动到下一行，用#n滑动到第n行，@则停留在当前行，也可以通过引号来加入字符串。

 

**例子** 仍然是高尔夫球课程的数据，

   

下面的代码是读取数据的：

   

现在要将数据写入原始原件，但只有三个变量，按新的变量顺序排列，并且美元符号放入变量GreenFees后面。下面的代码读取数据并用FILE和PUT语句写入原始文件：

   

_NULL_是告诉SAS不要新建数据集，以节省电脑资源。

SET语句告诉SAS读取永久数据集GOLF，FILE语句告诉SAS写入的内容和路径，PUT语句告诉SAS要创建的输出变量的名字。Put语句包含了两个引用的字符串，“Golf Course”和“Par”，这两个将插入原始文件中。Put语句使用@列指示符告诉SAS变量的变量值放置在哪里。为GreenFees变量赋DOLLAR7.2格式。用put语句可以完全控制原始文件。

运行这段代码，日志窗口将出现下面的信息：

   

输出结果为：

   

 

### 9.6 用ODS写分隔和HTML文件

ODS是创造各种输出格式的强有力的工具。在各种输出格式中，ODS可以创建的有两种，CSV和HTML，使用它来将数据从SAS中传送到其他程序中，是很有用的方法。许多程序可以读取CSV或HTML格式，而且任何操作系统都可以使用这种方法。

由于所有的过程其输出都经过ODS，因此可以通过选择正确的目的地来用ODS导出数据，并用proc print来获取数据列表。如果不想让SAS打印缺失数据，可以使用MISSING=''系统选项。默认下，PROC PRINT打印观测序号，可以通过使用NOOBS让其不打印。

 

**CSV files** 从9.0开始，可以用ODS创建CSV文件。CSV文件用逗号将变量值分开，且变量值被括在双引号之内。双引号允许变量值包含逗号。创建一个CSV文件来转载数据，用下面的语句：

ODS CSV FILE='filename.csv';

Your PROC PRINT statements go here

RUN;

ODS CSV CLOSE;

filename.csv是要创建的CSV文件，并且下面要为你的数据插入正确的proc print语句。如果想要在CSV文件中包含标题和注脚，使用csvall，而不是csv。

HTML files 使用下面语句为你的数据产生HTML文件，可以在ODS HTML语句中增加STYLE=option语句来选择不同的风格。或者，如果不想使用任何风格，则使用CHTML输出目的地来代替HTML。

ODS HTML FILE='filename.html';

Your PROC PRINT statements go here

RUN;

ODS HTML CLOSE;

 

**例子** 此例使用SAS永久数据集GOLF，仅包括在hawaii的gofl课程。下面的代码使用ODS来创建CSV文件，golfinfo.csv：

   

CSV文件如果用记事本打开，如下所示：

   

如果使用excel打开，则如下所示:

   

下面的代码从golf数据创建一个HTML文件，golfinfo.html，并且在proc print语句中使用noobs选项来减少观测之列：

   

用excel打开：

   

 

### 9.7 和其他类型电脑分享SAS数据集

   

访问SAS数据集时候，SAS会自动检测数据以决定是否和与你使用的操作系统兼容。如果数据集处于不同的系统之中，SAS会自动使用交叉环境数据访问（CEDA），以动态传送数据至一种形式，这种形式下，SAS可以在你的系统中理解数据。有两种CEDA不能使用的情况，分别为：OS/390或z/OS，和SAS 6.0及以前的版本。

决定数据表现 CEDA是透明的，以至于你不知道什么时候它在被使用。如果想知道什么时候CEDA被使用，可以用下面的语句：OPTIONS MSGLEVEL=I;

则，无论什么时候SAS使用CEDA访问数据，日志窗口都会出现下面的类似信息：

   

为外部主机创建SAS数据集 创立一个SAS数据集，方便其他电脑系统访问，而又不需要浪费电脑资源转换格式，可以在libname语句中使用OUTREP=option，基本形式：

LIBNAME libref'path'OUTREP=data-representation;

如果想要那个库中所有数据集都有指定host representation，还可以：

data-set-name(OUTREP=data-representation)

data-representation基本来说是操作系统的名字，比如想要data representation是Microsoft Windows 64-Bit Edition，那么就应该为WINDOWS_64；如果想要data representation是Solaris 32-Bit Edition，那么应该为SOLARIS_32。

 

**例子** 你有关于HAWII高尔夫球课程的数据，储存在你的电脑里。可是你的朋友需要你的数据，而他的电脑是linux系统，现在需要把数据集转换成linux格式。下面的代码在数据步中使用SET语句读取sport逻辑库中的golf数据，Data语句中的OUTREP=data set选项告诉SAS用linux格式写下数据，并创建名为golflinux的数据集。

   

系统选项MSGLEVEL=I导致了下面的信息：

   

 

**移动****SAS****数据集** 如果两台电脑都访问同一个文件系统，那么用LIBNAME语句指向SAS数据集存放的路径就可以了，否则要用binary模式的FTP，或者使用外部媒介，比如软盘或CD。

 

**FAT****文件系统** 从SAS版本7开始，创建的数据集默认扩展名为.sas7bdat。有的使用FAT文件系统的windows系统只能有三个字符的扩展名，此时SAS数据集的扩展名为.sd7。如果接受三个字符的扩展名，创建一个三个字符扩展名的数据集，则需要再libname语句中使用SHORTFILEEXT选项：

LIBNNAME libref'path' SHORTFILEEXT;

 

**如果你不能使用****CEDA** 

 ******LAST.variable** 当使用BY语句时，这两个变量才有效。SAS处理一个观测值时，如果某个变量的新变量值是第一次出现，first.variable被赋值为1，其他观测值中被赋为0。LAST.variable是同理的某变量的变量值是最后一次出现时，赋为1，其他赋为0。

 

**例子** 有一份不知道绕着镇中心走路比赛的数据，变量为entry number、age group和 finishing time。注意每行不止一个观测值：

   

第一件要做的事情是为完成情况创建一个新变量。下面代码读取数据，按照finishing time排序，另一个数据步创建新变量place，并赋给它当前的_N_值，print过程产生finishers列表：

   

   

第二段代码给出了每个年龄组的第一名：BY语句中自动产生了first.variable，后面的IF语句保留了每个年龄组的第一个观测值，由于数据是按照年龄组agegroup和time排序的，因此第一个观测值就是第一名。结果为：

   




## 第七章 使用SAS宏功能灵活写代码

### 7.1 宏概述

宏以前被认为是经验老道的SAS程序员使用的高级技术。但现在新手也能够了解一些。幸运的是，宏的基本功能不是那么难理解。本章介绍的最普遍使用的SAS宏语言的特征。

 

​    **宏处理器** 标准SAS程序中，提交程序后，SAS就编译并立即执行。但宏语句多了一步，在提交之后，SAS会将宏语句传送到宏处理器上，将其转变为SAS标准代码，通常叫做“变换代码”（meta-programming.）

 

​    **宏和宏变量** SAS宏代码包括两个基本部分：宏命令和宏变量。宏变量通常加一个“&”作为前缀，而宏命令通常加一个“%”作为前缀。

 

​    **局部****VS****全局** 宏变量有局部宏变量和全局宏变量。如果在宏的内部定义则为局部宏变量，只能在内部使用。如果在开放代码中定义则为全局宏变量。避免两种错误：在宏之外（开放代码）使用局部变量；创建同名的局部变量和全局变量。

 

​    **启动宏处理器** 使用宏指令之前必须将宏系统选项打开，尽管有时默认是打开的。可以用下面代码查看是否打开： PROC OPTIONS OPTION=MACRO; RUN;查看日志，如果看到MACRO，则打开了；如果看到NOMACRO，则没有打开。

 

**避免宏错误** 宏会让人很头痛，可以通过分段形式避免。首先，用SAS标准语言写下程序；接着，将其转变为宏代码。

 

### 7.2 用宏变量提交文本

​    **用****%let****创建一个宏变量** 最简单给宏变量分配一个值的方法是%let，基本形式为：

%LET macro-variable-name=value;

宏变量名必须符合SAS命名法则，（少于等于32字节、以字母或下划线开头、只能包括字母、数字和下划线），下面创建了宏变量：

  %LET iterations=10;

  %LET country=New Zealand;

当赋值字符串时，不需要加引号。除非在开头和结尾有空格，否则从等号到分号的全部内容都是变量值。

 

**使用宏变量** 宏变量前面要加前缀&，注意宏处理器找不到单引号内的宏变量，只能用双引号。如下的例子：

DO i=1 to &iterations;

TITLE ”Addresses in &country”;

经宏处理器编译后，语句变成：

DO i=1 to 10;

TITLE ”Addresses in New Zealand”;

 

​    **例子** 一份关于花店销售的数据，变量为顾客ID，销售日期，花的种类，数量：

   

想要一份反映某一种类型花的销售情况数据，宏变量就可以不用编辑数据步和过程步来选择一种花种：

   

结果如下：

   

 

### 7.3 用宏创建一个模块化的代码

宏可以使一段代码在一个或多个程序中被反复使用，而不需要重复地去编写相同或相似的代码。基本形式为：

%MACRO macro-name;

macro-text

%MEND macro-name;

%MACRO语句告诉SAS这是宏开始，而%MEND则意味着结束。macro-name是自己命名的，但mend后面的macro-name则是可选的，但加入会使得句子好很多（easier to debug and maintain）。

 

**启动宏** 定义了宏之后，可以通过在宏名称前面增加%来启动宏：%macro-name，注意这里可以不用分号。

 

​    **例子** 使用前面花店销售的数据：

   

下面的代码创建了一个名为%SAMPLE的宏，来将数据按照Quantity排序，打印出最大销售额的五个观测值（先降序排列，然后用OBS指定最后一行）。然后用标准数据步读取数据，并启动宏：

   

结果为：

   

这样的宏有些限制，因为它只能做一件事。现在结合%let语句，并增加参数使得其更加灵活

 

​    **宏自动呼叫库** 本书中的宏仅在一个程序内部定义和启动。也可以将宏储存在一个中心位置，叫做自动呼叫库，被各个程序分享。具体来说，将宏作为文件储存在某路径中，或作为分区数据集中的一员。使用MAUTOSOURCE和SASAUTOS=系统选项告诉SAS在哪里查找宏。之后，即使宏没有出现在程序中，也可以启动它了。

### 7.4 给宏增加参数

参数就是宏的变量，给宏增加参数，在%MACRO语句中的括号内列出宏变量的名字。基本形式为：

%MACRO macro-name(parameter-1=,parameter-2=,...parameter-n=);

macro-text

%MEND macro-name;

比如，一个叫做%QUARTERLYREPORT的宏可能这样开始：

%MACRO quarterlyreport(quarter=,salesrep=);

这个宏有两个参数&QUARTER 和&SALESREP。启用这个宏可以用这样的语句：

%quarterlyreport(quarter=3,salesrep=Smith)

 

​    **例子** 仍然是花店销售例子：

   

现在需要一份报告，反映每位对每位顾客的销售。下面的代码定义了宏%SELECT，并启动两次。这个宏排序并打印数据FlowerSales，使用参数创造了两位命为&CUSTOMER和&SORTVAR的宏变量：

   

   

   

结果为：

   

 

### 7.5 使用条件逻辑写宏代码

在宏中使用条件逻辑的基本形式为：

%IF condition %THEN action;

%ELSE %IF condition %THEN action;

%ELSE action;

%IF condition %THEN %DO;

SAS statements

%END;

 

​    **自动宏变量** 每一次启动SAS，宏处理器自动创建一些宏变量，可以使用在程序中。最常见的有：

   

比如，可以像这样结合自动宏变量和条件逻辑语句：

%IF &SYSDAY=Tuesday %THEN %LET country=Belgium;

%ELSE %LET country=France;

 

​    **例子** 仍然是花店销售数据：

   

现在想在周一和周四的时候打印报告，代码如下：

   

当程序提交之后，宏处理器将会写下如下代码：

   

如果这段代码是周四写的，那么结果如下：

   

### 7.6 用call symput编写数据驱动的程序

分配一个值给宏变量，可以使用call symput：

CALL SYMPUT(”macro-variable-name”,value);

macro-variable-name是变量名，value可以是一个变量名，该变量的值将分配给macro-variable-name，也可以是一个用引号括起来的常量。

call symput通常在IF-THEN语句中使用：

IF Age>=18 THEN CALL SYMPUT(”status”,”Adult”);

ELSE CALL SYMPUT(”status”,”Minor”);

这个语句创建了宏变量&STATUS，并依据年龄情况分配值adult或minor。下面的代码使用变量来赋值：

IF TotalSales>1000000 THEN CALL SYMPUT(”bestseller”,BookTitle);

**注意** 用call symput创建的宏变量与赋值变量不能够用在同一个数据步中。因为直到数据步执行之后，SAS才会将一个值赋给宏变量。

 

​    **例子** 仍然是花店销售的数据：

   

现在想找到单个订单最大的客户，并打印出这个客户的所有订单。

   

第一段代码读取原始数据，proc sort按照quantity降序排序，最大单个订单将会出现在第一个观测值上。

第二段代码使用call symput，当_N_为1 的时候，分配变量CustomerID的值给宏变量&SELECTEDCUSTOMER，在数据步中，我们所需要的就是这么多，因此使用stop语句告诉SAS停止数据步。Stop语句也可以不要，但为了提高效率，它可以告诉SAS不要再读取下面的观测值了。

第三段代码，此时SAS直到数据步已经结束，因此执行数据步。宏变量&SELECTEDCUSTOMER的值为356W，结果如下：

   

 

### 7.7 排除宏错误的bug

**避免宏错误** 尽可能先用标准SAS代码写你的程序，当没有错误了，再转成宏代码，先一次增加一个宏逻辑特征。再增加%macro和%mend。再增加宏变量。

 

​    **引用问题** 宏处理器不能解决单引号内的宏，所以要使用双引号。比如下面的例子，单引号不能读取宏变量的值：

   

 

**排除宏错误****bug****的系统选项** 这五个系统选项会影响SAS写入日志的信息。粗体为默认的设置。

**MERROR**|NOMERROR          如果你调用了一个SAS不能找到的宏，则会报警。

**SERROR**|NOSERROR            如果你使用了一个SAS不能找到的宏，则会报警。

MLOGIC|**NOMLOGIC**           SAS会在日志里打印关于执行宏的详细信息。

MPRINT|**NOMPRINT**            SAS在日志里打印由宏产生的标准SAS代码。

SYMBOLGEN|**NOSYMBOLGEN**    SAS在日志里打印宏变量的值。

最好只在排除bug的时候才将MLOGIC,MPRINT和SYMBOLGEN打开，否则它会让你的日志阅读起来很困难。想要关闭，则用系统语句：

OPTIONS MPRINT NOSYMBOLGEN NOMLOGIC;

 

​    **Merror****信息** 如果SAS不能找到一个宏，并且Merror选项也是开着的，那么SAS会打印这样的信息：

WARNING: Apparent invocation of macro SAMPL not resolved.

确认宏名字的拼写是否正确。

 

​    **SERROR****信息** 如果SAS不能在开放代码中处理一个宏变量，并且serror选项是开着的，SAS会打印这样的信息：

WARNING: Apparent symbolic reference FLOWER not resolved.

首先确认是否拼写错误，再次查看视角，即是否在外部使用了一个局部变量。

 

​    **MLOGIC****信息** 如果这个选项开启，SAS会在日志中打印由宏产生的SAS语句。如果在MPRINT选项中运行了%SAMPLE，日志会如下所示;

   

​    **SYMBOLGEN****信息** 如果这个选项开启，SAS会在日志窗口中打印每个宏变量的值。如果在SYMBOLGEN选项中运行%SAMPLE，日志会如下所示：

   




## 第八章 使用基本统计过程

### 8.1 用PROC UNIVARIATE检验数据分布

PROC UNIVARIATE是Base SAS software的一部分，产生统计量以描述单个变量的分布。这些统计量包括均值、中位数、mode（众数）、标准差、偏度和峰度。

Proc UNIVARIATE的使用很简单，在proc语句之后，用var语句指定一个或多个变量：

PROC UNIVARIATE;

VAR variable-list;

没有var语句，SAS会计算所有数值变量的统计量。Proc语句中也可以指定其他选项，比如plot或normal：

PROC UNIVARIATE PLOT NORMAL;

Normal选项进行正态测试，PLOT画出数据的三个图(stem-and-leaf plot, box plot, and normal probability plot)，可以使用BY语句来对单个组进行分析。（前提是要进行sort排序）

 

**例子** 下面的数据是一个班级的学生分数,每一行是10位同学的分数:

   

下面代码读取数据并运行PROC UNIVARIATE:

   

结果为:

   

 

### 8.2 用proc means产生统计量

由Proc univariate产生的统计量，大部分都可以由proc means产生，前提是你要要求它产生。Proc univariate会默认打印所有的统计量：mean,variance,skewness,quantiles,extremes,t tests,standard error。而用proc means你可以要求打印你需要的统计量。

Means过程只需要一个语句：

PROC MEANS statistic-keywords;

​    默认means会产生均值、缺失值数、标准差、每一个数值变量的最小最大值，下面的list列出可以需要的统计量，可以将它们加入proc means语句中：

CLM        双侧置信区间             RANGE     范围

CSS        校正的平方和              SKEWNESS 偏度

CV         变异系数                  STDDEV    标准差

KURTOSIS  峰度                      STDERR    平均标准差

LCLM      单侧（低侧）置信区间      SUM       总和

MAX       最大值                    SUMWGT   权数变量之和

MEAN      平均数                    UCLM      单侧（高侧）置信区间

MIN        最小值                    USS        未校正的平方和

N 非缺失变量值的个数                  VAR 方差

NMISS缺失变量值个数                  PROBT probability for Student’s t

MEDIAN中位数                        T Student’s t

Q1(P25) 25%quantile                     Q3(P75) 75%quantile

P1 1%quantile                           P5 5%quantile

P10 10%quantile                         P90 90%quantile

P95 95%quantile                         P99 99%quantile

 

**置信区间** 默认置信区间的置信水平为0.05或95%，用在means语句中使用ALPHA=option可以得到不同的置信度。比如现在想要90%的置信区间，就要指定ALPHA=0.10，并要有CLM选项，语句为：

PROC MEANS ALPHA=.10 CLM;

VAR语句 means会默认为所有的数值型变量产生统计量，如果不需要，那么用var语句中指定你需要的变量，基本形式：

PROC MEANS options;

VAR variable-list;

 

​    **例子** 如下是书店中关于儿童读物的书本页数：

   

​    Means可以产生平均页数及90%的置信区间：

   

​    结果为：

   

 

### 8.3 用proc freq检验分类数据

PROC FREQ，是base SAS的一部分，可以产生很多统计量来检验分类数据的相关性。基本形式为：

PROC FREQ;

TABLES variable-combinations/options;

**选项** 这里有一些统计选项：

AGREE    检测分类性，包括McNemar’s test, Bowker’s test, Cochran’s Q test, and kappa statistics

CHISQ         用卡方统计量检测一致性和同类性

CL            一致性检测的置信区间

CMH          Cochran-Mantel-Haenszel statistics

EXACT         Fisher’s exact test for tables larger than 2X2

MEASURES   一致性测量，包括Pearson and Spearman correlation coefficients,gamma,Kendall’s tau-b,Stuart’s tau-c,Somer’s D

PLCORR         polychoric correlation coefficient

RELRISK         relative risk measures for 2X2 tables

TREND          the Cochran-Armitage test for trend

 

**例子** 有人抱怨公交班车总是到站太慢，而快速巴士却可以准时到达。现在想弄明白车的种类与是否准时之间的关系。现在有一组数据，包括两个变量：车类型（E for express or R for regular），是否准时（L for late or O for on time），每一行包含10个观测值：

   

下面的代码读取数据，用chisq选项运行proc freq，

   

结果为：（注意行列次序）假设车类型和到达时间是独立的，获得的卡方检验chi-square概率为 0.0071。因此，数据支持车类型和到达时间是有关联的。

   

 

### 8.4 用proc corr检测相关性

基本形式为：PROC CORR；

它告诉SAS计算最近创建的数据集中的所有数值变量两两相关系数。可以和VAR和with来指定变量：

VAR variable-list;

WITH variable-list;

VAR语句中的变量出现在交叉表顶部，而with的变量出现在左侧。

默认情况下，proc corr计算Pearson积差相关系数。可以增加选项要求非参数的相关系数。下面的SPEARMAN选项告诉SAS计算Spearman’s rank correlations，而不是Pearson’s correlations：

PROC CORR SPEARMAN;

其他还有如HOEFFDING(for Hoeffding’s D statistic)和KENDALL(for Kendall’stau-b coefficients)。

 

**例子** 有一份关于学生学习的数据，变量为考试分数，一周花在电视上的小时数，一周花在学习上的小时数，注意每行包括五个学生数据：

   

代码为：

   

   

结果为：

   

报告开始于每个变量的描述统计量，接着列出相关矩阵，包括：相关系数（pearson）、P值。

### 8.5 使用proc reg做简单的回归分析

REG过程使用最小二乘法拟合线性回归模型，是SAS/STAT 产品的一部分。Reg使用逐步法、前进法、后退法进行自变量的筛选。SAS/STAT其他的产品可以进行非线性（non-linear）、混合线性、logistic回归。SAS/ETS产品中有时间序列回归的分析。

Reg只需两步：用PROC REG语句开始，用MODEL语句指定分析模型。基本形式为：

PROC REG;

MODEL dependent=independent;

Model语句中，自变量在左边，因变量在右边。

Plot语句是reg过程中许多可选的语句之一。可以用plot语句产生数据的散点图。如果安装了SAS/GRAPH模块，PROC REG将使用这个模块来产生散点图。产生散点图语句：

PLOT dependent*independent;

如果没有SAS/GRAPH模块，则需要在proc reg语句中使用LINEPRINTER选项，以产生plots。由于没有SAS/GRAPH模块不能产生回归线，需要用预测值代替观测值来拟合出线。下面的代码显示了用reg过程产生数据的单个散点图和预测值：

PROC REG LINEPRINTER;

MODEL dependent=independent;

PLOT dependent*independent='symbol'P.*independent='symbol'/

OVERLAY;

Symbol的值指定SAS使用哪种标记来标注数据点，如果不指定，SAS会直接使用数字。P.是代表预测值的关键词。

有很多中选项可以选择，来绘出回归分析的结果。比如可以绘出残差值、学生化残差、Cook’s D influence statistics、置信区间。如果有SAS/GRAPH模块，那么有很多方法来高质量的控制输出的外观。

 

**例子** 在儿童垒球比赛上，有人说，选手多高，他就能将球击多远。想从统计角度来验证，收集了如下的数据，分别是身高（英尺）、三次击球最长的长度（英尺）。

   

下面代码读取数据并做回归：

   

在model和plot语句中，距离是自变量、高度是因变量。输出结果将在8.6讨论。

 

### 8.6 读取proc reg的输出

Reg的输出有几个部分，方差分析和参数估计通常输出在一页。有些选项语句，比如plot，在另外的页面中产生。

这部分的输出是由如下proc reg语句产生的结果：

   

第一部分是方差分析的结果，给出了模型对数据拟合的程度：

   

参数估计的结果如下：

   

参数分析的结果可以构建模型：

Distance=-11.00859+2.89466*Height

Root MSE即中文教材中的残差平方根。残差平方(SS残差)是总变异中无法用回归的协变量解释的部分。该数值越小，说明回归的效果越好；该数值越大，说明回归的效果越差。 它的平方根意义相同。 同时，其意义可以反映在回归假设检验的P值上。该数值越大，P值越大，该数值越小，P值越小。

除非是统计方面的研究论文，一般不报告Root of MSE。但它是评价回归效果好坏很有意义的指标。

下面的图形显示了plot语句的结果，如果有SAS/GRAPH模块，proc reg会描出数据点和回归线。上面打印出方程，右边显示统计量：

   

就这个例子来看，球飞出去的长度确实和击球人的身高有关系，模型是显著的，但是两者之间的关系不是很明显（R-square=0.3758），可能年龄、经验会是比身高更好的预测变量。

 

### 8.7 使用proc anova做单因素方差分析

Proc anova是SAS/STAT模块的一部分，许可证独立于BASE SAS。

方差分析有两个基本语句：CLASS 和MODEL，基本形式为：

PROC ANOVA;

CLASS variable-list;

MODEL dependent=effects;

Class描述分类变量，并要在model语句之前。对于单因素方差分析，只需要列出一个变量。Model语句描述了自变量和效应（effects）。对于单因素方差分析，效应就是分类变量。每组的观测值数要求一样，这样的数据为平衡的。

Proc anova有很多选择语句，最常用的是means，计算出model语句中任何一种主效应的自变量的均值。另外，means还可以做几种多重比较检验，包括Bonferroni t tests(BON)，Duncan’smultiple-rangetest(DUNCAN)，Scheffe’smultiple-comparison procedure(SCHEFFE)，pairwise t tests(T)，和Tukey’s studentized range test(TUKEY)。Means语句的基本形式为：

MEANS effects/options;

Effect可以为model语句中的主效应。选项为希望使用的多重比较检验的名字。

 

**例子** 有一份关于几个篮球队员身高的数据，变量为队名、身高，注意每行有六个观测值：

   

因为每组都有12个队员，所以数据是平衡的。现在想知道哪一组最高，因此还要用means语句，并选择Scheffe’s multiple-comparison过程来比较均值。代码为：

   

结果将在8.8中讨论。

 

### 8.8 读取proc anova的输出

Proc anova的输出至少有两个部分，首先打印出有一个表，给出分类变量的信息：水平数、变量值、观测值数。再次打印出变量表的分析。如果使用了类似means这样的语句，那么其结果将接在后面。

8.7中想要检验是否组与组之间的身高有区别，使用proc anova语句如下：

   

第一部分给出了分类变量的信息：

   

分类变量team有五个水平：blue, gold, gray, pink和red。第二部分是方差分析的表：

   

因为模型是显著的，因此可以认为不是所有组的队员身高都相同。Means语句中的SCHEFFE选项比较了不同组的身高。

   

### 8.9 统计分析的图形界面

统计分析的结果也可以用Graphical User Interfaces来完成。

SAS Enterprise Guide、分析家 、SAS/LAB和SAS/INSIGHT。




## 第九章 导出数据

### 9.1 导出数据的方法

**将数据导出到其他应用程序** 有三个基本方法将数据导出到其他应用程序：delimited files或文本这样其他软件都可以读取的文件。创建一个如html、rtf、或xml这样其他软件业可以读的文件。用其他软件的格式创建数据。

l  不论操作环境是什么，几乎都可以创建分隔文件（delimited files），且大部分软件都是可以读取的。数据步，可以让你很好的控制文件的格式，但是步骤比较多。导出向导（Export Wizard）和导出过程（EXPORT procedure），很好使用，但对结果的控制不是很好。ODS可以从任何输出中创建逗号分隔的文件（CSV）。

l  使用ODS，可以从任何输出中创建HTML、RTF、和XML文件，大部分软件都是可以读取这些文件的。

l  如果PC文件格式软件中有SAS/ACCESS模块，可以创建一些不同的文件类型，这些文件在PC程序中很常见。出向导（Export Wizard）和导出过程（EXPORT procedure）都可以产生PC文件。通过使用这些程序本身来创建，避免了创建完还要导入。如果没有SAS/ACCESS模块，且使用window系统，那么可以使用Dynamic Data Exchange(DDE)或 Open Database Connectivity(ODBC)来讲数据从SAS移动到PC程序中，且不需要创建中介的文件。

 

**导出****SAS****数据集到其他的操作系统中** 有三个有效的方法：交叉环境数据访问（CEDA），XPORT引擎或CPORT过程，XML引擎，以及SAS/CONNECT模块。

l  CEDA是迄今为止最简单的，将SAS数据集移动到其他操作系统的方法。但CEDA不能被SAS version 6使用，也不能在OS/390或z/OS中使用。

l  XPORT引擎和 CPORT过程都创建了可以移动到   其他操作系统的传送文件，再将其转回成SAS数据集。创建传送文件会导致数据精度的损失。但对于SAS version 和OS/390或z/OS，由于不能使用CEDA，故可能需要这个方法。

l  如果使用的是SAS 9.0或更高版本，那么你可以在LIBNAME语句中使用XML引擎，来创建XML文件。这个文件可以转移到其他电脑中，并且可以使用XML引擎来转回到SAS数据集。

l  SAS/CONNECT模块，连同一些其他的功能，可以让你将SAS数据集转移到其他操作系统中，而不需要创建中间文件。SAS/CONNECT模块也可以讲SAS数据集从一个较早版本移到一个较高版本，且反之也可以。

 

### 9.2 用导出向导写文件

导出向导是一个图形使用界面（GUI），如果你只需要一次性导出数据，那么这个方法比proc export简单。

在文件菜单中选择“导出数据…”，在第一个窗口中，选择要导出的library和menbs名。如果要导出一个临时SAS数据集，那么library就是work。Member就是SAS数据集的名字。

   

第二个窗口中，选择要创建的文件类型。这可以从standard data sources的下拉列表中选择，或勾选User-defined formats旁边的框框。

   

下一个窗口中 ，选择导出文件的路径。如果要导出分隔的文件，那么要在option中进行设置。

   

最后一个窗口中，用来储存由导出向导产生的proc export语句：

   

 

### 9.3 用EXPORT Procedure写分隔的文件

   

使用EXPORT Procedure的优点在于，它可以将代码融合到现有的SAS程序中，每一次创建文件时，不需要通过export Wizard。

**The EXPORT procedure** 基本形式为：

PROC EXPORT DATA=data-set OUTFILE='filename';

Data-set是要导出的数据集，filename是路径及名称，如下的代码告诉SAS读取名为HOTELS的临时SAS数据集，并写入名为HOTELs.csv的逗号分隔的文件中，路径为C盘下的MyRawData文件夹：

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.csv';

SAS根据文件的扩展名，来决定创建哪一种文件。也可以通过在PROC EXPORT语句中增加DBMS=option来指定文件类型。下面的表格显示了扩展名和对应的DBMS辨认器的辨认：

   

注意空格分隔的文件，是没有扩展名的。因此必须使用DBMS=option。下面的代码通过DBMS=option，告诉SAS创建一个空格分隔的文件，名为Hotels.spc，替代选项告诉SAS替代同名文件。

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.spc'

DBMS=DLM REPLACE;

如果想创建一个有分隔符的文件，不是逗号、tab或者空格分隔的，就需要DELIMITER语句。DELIMITER语句不在乎使用什么扩展名，也不在乎指定的哪种DBMS identifier，文件将会使用你在identifier中指定的分隔符。比如，下面的代码产生文件，Hotels.txt，用&作为分隔符：

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.txt'

DBMS=DLM REPLACE;

DELIMITER='&';

 

**例子** 有一份关于高尔夫课程的数据，变量为课程名、洞口数、par、yardage和

greens fees.

   

下面的代码使用infile和input语句读取数据并放入名为GOLF的永久SAS数据集中，存于C盘的MySASLib路径下。这个例子使用LIBNAME告诉SAS永久数据集储存在哪里，但也可是使用直接指代：

   

下面的代码写一个纯文本、tab-delimited文件，可以用任何文本编辑器来读取：

   

由于输出文件以txt结尾，且没有DELIMITER语句，SAS将写入一个tab-delimited文件，如果运行这段代码，日志将出现如下：

   

注意原始数据中只有六个观测值，多出的一行是变量名。如果用文字编辑器读取这个文件，那么将出现如下：

   

如果想要改变格式，运行proc export之前，在数据步中使用FORMAT语句。

 

### 9.4 用EXPORT Procedure写PC文件

如果使用的是windows或unix系统，且有SAS/ACCESS的PC文件格式软件，那么就可以使用EXPORT procedure来创建PC文件类型。如果用的是Windows系统，EXPORT procedure可以创建Microsoft Access,Microsoft Excel,dBase,和Lotus files。Unix系统则可以用SAS9.1或更高版本创建dBase files，也可以创建Microsoft Access和 Microsoft Excel files。

 

**Microsoft Excel,Lotus and dBase files** PROC EXPORT创建Microsoft Excel,Lotus 和dBase的基本形式为：

PROC EXPORT DATA=data-set OUTFILE='filename';

Data-set是导出的数据集，filename是输出文件的路径。下面的语句告诉SAS读取名为HOTELS的临时SAS数据集，并写入名为Hotels.xls的Microsoft Excel文件:

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.xls';

SAS通过扩展名来决定创建哪一种文件。可以通过DBMS=option来指定文件类型。下面的表显示了文件扩展名和DBMS标识符。

   

下面的语句包括DBMS=option，告诉SAS创建一个名为hotels.xls的Microsoft Excel 5文件，REPLACE选项意味着替换同名文件。

PROC EXPORT DATA=hotels OUTFILE='c:\MyRawData\Hotels.xls'

DBMS=EXCEL5 REPLACE;

默认情况下，Microsoft Excel sheet的名字与SAS数据集一样，通过SHEET=语句可以指定不同的名字（该语句对Microsoft Excel 4 or Microsoft Excel 5无效）。Sheet名中特殊的字符将转化为下划线，且$不允许放在sheet名字的后面。下面的代码创建了一个名为Golf_Hotels的工作薄：SHEET='Golf Hotels';

 

**Microsoft Access files** 创建Microsoft Access文件使用OUTTABLE=option，而不是OUTFILE=option，并且要增加DATABASE=语句。基本形式为：

PROC EXPORT DATA=data-set OUTTABLE='filename'DBMS=identifier;

DATABASE='filename';

DATABASE语句指定了哪一个Microsoft Access database文件希望修改或创建，OUTTABLE选项指定那个database的表名。必须要指定DBMS选项来创建Microsoft Access table，下表显示了DBMS的标识符：

   

**例子** 仍然是高尔夫课程的数据：

   

下面的代码使用INFILE和INPUT语句读取数据，并将其放入名为GOLF的永久数据集中：

   

如下代码将golfSAS数据集写入Microsoft Excel文件：

   

Excel的结果为如下图所示：

   

### 9.5用数据步写原始文件

​      

 

 

 

 

数据步可以创建原始文件，在数据步中使用file语句和put语句，可以写下任何一种形式的原始数据文件。虽然PROC EXPORT和Export Wizard在某种程度上更简单，但选项有限。而数据步可以更灵活的创建。

可以用读取原始数据的同样方式写入原始数据，只需几步改变——用file语句和put语句。也就是说infile和input语句是将原始数据文件导入SAS，而file和put语句是将原始数据导出。

   

与input一样，put语句可以用list,column或formatted风格。但由于SAS已经知道变量是否是数值或字符串，因此不需要在字符串变量后加$符号。如果使用list format风格，SAS会自动在变量之间加空格，创建一个空格分隔的文件。要用其他分隔符，在file语句中使用list-style put语句和DSD和DLM=options：

FILE ’file-specification’ DSD DLM=’delimiter’;

如果使用column或formatted风格的put语句，SAS将会把变量放在任何你指定的地方。可以用input语句中同样的指示器，用@n移动到第n列，用+n移动n列，用/移动到下一行，用#n滑动到第n行，@则停留在当前行，也可以通过引号来加入字符串。

 

**例子** 仍然是高尔夫球课程的数据，

   

下面的代码是读取数据的：

   

现在要将数据写入原始原件，但只有三个变量，按新的变量顺序排列，并且美元符号放入变量GreenFees后面。下面的代码读取数据并用FILE和PUT语句写入原始文件：

   

_NULL_是告诉SAS不要新建数据集，以节省电脑资源。

SET语句告诉SAS读取永久数据集GOLF，FILE语句告诉SAS写入的内容和路径，PUT语句告诉SAS要创建的输出变量的名字。Put语句包含了两个引用的字符串，“Golf Course”和“Par”，这两个将插入原始文件中。Put语句使用@列指示符告诉SAS变量的变量值放置在哪里。为GreenFees变量赋DOLLAR7.2格式。用put语句可以完全控制原始文件。

运行这段代码，日志窗口将出现下面的信息：

   

输出结果为：

   

 

### 9.6 用ODS写分隔和HTML文件

ODS是创造各种输出格式的强有力的工具。在各种输出格式中，ODS可以创建的有两种，CSV和HTML，使用它来将数据从SAS中传送到其他程序中，是很有用的方法。许多程序可以读取CSV或HTML格式，而且任何操作系统都可以使用这种方法。

由于所有的过程其输出都经过ODS，因此可以通过选择正确的目的地来用ODS导出数据，并用proc print来获取数据列表。如果不想让SAS打印缺失数据，可以使用MISSING=''系统选项。默认下，PROC PRINT打印观测序号，可以通过使用NOOBS让其不打印。

 

**CSV files** 从9.0开始，可以用ODS创建CSV文件。CSV文件用逗号将变量值分开，且变量值被括在双引号之内。双引号允许变量值包含逗号。创建一个CSV文件来转载数据，用下面的语句：

ODS CSV FILE='filename.csv';

Your PROC PRINT statements go here

RUN;

ODS CSV CLOSE;

filename.csv是要创建的CSV文件，并且下面要为你的数据插入正确的proc print语句。如果想要在CSV文件中包含标题和注脚，使用csvall，而不是csv。

HTML files 使用下面语句为你的数据产生HTML文件，可以在ODS HTML语句中增加STYLE=option语句来选择不同的风格。或者，如果不想使用任何风格，则使用CHTML输出目的地来代替HTML。

ODS HTML FILE='filename.html';

Your PROC PRINT statements go here

RUN;

ODS HTML CLOSE;

 

**例子** 此例使用SAS永久数据集GOLF，仅包括在hawaii的gofl课程。下面的代码使用ODS来创建CSV文件，golfinfo.csv：

   

CSV文件如果用记事本打开，如下所示：

   

如果使用excel打开，则如下所示:

   

下面的代码从golf数据创建一个HTML文件，golfinfo.html，并且在proc print语句中使用noobs选项来减少观测之列：

   

用excel打开：

   

 

### 9.7 和其他类型电脑分享SAS数据集

   

访问SAS数据集时候，SAS会自动检测数据以决定是否和与你使用的操作系统兼容。如果数据集处于不同的系统之中，SAS会自动使用交叉环境数据访问（CEDA），以动态传送数据至一种形式，这种形式下，SAS可以在你的系统中理解数据。有两种CEDA不能使用的情况，分别为：OS/390或z/OS，和SAS 6.0及以前的版本。

决定数据表现 CEDA是透明的，以至于你不知道什么时候它在被使用。如果想知道什么时候CEDA被使用，可以用下面的语句：OPTIONS MSGLEVEL=I;

则，无论什么时候SAS使用CEDA访问数据，日志窗口都会出现下面的类似信息：

   

为外部主机创建SAS数据集 创立一个SAS数据集，方便其他电脑系统访问，而又不需要浪费电脑资源转换格式，可以在libname语句中使用OUTREP=option，基本形式：

LIBNAME libref'path'OUTREP=data-representation;

如果想要那个库中所有数据集都有指定host representation，还可以：

data-set-name(OUTREP=data-representation)

data-representation基本来说是操作系统的名字，比如想要data representation是Microsoft Windows 64-Bit Edition，那么就应该为WINDOWS_64；如果想要data representation是Solaris 32-Bit Edition，那么应该为SOLARIS_32。

 

**例子** 你有关于HAWII高尔夫球课程的数据，储存在你的电脑里。可是你的朋友需要你的数据，而他的电脑是linux系统，现在需要把数据集转换成linux格式。下面的代码在数据步中使用SET语句读取sport逻辑库中的golf数据，Data语句中的OUTREP=data set选项告诉SAS用linux格式写下数据，并创建名为golflinux的数据集。

   

系统选项MSGLEVEL=I导致了下面的信息：

   

 

**移动****SAS****数据集** 如果两台电脑都访问同一个文件系统，那么用LIBNAME语句指向SAS数据集存放的路径就可以了，否则要用binary模式的FTP，或者使用外部媒介，比如软盘或CD。

 

**FAT****文件系统** 从SAS版本7开始，创建的数据集默认扩展名为.sas7bdat。有的使用FAT文件系统的windows系统只能有三个字符的扩展名，此时SAS数据集的扩展名为.sd7。如果接受三个字符的扩展名，创建一个三个字符扩展名的数据集，则需要再libname语句中使用SHORTFILEEXT选项：

LIBNNAME libref'path' SHORTFILEEXT;

 

**如果你不能使用****CEDA** 

 







## 参考文献