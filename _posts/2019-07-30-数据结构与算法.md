---
layout: post
title: "《数据结构与算法》的学习"
date: 2019-07-30
tag: 学习
---



# 数据结构与算法

```
  1.数组实现
  2.链表
二、栈与队列
三、树与二叉树
  1.树
  2.二叉树基本概念
  3.二叉查找树
  4.平衡二叉树
  5.红黑树
四、图
五、总结

```

(c++)

```

先广度-后深度
堆：在集合中取出最小值和最大值。可以取和添值；优先队列pq ：斐波那契队列
科学刷题：题目是对知识的抽象，题目是检验正确性，量的积累。（捷径）
目的性：20-30分钟的时间，5分钟是做过的；分类和总结
条件就是突破口，解决新算法问题
```



### 数据结构学科的定义：

```c++
主要是为研究和解决如何使用计算机处理非数值问题而产生的理论、技术和方法。

在程序设计时就已经遇到过。
一维数组是一个数据结构
 例如：一维数组A=（a1,a2,a3,a4）
 							int a[4];//定义并创建一维整型
     //数组(a[0],a[1],a[2],a[3])
 
 x=a[2]; //读数组元素a[2]的值
 a[2]=x; //置a[2]的值为x

数据结构由数据元素依某种逻辑关系组织起来，在数据结构上需要定义一组操作（运算）。
```

一、数据和数据元素 

```

1. 数据：是信息的载体,是计算机加工处理的对象.
 2. 数值数据和非数值数据
 (1)数值数据：包括整数、实数或复数。主要用于工程计算、科学计算。
 (2)非数值数据：包括字符、文字、图形、图象、语音等。
 用于情报检索、企业管理、图形图象、人工智能、远程教育、远程医疗、电子商务、电子图书馆和办公自动化等诸多领域。
3. 数据元素：组成数据的基本单位
```

### 二、什么是数据结构 

#### 1数据结构举例 

```c++

例如：一维数组A=（a1,a2,a3,a4）
 (1) 数据元素间的逻辑关系：
    B=（D，R）
其中，D是数据元素的有限集合，R是D上关系的有限集合。本书中一般只考虑R包含一个关系的情况，即R={r}。
    D={ a1,a2,a3,a4}
    r={ <a1,a2>,<a2,a3>,<a3,a4>}
    R={r}

(2) 数据在计算机内的表示
顺序存储表示 a1 a2 a3 a4从上到下，102 104 106 108
链接存储表示：first ->a1-->a2-->a3-->a4
一维数组A=（a1,a2,a3,a4）

3) 运算的定义和算法
Create():　 建立一个数组。
Retrieve(i): 返回下标为i的元素值。
Store(i,x): 将下标为i的数据元素
            的值置为x。
例如：
 int a[4]; //定义一个一维整型数组   
           //(a[0],a[1],a[2],a[3])
 x=a[2];   //读数组元素a[2]的值
 a[2]=x;   //置a[2]的值为x

```



#### 2.4种基本的逻辑结构

##### 集合结构：

结构中的数据元素之间除了“同属于一个集合”的关系外，别无其它关系； 集合和字典

##### 线性结构：

结构中的数据元素之间存在 一对一 的关系；有前面和后面之分
				线性表，堆栈，队列，字符串，数组，文件

##### 树形结构：

结构中的数据元素之间存在 一对多 的关系；				树是更简单的图
				树 二叉树 堆 优先权队列。

##### 图结构：

结构中的数据元素之间存在 多对多 的关系。 网and 图

链表就是一叉树



#### 3什么是数据结构

```
数据结构包括以下四个方面：
(1) 数据元素及特性
    是数据结构中的最基本信息单元。
(2) 数据的逻辑结构
    对数据元素间的逻辑关系的描述。
(3) 数据的存储表示（存储结构）
    数据在计算机内的组织方式。
(4) 运算的定义和算法
    数据结构上执行的运算和实现。
    
   

```



 1.5 数据结构的描述 


```
 1.数据结构的抽象层次  
 数据结构抽象为一种聚集结构。
数据结构被看成是一个类属抽象数据类型，用格式化的自然语言来描述之。
  另外，数据结构可以形式地用一个C++的抽象模板类描述之。

```

用ADT描述数据结构——堆栈的例子

```c++
ADT 1.1  栈抽象数据类型

ADT Stack { 
Data :
  零个或多个元素的线性序列（a1，a2， ，an)，遵循LIFO
  原则。
Operations:
  Create()：创建一个空栈。
  Push(x)：在栈中插入元素x。
  Pop()：删除栈顶元素。
  Top()：返回栈顶元素。
  IsEmpty()：若栈空，则返回true，否则返回false。
  IsFull()：若栈满，则返回true， 否则返回false。
}　



----------------
程序 1-2 栈的C++抽象类
template<class T>
class Stack
{
public:
  Stack(){};                     	  
  virtual void Push(const T &x)=0;	   
  virtual void Pop()=0;          
  virtual T Top()const=0;         
  virtual int IsEmpty() const=0;   	   
  virtual int IsFull() const=0;    
};
    除了构造函数，其余成员函数都是纯虚函数。顺序栈类SeqStack是类Stack在顺序存储表示下的一种实现，它是从抽象类Stack派生出来的，它可以实例化。

-----------------
整数堆：
从上到下； 1 0  底层是top

堆栈：
从上到下：n-1，···，1，0  an····a2 a1 ，an是top
                                                                           
```

### 1.6.1 算法及其性能分析 

```

1.什么是算法  
   一个算法(algorithm)是对特定问题的求解步骤的一种描述，它是指令的有限序列；此外，算法具有下列五个特征：
   (1)输入  算法有零个或多个输入。
   (2)输出  算法至少产生一个输出
   (3)确定性  算法的每一条指令都有确切的定义，没有二义性。
   (4)能行性  算法的每一条指令都足够基本，它们可以通过已经实现的基本运算执行有限次来实现。
   (5)有穷性  算法必须总能在执行有限步之后终止。  
   
 2. 算法描述方法 
 
    算法可以自然语言、表格法、流程图或程序设计语言描述。
    当一个算法用程序设计语言描述时，便成为程序。
    
    // 本书中主要使用C++语言描述。

3. 算法的性能标准  
(1) 正确性  算法的执行结果应当满足预先规定的功能和性能要求。
(2) 简明性  一个算法应当思路清晰、层次分明、简单明了、易读易懂。
(3) 健壮性  当输入不合法数据时，应能做适当处理，不至于引起严重后果。**
(4) 效率  有效使用存储空间和有高的时间效率。
(5) 最优性  解决同一个问题可能有多种算法，应进行比较，选择最佳算法。   

```



### 1.6.2 算法的空间复杂度 

```

算法的空间复杂度 
   是程序运行从开始到结束所需的存储量。  
问题实例的特征 : 
    与问题的具体实例有关的量。
    
    例如，对一组特定个数的元素进行排序，对该组元素的排序是排序问题的一个实例。元素的个数可视为该实例的特征。


程序运行所需的存储空间包括两部分：
（1）固定部分  这部分空间与所处理数据的大小和个数无关，或者称与问题的实例的特征无关。主要包括程序代码、常量、简单变量、定长成分的结构变量所占的空间。
（2）可变部分  这部分空间大小与算法在某次执行中处理的特定数据的大小和规模有关。例如，分别为100个元素的两个数组相加，与分别为10个元素的两个数组相加，所需的存储空间显然是不同的。    

```





### 1.6.3 算法的时间复杂度 

```c++


算法的时间复杂度 
   是程序运行从开始到结束所需的时间。  
程序步  
        一个程序步是指在语法上或语义上有意义的程序段，该程序段的执行时间与问题实例的特征无关。
        
        
程序1.2  求一个数组元素的累加之和
float sum(float list[],const int n)
{ 
  float tempsum=0.0;  
  count ++;   //针对赋值语句 
  for (int i=0; i<n; i++ ){
    count ++；//针对for语句
    tempsum += list[i];
    count ++;  //针对赋值语句
  }
  count ++; //针对for的最后一次执行
  count ++; //针对return语句
  return tempsum;
}
返回


count 是全局变量，用来计算程序步数。
       每一程序步均与问题实例的规模n无关。
      
       程序步数为2n+3。


```

### 1.6.4 渐近时间复杂度 

```c++

（一） 大O记号 
   如果存在两个正常数c 和 n0，使得对所有的n，n> n0 ，有
f(n)<= cg(n) 则有 f(n)=O(g(n))。
即函数f(n)当n充分大时上有界，且 g(n)是它的一个上界，也称f(n)的阶不高于g(n)的阶。

例1:
    T(n)= 3.6*n3 + 2.5 * n**2 + 2.8，取n0=1,则当n>=n0 时，
		T(n) <= 3.6n3+2.5n3+2.8n3 =8.9n**3;
		取c=8.9,则根据大O记号的定义得：       
          									T(n)= O(n**3)


渐近时间复杂性：
   使用大O记号表示的算法的时间复杂性，称为算法的渐近时间复杂性。  

在大O记号下，可用程序步来估计算法的执行时间。
    很多情况下，可以通过考察一个算法中的关键操作（关键操作被认为是一个程序步）的执行次数来计算算法的渐近时间复杂性。

--------------------------

例如，程序1.2为求一个数组元素的累加之和的算法。
（1）其总的程序步数为2n+3，则渐近时间复杂性为O(n)。
（2）语句tempsum += list[i]可认为是关键操作，它的执行次数为n次，则渐近时间复杂性为O(n)。

例二：
void Mult(int a[n][n], b[n][n], c[n][n], int n)
{ // nn矩阵a与b 相乘得到c。
   for (int i=0;i<n;i++)              // n+1
     for(int j=0;j<n;j++)             // n(n+1)
     {
	 c[i][j]=0;                     // n2
	 for (int k=0;k<n;k++)          // n2（n+1)
	   c[i][j]+=a[i][k]*b[k][j];    // n3
     }
} 

    程序步为：2n3 +3n2 + 2n+1 
    渐近时间复杂度为：T(n)=O(n3)

```



常见的渐近时间复杂性从小到大排列有：
O(1)< O(log2 n) < O(n)< O(nlog2 n)< O(n2)< O(n**3)



### （二） Ω记号

```

   如果存在两个正常数c 和 n0，使得对所有的n，n n0 ，有f(n)cg(n) ，则有 f(n)=Ω(g(n))。
即函数f(n)当n充分大时下有界，且g(n)是它的一个下界，也称f(n)的阶不低于g(n)的阶。

（三）θ记号 
f(n)=θ(g(n))，当且仅当f(n)=O(g(n))且f(n)=Ω(g(n)) ，这时称f(n)与g(n)同阶。

（四）对于O、Ω和θ的定义，可用求极限的方法作判断：若lim(f(n)/g(n))=C(当n->∞时） 
（1）当C≠0时，说明f(n)与g(n)同阶，记为f(n)=θ(g(n))
（2）当C=0时，说明f(n)比g(n)低阶，记为
f(n)= O (g(n))
（3）当C=∞时，说明f(n)比g(n)高阶，记为f(n)=Ω(g(n))

```

### 对于O、Ω和θ的定义，重点是理解O

```
一）O的运算性质：
 (1) 0(f)+ O(g)=0(max(f,g))
 (2) 0(f)+ O(g)=0(f+g)
 (3) 0(f)O(g)=0(fg)
 (4) 若g(n)=0(f),则0(f)+0(g)=0(f)
 (5) 0(cf(n))=0(f(n))
 (6) f=O(f)

（二）O的运算性质的证明：
性质(1) 0(f)+ O(g)=0(max(f,g))
证明：设F(N)=0(f),根据0的定义，存在正常数C1和自然数N1，
使得对所有的N>=N1，有 F(N)<=C1f(N),
同理，设G(N)=0(g), 根据0的定义，存在正常数C2和自然数N2，使得对所有的N>=N2，有 F(N)<=C2f(N).
现在令C3=max(C1,C2),N3=max(N1,N2),h(N)=max(f(N),g(N)),
则当N>=N3时，必有：
①F(N)  <=  C1f(N)  <=  C3f(N)  <=  C3h(N)和 
②G(N)  <=  C2g(N)  <=  C3g(N)  <=  C3h(N) 
上面两式相加,得:F(N)+G(N) <=  2C3h(N),
取C=2C3,则当 N >=  N3时，有:0(f)+0(g) <=  Ch(N)=Cmax(f,g),
再根据0的定义可得, 0(f)+0(g)=0(max(f,g))
```

### 小节

```
首先给出传统的数据结构的概念，继而介绍抽象数据类型和面向对象的基本概念，回顾C++语言的基本特征，以及算法的效率和算法分析的基本方法。
    本章的学习将贯穿全书。
    通过本章学习，希望掌握如下内容：
1. 了解下列有关数据结构的术语和概念：
    数据、数据元素、数据结构、逻辑结构、存储结构、  
数据类型、抽象数据类型、数据结构的规范和实现。
2. 复习下列面向对象的术语和概念：
    对象、属性、服务、对象类、 继承、父类、子类

3.复习下列 C++概念：
    传值参数、引用参数、常量引用参数、函数原型、动态存储分配、操作符重载、友元函数、友元类、继承、基类、派生类、多态性、虚函数、动态联编、纯虚函数、抽象类、模板函数和模板类。
    
4.了解数据结构的抽象层次。
5. 学会使用类属抽象数据类型和模板抽象类描述数据结构的方法。 
6. 算法、算法的空间复杂性、算法的时间复杂性、程序步和渐近时间复杂性。
7. 学会使用程序步来分析一个算法的渐近时间复杂度。
8. 会根据0的定义对0的一些性质给出证明.

```





### 冒泡排序：

就是比较，然后交换 

### 排序： O(n*log(n))

```
sort (arr ,1 ,n):
return arr[1,k]    
```



### 局部排序：O（n*k）

### 堆： 分治法O（n*log（k））



# 堆栈

### 堆栈空间分配（百度百科）

栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS（操作系统）回收，分配方式倒是类似于链表。

### 堆栈缓存方式

栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

### 堆栈数据结构区别

堆（数据结构）：堆可以被看成是一棵树，如：堆排序。
栈（数据结构）：一种先进后出的数据结构。







### 堆栈（stack）（维基百科）

又称为栈或堆叠，是计算机科学中的一种抽象数据类型，只允许在有序的线性数据集合的一端（称为堆栈顶端，英语：top）进行加入数据（英语：push）和移除数据（英语：pop）的运算。

因而按照后进先出（LIFO, Last In First Out）的原理运作。

//常与另一种有序的线性数据集合队列相提并论。

堆栈常用一维数组或链表来实现



### 操作

堆栈使用两种基本操作：推入（压栈，push）和弹出（弹栈，pop）：

推入：将数据放入堆栈顶端，堆栈顶端移到新放入的数据。
弹出：将堆栈顶端数据移除，堆栈顶端移到移除后的下一笔数据。
特点

### 堆栈的基本特点：

先入后出，后入先出。
除头尾节点之外，每个元素有一个前驱，一个后继。



# 软件工程

### （测试的方法，设计模式）

```
耦合性：也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息

内聚性：又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。

所谓高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则。

耦合：一个软件结构内不同模块之间互连程度的度量。

对于低耦合，粗浅的理解是：
一个完整的系统，模块与模块之间，尽可能的使其独立存在。也就是说，让每个模块，尽可能的独立完成某个特定的子功能。模块与模块之间的接口，尽量的少而简单。如果某两个模块间的关系比较复杂的话，最好首先考虑进一步的模块划分。这样有利于修改和组合。 
```



