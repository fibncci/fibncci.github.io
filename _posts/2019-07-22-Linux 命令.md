---
layout: post
title: "Linux 常用命令"
date: 2019-07-22
tag: 学习
---





### 基本内容

#### 1、命令提示符

`[root@localhost ~]#`

```
[当前登陆用户@主机名 当前所在目录] 用户区分符号  ~ 用户家目录\# 超级管理员    $ 普通用户
```

#### 2、文件命名

不要用特殊符号（$?-=<>|@…）和 / 命名 
不要用 . 和 .. 表示当前目录和上层目录 
用 . 开头表示隐藏文件 
严格区分大小写

#### 3、文件颜色

```
bash下可根据文件后缀名自动适配颜色，具体查看 /etc/DIR_COLORS文件描述
```

#### 4、命令格式

```
<pre>`命令 [选项] [参数]`</pre>
```

---



### 目录操作命令

#### ls 命令

用于查看当前目录下的 子目录和子文件

```
格式: 
	ls [选项] [参数]
```

```
选项:
	-a 	查看所有文件和目录 (包含隐藏文件和目录)
		Linux文件名or目录名前面以  . 小数点 开头, 即为隐藏
	-l  以"长格式"显示所有文件和目录 (长格式 就是详情信息)
	-d  仅显示当前目录


	选项也可以组合使用
	-al 以"长格式"显示所有文件和目录( 包含隐藏文件和目录 )
	-dl 以"长格式"显示当前目录
	-hl 以"长格式"显示所有文件和目录( 大小以常规单位显示, 例如 KB )
```

```
参数:
	文件名 or 目录名
```



> 在文件名or目录名前面加 . (小数点) 都算是隐藏文件or目录



#### cd 命令

用于切换目录

```
格式:
	cd [目录名]
```



**了解Linux目录结构**

| 目录        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| /           | 根目录,    根目录通常只存放目录, 不存放文件                  |
| /bin        | 存放普通用户可执行的命令                                     |
| /sbin       | 存放管理员可执行的命令                                       |
| /etc        | 系统管理 和 配置文件                                         |
| /home       | 普通用户的主目录                                             |
| /root       | 管理员的主目录                                               |
| /boot       | 系统启动目录                                                 |
| /dev        | 设备文件目录,   linux中所有内容都是文件,  包括硬件设备       |
| /var        | 存储动态数据, 例如日志, 缓存等                               |
| /usr        | 超大目录, 大多软件都安装在这个目录中                         |
| /lib        | 系统函数库                                                   |
| /mnt        | 挂载目录,  最早的挂载目录, 常用于挂载 光盘, 镜像等           |
| /media      | 挂载目录,  常用于挂载多媒体设备,  例如 U盘, 移动硬盘         |
| /misc       | 挂载目录,  用于挂载共享目录<br>偷偷告诉大家,  其实这三个都是挂载,  用久了, 发现挂哪个都差不多, 能正常使用挂载设备就行 |
| /opt        | 第三方软件的安装位置                                         |
| /srv        | 系统服务数据目录                                             |
| /proc       | 虚拟文件系统, 存储在内存中, 保存有: 进程, 外部设备,网络状态灯 |
| /sys        | 虚拟文件系统, 存储在内存中, 保存有: 系统内核相关的信息       |
| /lost+found | 备份恢复目录                                                 |

`/`, `/boot`,`/root`,`/home`,`/etc`,`/mnt`



#### pwd 命令

查看当前的位置 ( 以绝对路径的方式 )



#### tree 命令

查看目录结构

```
格式:
	tree [选项] [目录名]
```

```
选项:
	-a 		查看树结构, 包含所有文件 and 目录 (默认)
	-d  	查看树结构, 只包含所有目录
	-L n 	只查看 n层树结构
	-f 		显示 "完整路径" 的树结构
```



#### mkdir 命令

创建目录

```
格式:
	mkdir [选项] 目录名
```

```
选项:
	-m 	创建目录并设置权限
	-p  创建多级目录
```



#### rmdir 命令

删除**空目录**

```
格式:
	rmdir [选项] 目录名
```

```
选项:
	-p 	删除多级空目录
	-v  删除目录并查看删除过程
```



#### rm 命令

删除文件或目录

```
格式:
	rm [选项] 文件or目录
```

```
选项:
	-r 	多级删除
	-f  强制删除
	-v  删除并显示过程
	-i  删除之前, 会向用户进行提示并确认
```



#### cp 命令

拷贝文件或目录

```
格式:
	cp [选项] 文件or目录(来源)  文件or目录(目标)	 
```

```
选项:
	-r 	拷贝多级目录
	-p 	保留源文件or目录的属性(属性包含时间, 权限等)
	-a  保留源文件or目录的属性, 递归拷贝等(基本算是完全拷贝)
	-i  拷贝时提示
```



#### mv 命令

剪切、重命名目录 (也可以文件)

```
格式: 
	mv [选项] 源目录 目标目录
```

---



### 文件操作命令

#### touch 命令

- 创建一个新的文件
- 更新已存在文件的时间

```
格式:
	touch [选项] 文件名
```

```
选项:
	-m 	仅仅更新修改时间, 内容不影响
```



#### unlink 命令

删除文件, 与rm一样,  **都可以**删除文件

```
格式:
	unlink 文件名
```



#### cp 命令

拷贝文件

```
格式:
	cp [选项] 源文件 目标文件
```



#### mv 命令

剪切、重命名文件

```
格式:
	mv [选项] 源文件 目标文件
```

```
选项: 
	-b 目标文件已存在, 则先提示, 确认覆盖则会先备份
	-i 剪切时提示
	-f 目标文件已存在, 不提示, 直接覆盖  类似rm中的-f, 具有强制性, 比较霸道
```



#### cat 命令

快速查看文件内容 (注意:  cat 适合小量内容,  大量内容建议使用more命令查看)

```
格式:
	cat 文件名
```



#### more 命令

**滚屏**查看文件内容

```
格式:
	more [选项] 文件名
```

```
选项:
	-数字  指定每屏显示的行数

```

1. 滚屏查看内容

   命令: `more  文件名`

   操作: 

   ​	`回车  下一行`

   ​	` 空格  下一页`

   ​	`b    上一页`

   ​	`q    退出`

2. 指定行数查看内容

   命令: `more -5 文件名`

   每滚屏一次, 显示5行

3. 从指定行数开始查看内容

   命令: `more +3 文件名`

   从该文件的 第3行开始查看内容



#### head 命令

查看文件的前 N 行

```
格式:
	head [选项] 文件名

```

```
选项: 
	-n 数字N 	前N行, 默认10行
	-c 数字N  前N个字符

```

1. 查看文件的前 5 行

   命令: `head -n 5 c.txt`

2. 查看文件的前 10个字符

   命令: `head -c 10 c.txt`



#### tail 命令

查看文件的后 N 行

```
格式:
	tail [选项] 文件名

```

```
选项:
	-n 数字N  最后N行, 默认10行
	-c 数字N  最后10个字符

```





#### file 命令

查看文件**内容类型**

```
格式:
	file [选项] 文件名

```

```
选项:
	-b 	不显示文件名, 直接显示结果
	-c 	详情显示指令执行过程

```

---



### 帮助命令

#### help

很多命令都有一些辅助选项, 但由于linux命令太多, 从而记不住这些选项, 可通过help来提示

```
格式:
	命令 --help
```



#### man

更加完整的帮助信息, 信息主要来自于man手册,  而help 提示选项是命令本身内置的

```
格式:
	man 命令
```

---



### 文件搜索命令

#### find

主要用于搜索文件

```
格式:
	find 范围 [选项] 文件名
```

```
选项:
	-name 	根据文件名查询
	-iname  根据文件名查询, 不区分大小写
	-ctime N  在N天被修改过的文件
```



#### grep

一个神奇强大的文本搜索工具, 主要是搜索内容.  可以使用正则

```
格式:
	grep [选项] "搜索内容" 文件名
```

```
选项: 
	-i 不区分大小写
	-v 反选
	-n 显示行号
```

---



### 权限管理

#### 查看权限

命令: `ll` 或 `ls -l`

该文件给不同的人 授予不同的权限

用户: ` rw-` 	代表自己可以读 和 写

用户组: `r--`  代表只能读,  意味着同组成员可以读, 但不能写

其他组: `r--`  代表只能读

**用户: **一般是指创建该文件的人, 后期可以改变用户

**用户组: ** 用户所在的组

**其他组:**  用户不在的组都称之为其他组  



#### 权限分析

​	Linux 非常注重权限的分配, 这也是为什么Linux安全系数高的原因.

​	Linux的每一个文件 or 目录都将权限分给 **3块**, 分别为: 

​		**User**:  文件or目录的**拥有者**

​		**Group**: 文件or目录的**所在群组**

​		**Other**: 除以上两个之外, 都属于Other范围

​	这 3块, 又将权限细分为:  

| 权限            | 权限值 | 简写 |
| --------------- | ------ | ---- |
| 读(read)        | 4      | r    |
| 写(write)       | 2      | w    |
| 可执行(execute) | 1      | x    |
| 无权限( - )     | 0      | -    |



#### 权限计算

权限都有权限值:

- `r`  读为 4
- `w`  写为 2
- `x`  可执行为 1
- `-`  无权限为 0

用户的权限是由以上组成的.

例如:  

​	可读可写 4+2 = 6

​	可读可写可执行 4+2+1 = 7

​	只读 4 = 4

​	无权限 0 = 0

用户组 和 其他组也是这么计算



#### 权限设置

```
格式:
	chmod 3位数 文件名
```

百位 => 用户

十位 => 用户组

个位 => 其他组



#### 修改权限

```
格式:
	chmod 角色+权限  文件

角色:
	用户      u
	用户组    g
	其他组	   o
	所有人    a

权限:
	读   	r
	写		w
	执行 	   x
	
	添加权限 +
	删除权限 -
	赋予权限 = 

```



1. 添加 读权限

   命令: `chmod u+r a.txt`

   u+r  仅仅是给用户 添加读权限

2. 删除 读权限

   命令: `chmod u-r a.txt`

   u-r 仅仅是用户 删除了读权限

3. 添加 读写权限

   命令: `chmod u+rw a.txt`

   u+rw 给用户添加 读写权限

4. 同时给多个人添加权限

   命令: `chmod u+r,g+rw a.txt`

   u+r, g+r  分别给 用户添加读权限, 用户组添加读写权限 

5. 给所有人添加权限

   命令: `chmod a+rw a.txt`

   a+rw 给用户, 用户组, 其他组都添加 读写权限 (所有人)

6. 给所有人设置权限

   命令: `chmod a=rw a.txt`

   a=rw 给用户, 用户组, 其他组都设置为 读写权限(所有人)

---







### 用户管理

#### 管理员

Linux系统是一个`多用户,多任务`的分时操作系统.

任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。

管理员可以对这些 账号用户做`使用跟踪`, `访问限制`, `保护用户`.

管理员对用户的日常工作主要有以下操作: 

- 用户账号的添加, 删除, 修改
- 用户密码
- 用户组管理



#### 添加用户

```
格式:
	useradd [选项] 用户名
```

```
选项:
	-c 	备注,描述. 备注会存储在 /etc/passwd 中
	-d  指定家目录, 默认家目录 /home
	-m  自动建立用户家目录
	-g  指定用户所在的组，否则会建立一个和同名的组
```



#### 设置密码

```
格式:
	passwd 用户名
```

1. 给指定用户设置密码

2. 修改指定用户的密码

   

#### 删除用户

```
格式:
	userdel [选项] 用户名
```

```
选项:
	-r 	删除与用户相关的文件, 例如: 家目录
	-f  强制删除,就算已登录也可以删除
```



#### 添加组

```
格式:
	groupadd 组名
```



#### 删除组

```
格式:
	groupdel 组名
```



#### 指派组

```
格式:
	gpasswd [选项] 用户名 组名
```

```
选项:
	-a 	将用户添加进组
	-d  将用户从组中移除

```



#### 查看当前所在组

```
格式:
	groups

```



#### 切换用户

```
格式:
	su - 用户名

```

1. 切换 **管理员用户**登录

   命令: `su` 或 `su - root`

   

#### 用户信息

里面存储所有用户的相关信息

**命令: ** `vim /etc/passwd`

**分析:** 

​	`root:x:0:0:root:/root:/bin/bash`  以此为例,  **冒号**作为**间隔**

- root 	用户名

- x     密码位, 由于现在都是用shadow技术, 把真正的密码存放在其他位置**(/etc/shadow)**, 以提高安全性

- 0     用户id, 通常 0 代表管理员,  普通用户都是从 500开始

- 0     组id, 与 /etc/group 有关

- root  用户描述

- /root  家目录

- /bin/bash  可以由此shell登录

  ------

  此文件除了 管理员 和 普通用户, 都是伪用户, 主要是 系统自己使用的账户, 不是给我们使用, 所以称之为**伪用户**



#### 密码信息

里面存储所有用户的密码信息

命令: `vim /etc/shadow`

里面每一行存储内容, 分别为:

- 用户名
- 密码,   加过密的,  如果只有 `!` or `*` , 则代表不能登陆该用户
- 最后一次修改时间     1970年1月1日开始计算的天数
- 最小时间间隔           在该天数内, 无法修改密码, 如果是0, 则没有限制
- 最大时间间隔           密码过期时间, 必须重新密码, 如果是 99999, 则没有限制
- 警告时间  	         配合最大时间间隔, 会做个提醒
- 不活动时间              超过最大时间间隔, 能用的宽限时间
- 失效时间                 过了该日期, 则密码失效



#### 组信息

里面存储了所有的组

命令: `vim /etc/group`

里面每一行存储内容, 分别为: 

- 组名
- 密码位,  一般组用密码的较少
- 组id
- 附加组员



#### 修改所属用户或组

```
格式:
	chown  新用户名  文件名

```

1. 修改文件的所属用户

   命令: `chown root a.txt`

   本来a.txt 是 用户hl的,  经过chown修改后, a.txt成为 用户root的了



```
格式:
	chown 新用户名:新组名 文件名

```

1. 修改文件的所属用户和组

   命令: `chown root:root a.txt`

   本来a.txt 的用户 和 用户组都是 hl的, 经过chown, 变成了 root用户的了

   

```
格式:
	chown :新组名 文件名

```

1. 修改文件的用户组

   命令: `chown :hl a.txt`

   本来a.txt 的用户组是 root, 经过chown修改后, 用户组变成了 用户hl的了

---



### 打包压缩

将文件 or 目录进行压缩, 以更小的体积(二进制)进行存储, 从而获取更多的磁盘利用空间.

在 Linux 中常见的压缩格式为: `gzip`, `bzip2`

这些与windows中见到的`rar`,`zip`类似, 而且 Linux 和 windows 都能识别 zip 格式



#### gzip

gzip 只用于压缩文件

gzip文件扩展名: `.gz`

特性:

- 只能**单个压缩文件**
- 不能压缩目录
- 会**覆盖源文件**

```
格式:
	gzip [选项] 文件1 文件2 文件3 ...
```

```
选项:
	-d 	解压
	-r  压缩or解压 到 指定目录下的所有文件(包含子目录, 逐个进行压缩)
```



#### bzip2

bzip2 只用于压缩文件

bzip2文件扩展名: `.bz2`

特性:

- 只能单个压缩文件
- 不能压缩目录
- 会**覆盖源文件**

```
格式:
	bzip2 [选项] 文件1 文件2 文件3 ...
```

```
选项:
	-d 解压
```



> gzip 和 bzip2的区别?
>
> gzip   压缩速度较快
>
> bzip2 压缩后的体积更小



#### tar

`打包`: 只是将文件存入一个目录中, 文件大小不会有变化

`压缩`: 通过一些算法,  将文件以 更小的体积 存储.

特性: 

- 可压缩文件和目录
- **不会覆盖源文件**



```
格式:
	tar [选项]  压缩包名  被压缩的文件1 被压缩的文件2  ...
```

```
选项: 
	-c  新建一个压缩文件, 这就是打包 (小写)
	-C  切换到指定目录 (大写)
	-z  gz格式, 即 gzip 类型
	-j  bz2格式,  即 bzip 类型
	-f  目标文件( 取一个压缩包的名字, 注意, -f 后面必须立马跟 "压缩文件名", 所以一般 "-f" 在选项的最后面 )
	-v  显示过程
	-t  不解压查看
	-x  解压
```

1. 打包文件

   命令: `tar -zcvf demo.tar.gz  a.txt b.txt`

   将 a.txt 和 b.txt 都打包进 demo.tar.gz中

2. 查看打包文件

   命令: `tar -tf demo.tar.gz`

   可以查看到 demo.tar.gz 里面有哪些被打包的文件

3. 解压文件

   命令: `tar -xf ./demo.tar.gz`

   将 demo.tar.gz 解压到当前目录下

4. 解压文件到指定目录下

   命令: `tar -xf ./demo.tar.gz -C ./y` 

   将 demo.tar.gz 的内容全部解压到  y目录下

> 小结:
>
> ​	打包并以 gzip压缩:    zcvf
>
> ​	打包并以 bzip2 压缩:  jcvf



#### zip

zip 是 Linux 和 Windows 都能识别的压缩格式, 相对而言, 在Linux 中使用较少,  且压缩比例不如tar

特性:

- 可压缩文件 和 目录
- 不会覆盖源文件

```
格式:
	zip [选项] 压缩包名  文件1 文件2 文件3 ...
```

```
选项: 
	-r  压缩目录
```



#### unzip

**解压** zip包

```
格式:
	unzip [选项] 压缩包名

```

```
选项:
	-d  解压到指定目录下

```

---



### 关机重启

#### 重启系统

重新启动Linux, 所有的远程工具连接也会全部失效, 需要等待重新好之后,再次连接

```
格式:
	reboot
```



#### 关机

```
格式:
	shutdown [选项]
```

```
选项: 
	-h 时间  指定时间关机
	-r 时间  指定时间重启
	-k 内容  提示警告, 但不会关机	
```

---



### 挂载卸载

#### 认识设备

Linux 有时会需要用到光驱, U盘等外接设备, 而我们用的Linux又是命令界面, 而非图形界面, 无法双击打开外设.

那么此时, 就需要用到挂载了. 通过相关命令, 可直接读取光驱, U盘等里面的内容

在Linux的根目录下, 有一个 dev目录, 是专门存放设备的目录. 可以查看所有的设备.



其中, 这些分区目录都是以 sda, sdb, sdc 等名字出现的

Linux 本身分区, 一般都是 sda

外接设备1, 一般为 sdb

外接设备2, 一般为 sdc

以此类推.

我们也可通过 `fdisk -l` 命令查看, 已有的分区目录



在dev中, 还有cdrom, sr0, sr1 等等的存在

cdrom 代表光驱本身

sr0 是其中的一个光驱0

sr1 是其中的一个光驱1

以此类推

---



### 挂载u盘

```
格式:
	mount 设备地址 挂载地址
```

1. 挂载u盘

   命令: `ls /dev`

   命令: `mount /dev/sdd  /mnt/usb`



#### 挂载光驱

```
格式:
	mount 设备地址  挂载地址
```

1. 挂载 ios镜像

   命令: `mkdir /mnt/ios`

   命令: `mount /dev/sr0 /mnt/ios`



#### 卸载挂载

解除u盘与mnt的挂载连接

```
格式:
	umount 挂载地址 	

# 当前位置一定不能在 挂载地址目录中
```

---



### 系统信息

#### 查看IP

可以查看到自己的IP地址,  网关, DNS 等等

```
格式:
	ifconfig

注意: 是ifconfig 不是ipconfig, 在windows中查看ip是用 ipconfig, 因此有不少熟悉windows的人容易写错
```



#### 修改IP

网卡信息的存储位置在:  `/etc/sysconfig/network-scripts/ifcfg-eth0`

命令: `vim /etc/sysconfig/network-scripts/ifcfg-eth0`

```
DEVICE=eth0 					描述网卡对应的设备别名, 第一个网卡eth0, 第二个eth1, 以此类推
HWADDR=00:0C:29:4C:CE:92 		物理网卡地址
TYPE=Ethernet 					网卡类型
UUID=86f8d304-55ba-4d0b-bb8d-6e5f9574f1a5
ONBOOT=yes 						系统启动时是否设置此网络接口, yes激活此设备,  no关闭此设备
NM_CONTROLLED=yes
BOOTPROTO=dhcp 					启用地址协议:
									static 静态协议
									dhcp   自动获取协议
									bootp  bootp协议
```

如果是手动修改ip, 则需要做以下调整

```
BOOTPROTO=none 			    设为none
IPADDR=192.168.31.10 		设置ip   例如: 192.168.31.10
NETMASK=255.255.255.0 		子网掩码  例如: 255.255.255.0
GATEWAY=192.168.1.1 		网关地址  例如: 192.168.31.1
DNS1=8.8.8.8 				DNS设置  例如股: 8.8.8.8
```



#### 重启网卡

修改ip之后, 必须重新网卡服务, 才能真正的起作用

```
格式:
	service network restart
```



#### 网络连接测试

可通过ping方式, 来检测网络是否连接成功.

```
格式:
	ping [选项] ip地址
```

```
选项:
 	-c N 	只ping N次, 不指定则一直ping测试
```

---



### 基本快捷键

#### 终止命令

在持续执行命令 or 命令等待界面, 如果不想在等或继续执行, 通过`终止命令`强行结束

```
快捷键:
	ctrl + c
```



#### 清屏

当屏幕命令非常繁多, 眼花缭乱时, 推荐清理一下屏幕

```
快捷键:
	ctrl + L 

命令: 
	clear
```



#### 命令补全

当 linux命令较长 or 地址路径较长 or 地址名记不全, 都可以通过 补全来`做提示`

补全键: `Tab`



#### 退出系统

退出当前系统

```
快捷键:
	Ctrl + D

命令: 
	exit

```

---



### 软件包

在Linux系统中, 所有软件包可以分为以下两种: 

- 二进制包 ( 安装速度快, 不可自定义安装 )
- 源码包    ( 编译时间长, 效率高, 可自定义安装 )



#### 二进制包

二进制包的格式: `文件名.rpm`



**查看 iso镜像的rpm包**

1. 挂载 iso镜像 到 /mnt/iso

   不会的, 可以先学习前面的 `挂载.md` 教程

2. 进入 /mnt/iso/Package

3. `ls` 查看所有的 rpm包

4. 统计一共有多少个文件, 命令: `ls | wc -l`

   我的iso镜像中, 发现有 3000多rpm包

   这些 rpm包的命名规则如下: 

   `软件名-版本号-更新次数.el6.平台.rpm`

   其中 el6 代表centos 6

   平台:

   - i386 	32位操作系统
   - i686        是i386的一个子集
   - x86_64    64位操作系统
   - noarch     跨平台

------

对于 rpm包有 两种安装方式:

- rpm 
- yum 



##### rpm安装

```
格式:
	rpm [选项] 软件包名
```

```
选项:
	-i 	显示相关信息
	-v  显示安装过程
	-h  显示安装时的进度标记
	-q  查询包
	-l  查询包的安装位置
	-f  查询某文件的起源包
	-a  查询安装过的rpm包
	-U  升级rpm包
	-e  删除指定rpm包
```

1. **安装** tree 软件包

   命令: `rpm -ivh tree-1.5.3-3.el6.x86_64.rpm`

   

2. **升级** tree 软件包

   命令: `rpm -Uvh tree-1.5.3-3.el6.x86_64.rpm `

   

3. **卸载**tree 软件包

   命令: `rpm -e tree`

   注意, 这里的tree 软件包, 不要填写完整, 只需要协商tree即可. 相当于命令名

   

4. 查询**是否已安装过 tree包**

   命令: `rpm -q tree` 	检测是否已经安装过 tree包

   命令: `rpm -qi tree`    检测是否安装过tree包, 并详细显示

   

5. 查询**所有安装过的 软件包**

   命令: `rpm -qa `

   会显示所有已经安装过的 rpm包

   

6. 查询 **tree包的安装位置**

   命令: `rpm -ql tree `

   可以查看到 tree包 可执行命令, 文档, 帮助等 文件位置

   

7. 查询 **tree命令的起源包**

   命令: `rpm -qf /usr/bin/tree`

   查看 tree命令是安装哪个包后而产生的

   **注意: ** 这里的tree命令一定要说清具体位置



##### yum安装

yum 一般有两个安装来源:

- 在线官网
- iso镜像

默认情况, 都是在线官网, 只要有网络, 就可以直接下载.

iso镜像是本地有现成的镜像, 那也可行本地安装, 就不需要联网了



```
格式:
	yum [选项] 软件包名
```

```
选项:
	-y 	在安装过程中, 所有的确认, 都认为是yes
```

1. 安装  tree软件包

   命令: `yum -y install tree`

   非常的简单, 方便.

2. 列出所有已安装的 软件包

   命令: `yum list installed `

3. 查看是否已安装  tree包

   命令: `yum list installed | grep tree`

   先查询所有安装的包, 再查询其中是否有 tree包.  `|` 是后期要学习的管道技术

4. 更新 tree包

   命令: `yum update tree`

5. 卸载 tree包

   命令: `yum -y remove tree` 

6. 查看 tree包的安装位置 与 rpm 命令相同



**如何辨别这是 在线安装还是 iso镜像安装？**

命令: `cd /etc/yum.repos.d`

`CentOS-Base.repo`  里面就是在线官网的地址

`CentOS-Media.repo` 里面就是本地挂载镜像的地址

> 注意:  只要 `CentOS-Base.repo`存在, 则优先使用 在线地址, 反之, 优先使用 本地镜像



**在线官网地址**

命令: `vim CentOS-Base.repo`  

- mirrorlist 	在线安装的 yum包都是从这个地址上下载下来的



**本地iso镜像**

命令: `vim CentOS-Media.repo`

- baseurl       挂载地址

- gpgcheck    安全检测  `1:开启` `0:关闭`  (由于 iso镜像是写保护, 基本无需担心安全问题)

- enabled      是否启用此配置  `1: 启用`  `0: 禁用`

- gpgkey       与gpgcheck 绑定使用, 如果 安全检测关闭, 该项则无需改动

  **注意:**

​	如果使用 iso镜像安装, 则必须先将 CentOS-Base.repo 改成其他名字, 否则优先使用Base 



#### 源码包

##### 安装

此安装方式,  是我们提前先准备好 .tar.gz包,  由windows传递给Linux, 直接本地安装.

那么就需要先在 windows中安装 Xshell, Xfpt 等远程工具了.

- Xshell  远程管理工具
- Xfpt     远程传输工具



1. 打开Xshell并连接Linux

   

2. 在Linux的 /root 查看是否成功传输过来

   命令: `ls /root`

   

3. 解压并进入

   命令: `tar -xf httpd-2.2.9.tar.gz`

   命令: `cd httpd-2.2.9`

   

4. 查看帮助文件

   命令: `vim README`

   主要用于 这个包主要是干什么, 官方怎么介绍的

   

   命令: `vim INSTALL`

   主要介绍 **如何安装这个包**,  不知道怎么安装的, 可以参考此文件

   

5. 安装 gcc 编译器

   命令: `yum -y install gcc`

   由于后面的 httpd 需要gcc编译, 所有需要提前安装好

   

6. 自定义安装目录

   命令: `./configure --prefix=/usr/local/apache2/`

   这些命令都是由 **INSTALL** 推荐介绍的

   意思是:  将当前包 安装到  **/usr/local/apache2/** 下

7. 编译

   命令: `make`

   一般编译时间, 都比较长.

   

8. 编译安装

   命令: `make install`

   

9. 启动 apache服务

   命令: `/usr/local/apache2/bin/apachectl start`

   

10. 检测是否能访问 Apache

    在windows中, 打开浏览器, 输入地址:  192.168.31.17 (这是我linux的ip地址, 可通过 ifconfig查看)

    如果显示 **It works!** 即代表成功安装. 

    以上就是httpd源码包的安装方式了, 如果没有成功访问, 最好在**关闭防火墙**后, 再测试一下.

    

##### 升级

对于源码包的升级, 一般都会选择重新编译安装, 毕竟是离线的本地安装.

##### 卸载

源码包的卸载比较暴力, 直接通过 `rm -rf` 的方式删除卸载

---



### 进程与服务

#### 进程

所有正在执行的程序, 都会在进程中展示.

So, 我们可以通过**查看进程**, **判断服务器健康状态**, **终止进程** 等操作



#### 查看进程

```
格式:
	ps [选项]
```

```
选项:
	-a 	显示所有进程(根据终端区分)
	-x  显示所有进程(不区分终端)
	-l  详情显示(长格式)
	-u  显示用户名
	-C  显示指定进程状态
	-f  显示的更详细, 例如 UID, PPIP等
	
```

1. 显示所有当前进程

   命令: `ps -ax`

2. 显示某一用户的相关进程

   命令: `ps -u xiaoming`

   只显示 `用户xiaoming` 正在使用的进程

3. 显示 CPU 和 内存信息

   命令: `ps -aux`

4. 显示指定进程信息

   命令: `ps -C httpd`

   只看看 进程httpd 的相关信息

5. 显示指定pid信息

   命令: `ps -fL 26464`

   详细显示 pid=26464 的相关信息



#### 进程树

有些进程会有一些依赖关系, 以 树形图显示的话 比较直观

```
格式:
	pstree
```



#### 实时查看整体运行情况

实时监测整个系统的运行状态, 例如 cpu, 内存

也可以通过`交互命令`改变排版

```
格式:
	top
```

```
交互命令:
	M 	按内存排序
	P   按CPU排序
	k   杀死进程, 之后输入pid来选择杀死那个进程
	q   退出
```



#### 终止进程

```
格式:
	kill [选项] 进程名 或 PID
```

```
选项:
	-9 	强制终止
```



#### 服务

服务本身其实就是一个软件, 只是该软件会被其他的软件所依赖或引用, 相当于是给其他软件提供的一些服务, 所以称该软件为 **服务**

```
格式: 
	chkconfig [--add][--del][--list][系统服务]
	chkconfig [--level 等级代号 ][系统服务][on/off/reset]
```

```
--add 添加服务
--del 删除服务
--list 显示服务

等级代号
0 : 关机, 一般很少设为0, 否则无法正常启动
1 : 单用户模式, 只能root登录, 禁止远程登录
2 : 无网络连接的多用户命令行模式
3 : 有网络连接的多用户命令行模式
4 ：不可用, 在系统没有使用时,操作一些事情.
5 ：带图形界面的多用户模式, 图形化界面
6 ：重新启动

```



#### 分类

在Linux中, 将服务分为了两类:

- 二进制包(rpm)安装的服务
- 源码包安装的服务

#### rpm 安装的服务

**1. 进目录查看**

​	命令: `vim  /etc/rc.d/init.d`

​	以下显示的都是 已经有的服务

![152](D:/Desktop/Linux%E6%93%8D%E4%BD%9C/img/152.png)



**2. 命令查看**

​	命令: `chkconfig --list`

​	该截图并没有显示完全,  但是跟 第一种 方式看到的服务是一样的

![153](D:/Desktop/Linux%E6%93%8D%E4%BD%9C/img/153.png)



**3. 查看 是否有network 网卡服务**

​	命令: `chkconfig --list | grep network`

​	

##### 服务管理

对服务做`开启`,`关闭`,`重启`,`查看状态` 等操作

Linux 对服务有两大启动方式: **手动启动**, **自启动**



##### 手动启动服务

```
格式1:
	服务名路径 [状态]
	
格式2:
	service 服务名 [状态]

```

```
状态:
	start 	开启
	restart 重启
	stop    关闭
	status  查看状态

```

1. 开启 sshd 服务 (服务路径开启)

   命令1: `/etc/rc.d/init.d/sshd start`

   首先得确保 sshd是在 /etc/rc.d/init.d 才行



2. 开启 sshd 服务 (service开启)

   命令2: `service sshd start`

​			这也能开启 sshd 服务



##### 自启动服务

将需要开机启动的服务 写在一个文件中 或 通过chkconfig命令也行

**1. 自启动文件**

命令: `vim /etc/rc.local`

添加以下代码,  即可在下一次开机or重启时, 自动启用服务

![154](D:/Desktop/Linux%E6%93%8D%E4%BD%9C/img/154.png)



**2. chkconfig命令**

命令: `chkconfig sshd on`

设置开启自启动服务 sshd,  如果最后设为 off, 则关闭开机自启动



#### 源码包安装的服务

对于源码包安装的服务, 没办法在 /etc/rc.d/init.d 查看, 因为源码包都是第三方安装过来的, 服务都在当初的指定安装下呢. 



##### 手动启动服务

```
格式:
	服务路径 [状态]
	
	没有 service 的开启方式了, service只适用于rpm服务

```

```
状态:
	start 	开启
	restart 重启
	stop    关闭
	没有 status 状态显示了, 可通过进程查看状态

```

1. 开启 httpd 服务

   命令: `/usr/local/apache2/bin/apachectl  start`

   当初httpd 就是安装在 /usr/local/apache2 下



##### 自启动服务

这其实与 rpm服务的操作方式一模一样的, 都是在 `/etc/rc.local` 里设置



### 计划任务

在指定时间 执行指定的事情, 就是计划任务.

例如:

​	每天的凌晨3点, 备份数据库

​	周一上午6点, 更新游戏



```
格式:
	crontab [选项]
```

```
选项:
	-e 	编辑计划任务
	-l  显示计划任务
	-r  删除计划任务
```



**计划任务编辑格式**

```
格式:
	分 时 日 月 周 命令
	
```

```
范围:
	分: 0~59
	时: 0~23
	日: 1~31
	月: 1~12
	周: 0~7 	0或7 都是星期日
	命令: 到指定时间需要执行的命令, 也可以是编写好的脚本
```

```
符号:
	时间格式除了填写数字, 也可以填写符号
	* : 代表所有的可能
	, : 多个选择
	- : 几到几的范围
	/ : 间隔频率
```



**案例:**

1. 准备编辑计划任务

   命令: `crontab -e`

   会进入一个专门填写 计划的文档, 按照上面的格式填写计划

2. 每天23点 直接关机

   命令: `* 23 * * * /sbin/shutdown -h now`

   每天 23点 准时关机 ,  shutdown本身就在 /sbin 管理员命令下, 所以需要加 /sbin

   > 如果没关机, 请使用 date 查看当前Linux时间是否正确.
   >
   > 时间矫正, 请查看本教程的最下面

3. 每天凌晨 5点10分重启Apache服务

   命令: `10 5 * * * /usr/local/apache2/bin/apachectl restart`

4. 每周二~周五的5点重启Apache服务

   命令: `* 5 * * 2-5 /usr/local/apache2/bin/apachectl restart`

5. 每周一, 周三, 周五的5点重启Apache服务

   命令: `* 5 * * 1,3,5 /usr/local/apache2/bin/apachectl restart`

6. 每年7月20号凌晨3点每隔10分钟就重启Apache服务

   命令: `*/10 3 20 7 * /usr/local/apache2/bin/apachectl restart`

7. 删除计划任务

   命令: `crontab -r`

   这是删除了所有的计划任务,  如果只删除个别计划任务, 进计划任务文档单独删除就是





### 时间

#### 查看时间

```
格式:
	date [选项]
```

```
选项: 
	-s 	设置时间
```

```
时间格式:
	%s 时间戳,  从1970年1月1日00:00:00到目前经历的秒数

	%Y 年, 4位数的年份
	%m 月（01~12）
	%d 天（01~31）
	%H 小时，24小时制（00~23）
    %M 分钟（00~59）
    %S 显示秒（00~59）
    
    %x,%D 日期（mm/dd/yy）
    %X 显示时间的格式（%H:%M:%S）
    %r 显示时间，12小时制（hh:mm:ss %p）
    %T 显示时间，24小时制（hh:mm:ss)
     
    %Z 显示时区，日期域（CST）
    %a 星期的简称（Sun~Sat）
    %A 星期的全称（Sunday~Saturday）
    %h,%b 月的简称（Jan~Dec）
    %B 月的全称（January~December）
    %c 日期和时间（Tue Nov 20 14:12:58 2012）
    
    %j 一年的第几天（001~366）
    %w 一个星期的第几天（0代表星期天）
    %W 一年的第几个星期（00~53，星期一为第一天）
```

1. 查看当前时间

   命令: `date`

   显示当前时间

2. 按时间格式 -> 查看当前时间

   命令: `date +"%Y-%m-%d %H:%M:%S"` 

   按照指定格式来 显示当前时间

3. 设置时间

   命令: `date -s 10:20:30 `

   将当前时间设置为: 10点20分30秒

   命令: `date -s "2019-10-20 08:09:10"`

   将当前时间设置为: 2019年10月20号 8点9分10秒



#### 校正时间

校正时间需要先 安装 ntpdate 软件

1. 安装 ntpdate

   命令: `yum -y install ntpdate`

2. 校正时间

   命令: `ntpdate cn.pool.ntp.org`

3. 更改时区

   命令: `cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime`

   将时区设置为 亚洲上海

4. 查看当前是否正确

   命令: `date`

   









