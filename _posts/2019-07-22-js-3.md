---
layout: post
title: "JavaScript-language-语言第三遍"
date: 2019-07-22
tag: lang
---









## Js训练

> ​	ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。
> ECMA-262规范 定义了ECMAScript支持的一套关键字，这些关键字标识了ECMAScript语句的开头和/或结尾。根据规定，关键字是保留的，不能用作变量名或函数名。
>
> ECMAScript实际上是一种脚本在语法和语义上的标准。实际上JavaScript是由ECMAScript，DOM和BOM三者组成的。 所以说，在JavaScript，JScript和ActionScript中声明变量，操作数组等语法完全一样，因为它们都是ECMAScript。但是在操作浏览器对象等方面又有各自独特的方法，这些都是各自语言的扩展。



> **1.编辑器**
>
> 工欲善其事，必先利其器
> 想要写好程序, 学好编程,  必须先有一个趁手的IDE(编辑器)
> 目前市场常用编辑器: 
>
> 1. Sublime Text 3
> 2. Visual Studio
> 3. HBuilder
> 4. ATom
> 5. WebStorm
> 推荐Sublime Text 3, 小巧轻便, 就是一个变态版记事本. 



**JavaScript**

> ​	这是一门肥肠神奇的语言, 可以说, 当今IT, 绝大多数项目都需要用到JavaScript ( 俗称Js ). 无论是开发网站, 制作App, 桌面程序, 还是游戏, 都要用到Js. 所以一名程序员不会Js, 程序员这条路走的不会太远太久.
>
> 未来如何判定一名新人程序员是否具有培养价值?  那么 **逻辑思维, 编程思想** 是一个重要指标
>
> 我们前期通过 Js 先锻炼逻辑思维,  慢慢具备编程思想, 会非常有利于我们学习编程

> ​	2**第一次编程**
>
> 1. 创建文件
>
>    在桌面新建一个HTML文件,  取名 `demo.html`

![1](../images/posts/js/1.gif)



> ​	2.打开`Sublime Text3 编辑器`, 并编写代码

![2](../images/posts/js/2.gif)

> ​	运行 demo.html 
>
> 在编辑器任意位置, 鼠标右键 -> 选择"在浏览器中打开"

![1](../images/posts/js/1.png)



> ​	自动打开默认浏览器, 并看到一个 `弹窗`, `弹窗`就是 `alert()` 实现的
>
> ​	以上, 是我们第一次写代码, 并成功运行代码.

![2](../images/posts/js/2.png)





> ​	**3.控制台**
>
> `alert` 来弹出内容的话, 其实还是比较繁琐的. 
>
> 浏览器自带`开发者工具`的`控制台` 来查看内容, 简单方便直观.
>
> 1. 开发者工具
>
>    每个浏览器基本都有开发者工具, 我推荐大家使用 `chrome`的开发者工具, 是Js最理想的实验环境.
>
>    打开开发者工具的方式: 
>
>    - 在浏览器的空白处, 右击选择 `检查` 或 `审查元素` 即可打开开发者工具
>    - 直接按 `F12` 也能打开开发者工具
>
> 2. 控制台
>
>    在开发者工具中, 选择 `Console`, 这就是`控制台`
>
>    在控制台中, 可以查看内容 or 运算

![3](../images/posts/js/3.gif)

 



> ​	4浏览器内核
>
> 为什么在控制台输入`1+1` 就会得到`2`?
>
> 为什么百度,淘宝网站有各种各样的字体颜色, 背景颜色?
>
> 这些功能都归功于`浏览器内核`
>
> Def 浏览器内核分成两部分: `渲染引擎` 和 `Js引擎`



![3-浏览器内核](../images/posts/js/3-浏览器内核.png)

**渲染引擎**

根据HTML代码, 向网页显示各种文字、图形,  也能给文字, 图形添加各种颜色,  还可以对文字、图形做各种排版

各大浏览器的渲染引擎

- firefox - gecko引擎
- IE - Trident引擎
- Opera - Presto引擎
- Chrome/Safari - webKit 引擎
- Chrome+Opera 联合开发 Blink引擎



**Js引擎**

本来也是渲染引擎里面的一部分, 但后来Js越做越大, 便独立出来了.

**Js引擎主要作用**: 读取网页中的 Js代码, 并对其进行处理. 例如 算术运算, 变量声明, 事件调用等等

各大浏览器的Js引擎

- 旧 IE - Jscript引擎
- IE9 - Chakra引擎
- IE Edge - Chakra引擎
- Firefox - monkey引擎
- Safari - SquirrelFish引擎
- Opera - Carakan引擎
- Chrome - V8引擎    ( Node.Js 也封装了V8引擎 )



**Js标准**				

ECMAScript 是JavaScript语言的国际标准, 简称`ES`

目前市场常用标准版本为 `ES5`, `ES6`









> 5. Js语句
>
> 在控制台中, 了解一下Console



![4](../images/posts/js/4.png)

**发现:**

Console 有 `>` 等待输入,  也有 `<` 输出结果. 那么每一次输入的东西, 被我们称之为 `语句`

在将来, 我们要编程的代码会越来越多, 一个正式的项目不会让程序员一边写代码, 一边让客户看结果. 所以我们会把代码写好,一次性导入项目中.



> 书写Js
>
> 项目中常见有两种写法:
>
> - 内部书写
> - 外部导入
>
> 第一种:(script)内部直接书写Js代码



![5](../images/posts/js/5.png)



> **第二种: **外部导入Js代码

![6](../images/posts/js/6.png)

![7](../images/posts/js/7.png)

> 注意: 
>
> ​	用了 src 就不能直接在 script 内直接书写js, 
>
> 除非在下面新写一个 script



> ​	分隔符
>
> 分隔符:  `分号;`



![8](../images/posts/js/8.png)



> 每一条Js 写完后, 强烈建议加上`;`  虽说不是必须品, 但能提高代码可读性
>
> 横排写时,  程序员一般都喜欢把字符个数控制在80个以内, 
>
> 亦可提高代码可读性



**空格/换行**

在 Js代码中, 连续多个空格 or 换行会被忽略, 所以我们随意使用空格or换行.

那么, 强烈推荐大家利用空格 or 换行对代码进行排版, 形成统一风格, 从而提高代码`可读性`

例如: 

```
x = 10 + 2
x=10+2
```

两种写法在js引擎中没任何区别, 但对于我们程序员而言, 在 `=` 两边添加空格, 可以提高整体代码可读性



**大小写**

Js 严格区分大小写

![9](../images/posts/js/9.png)





> ​	**注释**
>
> Js 注释具备两种功效:
>
> - 对代码进行描述
> - 注释代码无法执行
>
> 
>
> 注释分类:
>
> - 单行注释
> - 多行注释
>
> 
>
> **单行注释**:  `// 注释内容`
>
> **多行注释**: `/* 注释内容 */`



![10](../images/posts/js/10.png)

> 注意哦,  注释可是程序员的保命技能, 国外曾发生因不写注释而被枪毙的事情哦, 吓人!!!!!







> ​	6.变量定义
>
> 变量: 就是存储数据的容器,  与数学中的未知数是一个意思, 只是在程序中我们称之为`变量`而已
>
> 

```

声明格式variable

var 变量名;
var 变量名 = 值;
```

例如: 

```
var x = 10

```

- 关键字: var
- 变量名: x       也被称之为`标识符, 标记符`
- 值: 10

> 变量名可以是 短名称(例如 x 和 y),  也可以更具有描述性( 例如 name 和 tel )

命名规范

- 可包含`数字`, `字母`, `汉字`,`下划线`和`美元符$`
- 常用`字母`开头, 很少以`汉字`, `_` 或 `$` 开头, 不能以 `数字`开头
- 区分大小写
- 不能使用`关键字`, `保留字`



> ​	控制台查看变量
>
> 常用 `console.log()`在控制台查看变量,  平时会经常这么查看, 而非用 alert

![11](../images/posts/js/11.png)

![12](../images/posts/js/12.png)





>数据类型
>
>分类
>
>常用数据类型:
>
>- 基本类型
>- 引用类型

**基本数据类型**

- number 数字2
- string 字符串4
- boolean 布尔3
- null 空 类型 5
- undefined 未定义6
- symbol（es6）独一无二的值	；第七类数据类型

**引用类型**

- object 对象1
- array 数组
- function 函数



> ​	简单使用
>
> number 数字
>
> 数字就是 整数, 小数, 科学计数



```
var x = 10; 	// 整数
var y = 10.5; 	// 小数
var z = -5; 	// 负数
```

```
var x = 2e3; 	// 科学计数, 相当于 2*10的3次方, 结果: 2000
var y = 2e-3;	// 科学计数, 相当于 2*10的-3次方, 结果: 0.002
```



> ​	string 字符串
>
> 字符串可以含有数字, 字母, 汉字, 标点等任意字符.
>
> 字符串基本是用 `引号`包起来的, 单双引号均可.

```
var x = '三国'
var y = "曹操"
```



> ​	boolean 布尔
>
> 布尔只有两个值: `true` 和 `false`
>
> 经常被用于做比较, 判断等状态值
>
> 注意:  boolean 只能识别小写

```
var x = 5;
var y = 8;
console.log( x > y ); # false
console.log( x < y ); # true
```



> ### null   undefined
>
> null 和 undefined 在一定意义上都代表 `空值`
>
> 一般情况下, null 都是程序员主动赋值 or 意料之中的
>
> 而undefined 是 始料未及的 or 系统级的错误等
>
> 注意: null 是关键字,  而undefined 不是

> ​	2.array 数组
>
> 能将很多值 存放到一起, 这些值都是平行关系

```
var x = [
            '刘备',
            '关羽',
            '张飞',
            100,
            5.5,
            true,
        ]
```

获取数组中的值

```
console.log( x[0] ); 	// 刘备 
console.log( x[1] ); 	// 关羽
```

**小结: **

- 数组都是由键值组成, 以上案例我们只写了值
- 键默认从 0 开始, 依次递增
- 数组被`[ ] `包含



> ​	object 对象
>
> 对象有着 `一切皆对象`的口号, 上面的`数组`其实就是对象的一种

```
  var x = {
            'name': '张全蛋',
            'age': 18,
            'address': '富士康',
          }
```

获取对象中的值

```
console.log( x.name ); 	// 张全蛋
console.log( x.age ); 	// 18
```

**小结**

- 数组大多是  数字键+值
- 对象大多是  字母键+值
- 对象被 `{}` 包含



> ​	function 函数
>
> 函数也被称之为功能, 虽说也是类型之一, 但我们其实很少把他看成数据类型, 只是看做能执行特定任务的代码块

```
// 定义一个函数
var x = function demo(){ 
	// 代码块, 功能
} 	

```



> 以上只是对数据类型, 做了简单的介绍, 后面会有详细的介绍
>
> typeof 类型检测
>
> 用于获取一个数据的类型
>
> **格式:** 





```
typeof(数据)
或
typeof 数据

```

**案例:** 

```
var x = 10; 		// number
var x = 1.5; 		// number
var x = 2e3; 		// number
var x = 'abc'; 		// string
var x = '123'; 		// string
var x = true; 		// boolean
var x = false; 		// boolean
var x = null; 		// object
var x = undefined; 	// undefined
var x = [1,2,3]; 	// object
var x = {'name':'刘邦', 'age':58}; // object
var x = function (){} 	// function
console.log( typeof x );

```

> 注:  `null` 并没有返回 null类型, 而是 object类型, 这是 Js历史遗留BUG, 本应是 null类型.

经过 typeof 测试, 基本将数据分为两类人: 

- 原始数据
- 复杂数据



**原始数据**

- number
- string
- boolean
- undefined

**复杂数据**

- object
- function 







> 8	Number 数字
>
> 很多编程语言, 都会有整数、小数之分, 但是在Js中, 统称为`number`
>
> number形式

- 整形
- 浮点型
- Infinity
- NaN



> ​	整型
>
> 整型并非整容, 而是指 整数. 例如 `1`, `2`, `0`, `-1`, `-2` 等
>
> **如何判断一个值是否为整型**

```
Number.isInteger(10); 	// true
Number.isInteger(10.5); // false
```

**其他类型如何转成 整型**

```
var x = parseInt(1.2); 		// 1 	
var x = parseInt(1.7);		// 1 	
var x = parseInt('1.2'); 	// 1 	
var x = parseInt('1.7'); 	// 1 	
var x = parseInt('0.9'); 	// 0
var x = parseInt('.9'); 	// NaN
var x = parseInt('1.a');	// 1
var x = parseInt('a.1'); 	// NaN
var x = parseInt('2e3'); 	// 2
console.log( x );
```

**进制**

常见进制: 二进制Bin, 八进制Oct, 十进制Dec, 十六进制Hex



|          | 基数          |
| -------- | ------------- |
| 二进制   | 0 ~ 1         |
| 八进制   | 0 ~ 7         |
| 十进制   | 0 ~ 9         |
| 十六进制 | 0 ~ 9   a ~ f |

> ​	十进制->其他进制:
>
> **规则:**  将 十进制 除以 当前进制, 直到商为0, 结果`倒取余`

```
var x = 10100;
console.log( parseInt(x, 2) ) 	// 20

var x = 24;
console.log( parseInt(x, 8) ) 	// 20

var x = 14;
console.log( parseInt(x, 16) ) 	// 20
```

> ​	其他进制 -> 十进制:
>
> **公式: **基数 * 进制数 ^ 次方

```
var x = 20

console.log( x.toString(2) ); 	// 10100
console.log( x.toString(8) ); 	// 24
console.log( x.toString(16) ); 	// 14
```

**浮点型**

数字中可以含有一个小数点, 例如: `0.1`, `0.123`, `-0.456`

**17有效位数**

```
var x = 0.123456789012345678901234567890123456789;
console.log(x); 	// 0.12345678901234568 

var x = 123.456789012345678901234567890123456789;
console.log( x, typeof x); 	// 123.45678901234568 
```

最大是2的

```js
console.log(Number(2e307))
console.log(Number(2e308))
2e4 = 20000
//2e+307
//Infinity

```





其他类型如何转为 浮点型

```
var x = parseFloat(10); 	// 10
var x = parseFloat(10.5); 	// 10.5
var x = parseFloat('1.5'); 	// 1.5
var x = parseFloat('a.5'); 	// NaN
var x = parseFloat('5.a'); 	// 5
var x = parseFloat('.9'); 	// 0.9
var x = parseFloat('2e3'); 	// 2000
var x = parseFloat('-2.5'); // -2.5
var x = parseFloat('2.5.6'); // 2.5
console.log(x);
```



>Infinity代表无穷大



```
console.log(x); 	// Infinity

var x = -2e30000;
console.log(x); 	// -Infinity
```



>
>
>### NaN
>
>一个特殊值, 代表 `Not a Number` 意为`不是一个数`, 只要不是number数字, 都认为是 NaN
>
>**检测是否为 NaN**

```
var x = 10; 	// false
var x = 1.5; 	// false
var x = 'a'; 	// true
var x = 'a.5'; 	// true
var x = true; 	// true
var x = NaN; 	// true
var x = 0/0;
console.log( isNaN(x) );
```

**奇葩NaN**

- 只要是纯数字, 就不是NaN
- NaN 与 任何人 都不相等 ( 包括自己 )
- NaN  与 任何人运算结果都为NaN
- 0 / 0  的结果为 NaN



> ​	Number类型转换
>
> 其余类型 -> number类型
>
> - Number()
> - 骚操作
>
> 
>
> Number() 

```
var x = Number('a'); 	// NaN
var x = Number('a2'); 	// NaN
var x = Number('2a'); 	// NaN
var x = Number('2.a'); 	// NaN
var x = Number('2.'); 	// 2
var x = Number('.2'); 	// 0.2
var x = Number('2e3'); 	// 2000
var x = Number('2.5e3');	// 2500

console.log( x, typeof x);
```



> ​	骚操作
>
> 在数值之前加上`+`, 也能转为number类型
>
> 之前的 parseInt 和 parseFloat 也是类型转换的方法

```
var x = +true;      // 1
var x = +false;     // 0
var x = +'2';       // 2
var x = +'.2';      // 0.2
var x = +'a.2';     // NaN
var x = +'1.2';     // 1.2

console.log( x, typeof x);
```





> ​	9 String 字符串
>
> 在计算机中, 除了用数字表达一些东西之外, 还需要一些字母, 汉字, 标点等, 那么这些我们统称为`字符串`
>
> string 形式
>
> - 单引号
> - 双引号
> - 反引号

**单引号**

```
var x = 'Hi, 美女';
```

**双引号**

```
var x = "哇, 好大的猫";
```

**反引号**

```
var x = `这鸡真香啊`
```



> ​	区别
>
> 单双引号本身其实没多大区别, 在于使用时有部分影响, 有如下影响:
>
> - 单双引号不能自插 ( 单引号不能嵌套单引号,  双引号同理 ) 
> - 单双引号可以互插 ( 单引号可以嵌套双引号,  双引号同理 )

```
console.log( 'I give you face, you don't want a face' );  	# 报错

console.log( 'I give you face, you don\'t want a face' ); 	# 解决方法1: 将单引号 转义为普通单引号
console.log( 'I give you face, you don"t want a face' ); 	# 解决方法2: 将单引号 变为双引号
```

> ​	**转义符**
>
> `\`就是转义符, 能将特殊字符-> 普通字符. 也能将普通字符 -> 特殊字符
>
> **特殊字符 -> 普通字符**
>
> 在Js 中有不少字符本身就具有特殊意义, 例如 单引号, 双引号.  
>
> 引号一输出就被认为是字符串,  若只想输出普通的引号, 而不具备特殊意义, 可以这么做 ` \'` 或 `\"`, 在引号前面加上`\`即可.
>
> 
>
> **普通字符 -> 特殊字符**
>
> - \n  换行
> - \r  回车
> - \t  制表符

> ​	变量识别
>
> `反引号`内可以识别变量, 而单双引号无法识别
>
> **格式:** `${变量名}`

```
var name = '刘亦菲';

console.log(' ${name} 真漂亮 ');
console.log(" ${name} 真漂亮 ");
console.log(` ${name} 真漂亮 `);
```





> ​	**注意**
>
> - 单双引号的内容不能直接断行,  如需断行,  可用 `+` 连接
> - 非纯数字值 不加引号会被认为是 `变量`

```
var x = '窗前明月光' + 
		'疑是地上霜';
console.log(x);   
```

```
var x = 10; 		// 正常执行
var x = 'Hello';  	// 正常执行
var x = Hello; 		// 报错, 说 Hello 未定义
```



> ​	常用属性
>
> **.length**		获取字符串的长度

```
var x = 'abc';
console.log( x.length ); 	// 3 	变量x的字符串长度
```



> ​	常用方法
>
> - .split(分割符)	按分割符拆分到 数组中
> - .toUpperCase()		字符串转大写
> - .replace( 搜索值, 替换值 )** 	字符串替换

```
var x = 'abc-ijk-xzy';
console.log(x.split('-')); 		// ["abc", "ijk", "xzy"] 	分割字符串到数组
```

```
var x = 'abc-ijk-xzy';
console.log(x.toUpperCase()); 	// ABC-IJK-XZY 				字符串转大写
```

```
var x = 'abc-ijk-xzy';
console.log(x.replace('-','?')) // abc?ijk-xzy 				字符串替换
```







> ​	10Array 数组
>
> 为什么学习数组? 大家看下面的例子就明白了

```
// 普通变量写法, 好像有点乱

var 同学1 = '胡歌';
var 亲戚1 = '张飞';
var 同学2 = '霍建华';
var 亲戚2 = '李云龙';
var 同学3 = '刘德华';
var 亲戚3 = '孙悟空';


// 数组写法, 一目了然

var 同学 = [ 
            '胡歌',
            '霍建华',
            '刘德华',
           ];

var 亲戚 = [
            '张飞',
            '李云龙',
            '孙悟空',
           ];
```



> ​	array形式
>
> - 中括号
>
> **中括号**
>
> 中括号里面的`值`也被称之为 `元素`

```
var x = []; 			// 空数组
var x = [10, 20, 30]; 	
```

> ​	值的类型不限

```
var x = [
		10,
		1.5,
		true,
		'abc'
];
```

> ​	数组嵌套,  称之为`多维数组`

```
var x = [
		[10],
		[20],
		[[[30]]],
];
```

> ​	**获取元素**
>
> 每个值都有一个索引,  第一个值的索引为0, 第二个为1, 以此类推...

```
var x = ['大哥', '小哥', '胡哥'];

console.log( x[0] ); 	// 大哥
console.log( x[1] ); 	// 小哥
console.log( x[2] ); 	// 胡哥
console.log( x[999] );  // undefined  索引不存在
```

```
var x = [
    ['熊大','熊二','光头强'],
    ['你妹','他妹','傣妹'],
    ['百度','腾讯','阿里'],
];

console.log( x[0][1] );     // 熊二
console.log( x[1][1] );     // 他妹
console.log( x[1][2] );     // 傣妹
```



**添加/修改元素**

```
var x = ['大哥', '小哥', '胡哥'];

x[3] = '磊哥'; 	// 添加, 索引已存在
x[1] = '老哥'; 	// 修改, 索引不存在
console.log(x);		// ["大哥", "老哥", "胡哥", "磊哥"]


x[10] = '马哥';
console.log( x ); 	// ["大哥", "小哥", "胡哥", empty × 7, "马哥"]
console.log(x[10]); // 马哥
console.log(x[8]);  // undefined
```



> 数字索引必须是 连续的, 如果中间的索引没有设置, 则默认undefined
>
> 数组的索引只能是 数字
>
> 数组的索引不能 主动命名



> ​	常用属性
>
> **.length 	获取数组的长度**

```
var x = [10,20,30];
console.log( x.length ); 	// 3
或
console.log( [10,20,30].length ); 	// 3
```



> ​	常用方法
>
> **.push(元素)**  	从尾部添加元素

```
var x = [10,20,30];
x.push(90);
console.log(x); 	//  [10, 20, 30, 90]

```

**.pop()** 		从尾部删除元素

```
var x = [10,20,30];
x.pop();
console.log(x); 	//  [10, 20]

```

**.unshift(元素)** 		从头部添加元素

```
var x = [10,20,30];
x.unshift(88);
console.log(x); 	//  [88, 10, 20, 30]

```

**.shift()** 			从头部删除元素

```
var x = [10,20,30];
x.shift();
console.log(x); 	//  [20, 30]

```

**.reverse()**	颠倒数组值的顺序

```
var x = [10,20,30];
x.reverse();
console.log(x); 	//  [30, 20, 10]

```

**.splice(从哪剪,  剪几个, 插入值1, 插入值2, 插入值3, 更多插入值... )**

```
var x = ['a','b','c','d'];
x.splice(1,2); 		// 从索引1开始剪, 向后剪去2个值
console.log(x);		// ["a", "d"]


var x = ['a','b','c','d'];
x.splice(1,2,'x','y','z'); 	// 从索引1开始剪, 向后剪去2个值, 并插入x,y,z 3个值
console.log(x); 	// ["a", "x", "y", "z", "d"]


```

**.forEach( 回调函数 )** 	数组迭代 	( 将数组中的值一个一个拿出来,  直到拿完为止 )

```
var x = ['a','b','c','d'];

x.forEach(function(索引对应值, 索引){
    console.log(  '第 '+索引+' 条: '+索引对应值 );
})

运结果: 
    第 0 条: a
    第 1 条: b
    第 2 条: c
    第 3 条: d

```





> 11	Object 对象
>
> 为啥学 `对象`?  我还没对象呢 ! ! !
>
> 通过两个对比, 一看就明白, 用对象来描述一些东西, 比普通变量看起来更直观, 整体写法, array跟object长得差不多.

```
// 原始写法
var 姓名1 = '叶修';
var 性别1 = '男';
var 姓名2 = '冷巴';
var 性别2 = '女';
var 年龄1 = 23;
var 年龄2 = 18;


//对象写法
var 叶修 = {
    姓名: '叶修',
    性别: '男',
    年龄: 23,
};

var 冷巴 = {
    姓名: '迪丽冷巴',
    性别: '女',
    年龄: 18,
};
```



> ​	object形式
>
> - 大括号
>
> **大括号**
>
> 左侧不再称之为`索引`, 而是键
>
> 右侧依旧称之为`值`, 也可以是`属性`





```
var x = { }  	// 空对象
var x = {
	键1: '值1',
	键2: '值2',
	...
}
```

键 含有空格or特殊字符

```
var 叶修 = {
    'Your name': '叶修',
    '性+别': '男',
};
```

值 可以是任意类型, 甚至是对象

```
var 叶修 = {
    姓名: '叶修',
    年龄: 23,
    擅长职业: {
        剑客: '狂战士',
        神枪: '机械师',
        法师: '战斗法师',
        格斗: '气功师'
    }
};
```

**小结:** 

- 键 一般用字母or数字, 本身啥字符都能用
- 键 存在空格or特殊字符 必须加引号
- 键 不能重复, 一旦重复, 就会覆盖
- 值 可以为任意类型



> ​	对象操作
>
> **获取对象属性**

```
var 同学 = {
	姓名: '黄磊',
	年龄: 18,
}

console.log( 同学.姓名 );
```

复杂点的对象

```
var 同学 = {
    姓名: '黄磊',
    年龄: 18,
    爱好: {
        美女: '小可爱',
        运动: '约跑',
    }
}

console.log( 同学.爱好.运动 );
```

奇葩的对象

```
var 符号 = {
    '☆': '星星'
}

console.log( 符号.'☆' ); 	// 报错
console.log( 符号['☆']); 	// 以数组的方式来获取, 运行成功
```



**添加/修改属性**

```
var 对象 = {} 	// 先定义一个对象

对象.姓名 = '咪咪';  // 添加属性: 姓名
对象.年龄 = 18; 	// 添加属性: 年龄

对象.年龄 = 23; 	// 修改属性年龄为23 	由于年龄已存在, 所以才是修改, 不存在就是添加
```





> ​	
>
> # 12类型转换
>
> 在js中, 只有同等类型的数据才能进行运算, 例如: number与number 运算, string与string运算 ...
>
> 如果发生不同类型的数据进行运算, 那么,  部分类型会偷偷转换类型再进行运算. 这种行为被称之为`自动类型转换`
>
> 有自动类型转换, 自然也有`强制类型转换`
>
> #### 自动类型转换
>
> **数字类型**
>
> 小结
>
> - boolean
>   - true => 1
>   - false => 0
> - string
>   - number字符串 = >  保留数字 		( 包括正常的科学计数法 ) 
>   - 其余字符串 = > NaN
>
> 只要是与 string 相加的, 都不会做加法, 都变成了 拼接

```
var x = 10;
console.log( x + 1 ); 		// 11
console.log( x + 1.5 ); 	// 11.5
console.log( x + true ); 	// 11 		
console.log( x + false ); 	// 10 		
console.log( x - '2' ); 	// 8 		
console.log( x - 'a' ); 	// NaN 		
console.log( x - '2a' ); 	// NaN  	
console.log( x - 'true' );	// NaN  	
console.log( x - 'false' );	// NaN  	
console.log( x - '2e3' ); 	// -1990
```

> 布尔型



```
var x = true;
console.log( x + 1 ); 		// 2
console.log( x + 1.5 ); 	// 2.5
console.log( x + true ); 	// 2 		
console.log( x + false ); 	// 1		
console.log( x - '2' ); 	// -1 		
console.log( x - 'a' ); 	// NaN 		
console.log( x - '2a' ); 	// NaN  	
console.log( x - 'true' );	// NaN  	
console.log( x - 'false' );	// NaN  
console.log( x - '2e3' );	// -1999
```

**小结**

- 只有 boolean 自动转成别人的份, 要么`1`, 要么`0`



> ​	强制类型转换
>
> 转为number类型:  `Number()`, `parseInt()`,  `parseFloat()`
>
> 转为string类型: `toString()`, `String()`
>
> 转为boolean类型: `Boolean()`

![1](../../../Desktop/91开发组/2019-09-26Logic/img/1.jpg)



**重点: **

以下值 在boolean转换时为false, 其余都是true

- false

- 0

- 0.0

- -0

- NaN

- null

- undefined

- "" 空字符串

  









> ​	13运算符
>
> - 算术运算符
>   - +
>   - -
>   - \*   乘法
>   - /   除法
>   - %  取模
>   - ++  自增
>   - --    自减
>   - **    幂
> - 赋值运算符
>   - =
>   - +=  -=  *=  /=  %=
> - 字符串运算符
>   - \+ 实则还有`拼接`的意思, 也可以使用 `+=` 拼接
> - 比较运算符
> - 逻辑运算符
> - 类型运算符
> - 位运算符
> - 三元运算符
> - void运算符
>
> 



> 算术运算符
>
> 算术只要计算的是: number之间的运算, 其他类型都会自动转为 number类型



```
# 加法 + 
var x = 10;
var y = 20;
console.log( x + y ); 	# 30


# 乘法 *
var x = 10;
var y = 20;
console.log( x * y ); 	# 200

# 除法 /
var x = 10;
var y = 20;
console.log( x / y ); 	# 0.5

取商
parseInt(x/y)

# 取模 %   求余数
console.log( x % y ); 	# 1 	5除以2的余数为1

# 幂
console.log( x ** y ); 	# 25 	5的2次方为25


# 自增 ++
var x = 5;
console.log( x++ ); 	# 5 	先遇到x, 则优先返回x, 再给x+1
console.log( x ); 		# 6

var x = 5;
console.log( ++x ); 	# 6 	先遇到++, 则优先x+1, 再返回x
console.log( x ); 		# 6 	

var x = 5;
var y = x++ + ++x;
console.log(x, y); 		# x=7  y=13

var x = 5;
var y = 2;
var z = x++ - y-- - ++x;
console.log(x, y, z); 	# x=7  y=1  z=-4

```



> ​	
>
> 赋值运算符
>
> - =
> - +=  -=  *=  /=  %=

```
# 赋值
var x = 10; 	# 将 数值10 赋给 变量x

# 加等 +=
var x = 5;
var y = 10;
x += y; 	# 相当于 x = x+y 	
console.log( x, y ); 	# 15 10


# 乘等 *=
var x = 5;
var y = 10;
x *= y; 	# 相当于 x = x*y 	
console.log( x, y ); 	# 50 10

```





> ## 字符串运算符
>
> - \+  
>
> `+` 看似只是`加法`的意思,  实则还有`拼接`的意思
>
> 当然, 也可以使用 `+=` 拼接
>
> **小结:** 在 `+ `运算过程中, 只要有一边出现字符串, 那么就是`拼接`, 如果两边都是number, 那么就是`加法`
>
>  

```
var x = 10;
var y = 5;
console.log( x + y ); 	# 15 	加法


var x = 10; 	# 数字10
var y = '5'; 	# 字符串5		
console.log( x + y ); 	# 105 	拼接

var x = 'Hello ';
var y = 'boy';
x += y;
console.log( x ); 	# Hello boy
console.log( y ); 	# boy

```



> ​	比较运算符
>
> - \>    
> - \>=
> - \<    
> - \<=
> - ==
> - ===
> - !=
> - !==
>
> 注意: 比较运算符的结果只有 boolean 值

```
console.log( 5 > 10 ); 		# false
console.log( 5 >= 10 );		# false 
console.log( 5 < 10 ); 		# true
console.log( 5 <= 10 ); 	# true
console.log( 5 == 10 ); 	# false 	判断数值大小是否相等
console.log( 5 == 5 ); 		# true
console.log( 5 === 5); 		# true 		判断数值大小是否相等 且 数据类型是否相等 ( 全等 )
console.log( 5 === '5'); 	# false 	
console.log( 5 != 10 ); 	# true 		判断数值大小是否不相等
console.log( 5 !== 5 ); 	# false 	只要全等即为false, 其余都是true

```



> ## 逻辑运算符
>
> - &&
> - \| |
> - !
>
> **逻辑与 &&**
>
> 运算规则:  `与全真才为真(最后一个), 否则就是第一个假(第一个)

```
console.log( true && true );    // true
console.log( true && false );   // false 
console.log( false && true );   // false 
console.log( false && false );  // false 

var x = 3;
var y = 0;
var z = 5;
var o = false;
console.log( x && y );  // y 0 
console.log( x && z );  // z 5
console.log( x && o );  // o false 
console.log( y && o );  // y 0
```



> ​	**逻辑或 | |**
>
> 运算规则: `或全假才为假(最后一个), 否则就是第一个真(第一个)`

```
console.log( true || true );    // true
console.log( true || false );   // true
console.log( false || true );   // true
console.log( false || false );  // false 

var x = 3;
var y = 0;
var z = 5;
var o = false;
console.log( x || y );  // x 3
console.log( x || z );  // x 3 
console.log( x || o );  // x 3
console.log( y || o );  // y false
```



> ​	**逻辑非 ! **
>
> 运算规则: `真即是假, 假即是真`

```
console.log(!true); 	// false
console.log(!false); 	// true

console.log(!1); 		// false
console.log(!0); 		// true
```





> ​	类型运算符
>
> - typeof 主要
> - instanceof 
>
> **返回数据的类型**

```
var x = 10;
console.log( typeof x ); 	// number

var x = '李寻欢';
console.log( typeof x ); 	// string

var x = null
console.log( typeof x ); 	// Object 历史坑

var x = [1,2];
console.log( typeof x );  	// Object 历史坑
console.log( Array.isArray(x) ); 	// true 	这是可以只检测是否为array, 而不是object的

```





> ​	位运算符
>
> - \& 按位与
> - \| 按位或
> - ^ 按位异或
> - ~ 按位取反
> - \>> 左移
> - \<<  右移
> - \>>> 带符号右移
>
> `位运算`基本都要是转化为 `32位二进制`再运算的, `位运算`的结果都是整数

```
console.log( 5 & 1 ); // 1 	
console.log( 5 | 1 ); // 5 	
console.log( 5 ^ 1 ); // 4 	
console.log( ~5 );    // -6 	
console.log( 5 << 1 );  // 10 
console.log( 5 >> 1 );  // 2  
console.log( 5 >>> 1 ); // 2  
console.log( -5 >>> 1 ); // 2147483645 	负数需要先转补码,再位移
```

| 运算符 | 名词     | 运算规则                                  |
| ------ | -------- | ----------------------------------------- |
| &      | 按位与   | 有一个为0,即为0, 否则为1                  |
| \|     | 按位或   | 有一个为1, 即为1, 否则为0                 |
| ^      | 按位异或 | 相异为1, 相同为0                          |
| ~      | 按位取反 | ~x = -x-1                                 |
| \<<    | 左移     | 左移n位, 低位补0                          |
| \>>    | 右移     | 右移n位<br>正数: 高位补0<br>负数: 高位补1 |
| \>>>   | 右移     | 右移n位, 高位补0 , 带符号                 |

> **正负数位移原理**

```
掌握位移之前, 必须先掌握 原码, 反码, 补码
例如: 
var x = 10;

10 的原码: 00000000000000000000000000001010 	(32位, 也是 10的二进制)
10 的反码: 11111111111111111111111111110101 	全部取反
10 的补码: 11111111111111111111111111110110    反码+1 , 同时也是 -10的二进制

```

```
>> 或 >>> 或 << 正数位移: 只需要原码即可, 再左右位移
>> 或 << 负数位移: 
            - 将负数当正数用
            - 先求补码
            - 再位移
            - 再减1
            - 再反码
            - 填充符号

>>> 负数位移:  
	- 将负数当正数用
	- 先求补码
	- 再位移

```



**技巧运用**

1. 互换两个变量

   ```
   var a = 10;
   var b = 20;
   
   a ^= b, b ^= a, a ^= b; 	# 互换a 和 b 的值
   console.log(a);
   console.log(b);
   ```

2. 取整

   ```
   console.log( 3.5 | 0 );     // 3
   console.log( 3.5 ^ 0 );     // 3
   console.log( ~~3.5 );       // 3
   console.log( 3.5 << 0 );    // 3
   ```

3. 倍数

   ```
   console.log( 3 << 0 );  // 3        3*2的0次方
   console.log( 3 << 1 );  // 6        3*2的1次方
   console.log( 3 << 2 );  // 12       3*2的2次方
   console.log( 3 << 3 );  // 24       3*2的3次方
   				    // 		  以此类推
   
   console.log( 10 >> 0 ); // 10       10/2的0次方
   console.log( 10 >> 1 ); // 5        10/2的1次方
   console.log( 10 >> 2 ); // 2        10/2的2次方
   console.log( 10 >> 3 ); // 1        10/2的3次方
   				    // 		  以此类推
   				    // 左乘右除
   ```

   



> 三元运算符运算规则:
>
> 当 `表达式1 成立`, 则执行`true环境`, 否则执行 `false环境`
>
> 三元运算符 与 将来的if-else分支功能相似, 不过 三元只能处理简单分支, if-else可以处理复杂分支 



```
# 格式
表达式1 ? true环境 :  false环境

# 例如
console.log(   5%2 == 0 ? '偶数' : '奇数'    );
```

> ​	void 运算符
>
> 意为: 无效的, 空白的
>
> 可以理解为 `没有返回值` or `undefined`
>
> void的语法格式就两种: 带小括号 和 不带小括号.  `推荐: 带小阔号`
>
> **作用:** 常被用于 `超链接的禁止刷新跳转`

```
console.log(  void 10 ); 	// undefined
console.log(  void(10) ); 	// undefined
```

2

```
<a href=""> 刷新当前页面 </a>
<a href="javascript: void(0)"> 不刷新也不跳转 </a>
```

> ​	void的语法格式就两种: 带小括号 和 不带小括号.  `推荐: 带小阔号`
>
> **作用:** 常被用于 `超链接的禁止刷新跳转`

```
console.log( 2 + 5 * 8 ); 	// 先乘法, 再加法
console.log( (2+5) * 8 ); 	// 先加法, 再乘法
```

**复杂运算**

```
var x = 10;
var y =  x++ + x % 2 == 0 ? 2 : 1 ; // 结果为: 1
console.log(y);
```















## 思考题

> 思考题1
>
> 问题1:  ES5 和 ES6 有什么区别?  ( 可暂时不做, 后期再来了解 )



> ES5 新增内容

1. use strict使用严格

```js
可以在函数定义的第一行通过一个字符串语法把这个函数声明为 严格模式

function() {
  "use strict";
}
```

在严格模式下，会有如下一些限制：

- 未声明的变量赋值直接报错，而不是变成全局变量
- 函数默认的 this 将变成 undefined 而不是默认指向 window
- 对只读属性进行写操作，删除不可删除属性，对不可拓展的对象添加属性均会抛出异常
- 禁止使用 with 语句
- 重名的属性会报错，重名的函数参数会报错

2. JSON 支持
   默认支持 JSON.parse 和 JSON.stringify
3. 对象和属性
   现在可以对一个对象的属性设置 getter setter:
4. 数组新增方法
   数组新增了如下常用的方法：

- map 地图
- every每一个
- filter 过滤器
- forEach 循环数组或集合中的对象、数据
- indexOf 指数
- reduce降低
- reduceRight 减少权利
- some一些

> ​	ES6 新增内容

1.块级作用域 关键字let, 常量const
2.对象字面量的属性赋值简写（property value shorthand）
3.赋值解构

```js
let singer = { first: "Bob", last: "Dylan" };
let { first: f, last: l } = singer; // 相当于 f = "Bob", l = "Dylan"
let [all, year, month, day] = /^(\d\d\d\d)-(\d\d)-(\d\d)$/.exec("2015-10-25");
let [x, y] = [1, 2, 3]; // x = 1, y = 2
```



4.函数参数 - 默认值、参数打包、数组展开（Default 、Rest 、Spread）
5.箭头函数 Arrow functions
(1).简化了代码形式，默认return表达式结果。
(2).自动绑定语义this，即定义函数时的this。

6.字符串模板 Template strings

7.Iterators（迭代器）+ for..of
迭代器有个next方法，调用会返回：
(1).返回迭代对象的一个元素：{ done: false, value: elem }
(2).如果已到迭代对象的末端：{ done: true, value: retVal }

8.生成器 （Generators）
9.Class
Class，有constructor、extends、super，但本质上是语法糖（对语言的功能并没有影响，但是更方便程序员使用）。

10.Modules
ES6的内置模块功能借鉴了CommonJS和AMD各自的优点：
(1).具有CommonJS的精简语法、唯一导出出口(single exports)和循环依赖(cyclic dependencies)的特点。
(2).类似AMD，支持异步加载和可配置的模块加载。

11.Map + Set + WeakMap + WeakSet
四种集合类型，WeakMap、WeakSet作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。

12.Math + Number + String + Array + Object APIs
一些新的API

13.Proxies
使用代理（Proxy）监听对象的操作，然后可以做一些相应事情。

14.Symbols	象征( symbol的名词复数 )  标志
Symbol是一种基本类型。Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。

15.Promises
Promises是处理异步操作的对象，使用了 Promise 对象之后可以用一种链式调用的方式来组织代码，让代码更加直观（类似jQuery的 deferred 对象）。







> 思考题
>
> 2 问题1:  如何一次性声明多个变量
>
> 3 问题2:  声明变量时没有赋值, 那么值是多少	
>
> undefined
>
> 4 问题3: 重复声明相同的变量名, 有什么反应 f     
>
> 替换
>
> 5 问题4: 声明变量有几种方式 const let
>
> 6 问题5: 请列举10个关键字,保留字



> ​	问题1:  如何一次性声明多个变量

```js
undefined undefined 23 234 234 234

var s1,s2,s3 = 23
var s4=s5 = s6 = 234
console.log(s1,s2,s3,s4,s5,s6)
```



```js
解构。就是解析数据的结构。并赋值给变量。

例子1：对象结构。
let {username,sex} = {username:"张三",age:18,sex:'男'}；

    let obj = {username:"张三",age:18,sex:'男'}

    let {username,sex} = obj;//就是一次性声明2个变量。

    console.log(username,sex);//打印  张三 男
    
例子2：赋值数组。
 let [,,a,b] = [1,2,'测试',true,456];//把第3、4个数据赋值给a、b变量。

 

例子3：解构赋值的用法。

当后台传递参数过来的时候，可以只接收某些参数。可以使用下面的方式声明接收函数。

//这里直接接受对象内的属性值。直接解构赋值。
    function test({username,sex}) {
        console.log(username,sex);//打印  张三 男
    }
    test(obj);//调用test方法。
```





> **const**：用于声明**常量**。
>
> 注意：定义的变量的时候，必须同时初始化，且其值之后不可以修改。
>
> var：最常用的声明变量关键字。
>
> 定义的变量的时候，若没有初始化，不报错，会输出undefined。其值之后可以修改。
> var可以用来声明全局变量，也可以声明局部变量，依据它们声明的位置：
>
> 全局变量：在函数外定义的变量；（注意：若没有使用关键字声明的变量，默认为全局变量。）作用域是整个代码文件。
> 局部变量：在函数内定义的变量。作用域是当前的函数内部。
>
> 
>
> let**：**块级;
>
> 作用域 。在块级{}里面用let定义的变量，离开当前的块{}之后，就不能使用（有点像局部变量，但作用域不一样）。
> 注意：{...}一对花括弧就就是一个特定的代码块，包括直接的{}，流程语句的{}，函数的{},....。函数声明时本身就带有{}，也是属于一个代码块。



```js
var c=11;
{
    let c=12;
    console.log(c);//输出12
}
console.log('代码块外c的值：',c);//输出11
```



> ​	问题5: 请列举10个关键字,保留字
>
> 和其他任何编程语言一样，JavaScript 保留了一些关键字为自己所用。



> ​	**一、JavaScript 所有关键字：**
>
> break		case		<u>catch</u>		continue
> default		delete(**删除对象（而非构造方法或原型）的某个属性**)		do		else
> finally			<u>for</u>		function		if
> <u>in</u>			instanceof		new		return
> switch		this			<u>throw</u>		<u>try</u>
> typeof		var		void		while		with
>
> 打破	案件	抓住	继续
>
> 默认	删除		做	其他
>
> 最后		对于	功能	如果		
>
> 在		的instanceof		新		返回
>
> 开关		这个		扔		尝试
>
> 类型		VAR		空虚		而		同

**JavaScript 所有保留字**

> ​	保留字是为以后js的扩展用的，不能作为普通变量名。
>
> abstract	boolean	 byte	char
> class	const	debugger	double
> enum		export		extends		final
> float		goto		implements			import
> int		interface		long		native	
>
> package		private		protected		public
> short		static		super		synchronized
> throws		transient		volatile
>
> 抽象		布尔		字节		烧焦
>
> 类		常量		调试器		双
>
> 枚举		出口		扩展		最后
>
> 浮动		去		器物		进口
>
> INT		接口		长		本地人
>
> 
>
> 包		私人的		保护		上市
>
> 短		静态的		超		同步
>
> 投		短暂的		挥发物

|  关键字  |            |            |              |             |          |            |        |
| :------: | :--------: | :--------: | :----------: | :---------: | :------: | :--------: | :----: |
| abstract |    else    | instanceof |    super     |    摘要     |   其他   | instanceof |  超级  |
| boolean  |    enum    |    int     |    switch    |    布尔     | 枚举 int |    开关    |        |
|  break   |   export   | interface  | synchronized |    打破     |   出口   |    界面    |  同步  |
|   byte   |  extends   |    let     |     this     |    字节     |   延伸   |     让     |  这个  |
|   case   |   false    |    long    |    throw     |    案例     |   错误   |     长     |   扔   |
|  catch   |   final    |   native   |    throws    |     抓      |   最后   |    本机    |  抛出  |
|   char   |  finally   |    new     |  transient   |    字符     |   最后   |     新     |  瞬态  |
|  class   |   float    |    null    |     true     |     类      |   浮动   |     空     |  真实  |
|  const   |    for     |  package   |     try      |    const    |    为    |    包装    |  尝试  |
| continue |  function  |  private   |    typeof    |    继续     |   功能   |    私人    |  类型  |
| debugger |    goto    | protected  |     var      |   调试器    |   转到   |   受保护   |  var   |
| default  |     if     |   public   |     void     | 默认值 如果 |   公共   |    无效    |        |
|  delete  | implements |   return   |   volatile   |    删除     |   工具   |    返回    | 易挥发 |
|    do    |   import   |   short    |    while     |     做      |   进口   |     短     |   当   |
|  double  |     in     |   static   |     with     |     双      |    在    |    静态    |   与   |

> 问题6	 :声明变量时 ,带var和不带var的区别

```js
var aaa = 11;
function test4(){
    var aaa = 22;
    console.log(aaa);
}
test4();    //22
console.log(aaa);   //11
// 函数内的var aaa声明是内部变量,这时结果是第一个aaa的值.
```



```
var abc = 11;
function test4(){
    abc = 22;
    console.log(abc);
}
test4();    //22
console.log(abc);   //22，注意这里
```

```js
function test4(){
    bbb = 33;
}
test4();
console.log(bbb);   //33
```

```
结论1: 函数或者对象构造内声明的变量是私有的. 外部无法访问到. 包括原型继承后的对象.
这就是有var 和没有 var的声明的区别.
结论2: 不加var 在函数或者构造内就是赋值, 从函数内往上一层层寻找变量bbb,一直到顶层没有. 就在顶层声明一个 var bbb;
很可怕假如一个大的项目,在这里改变了bbb的值, 并没有添加var 碰巧整个项目全局变量有个同名bbb被改变,不加var不是只作用在这个函数或对象内. 出了错误很难找.
声明变量改加的就加不能怕麻烦. 结果是完全不同的
```







> 思考题
>
> 7 问题1: 了解ES6 新数据类型
>
> 

> ES6的出现,对js的发展会起到很大的作用。对前端的一些功能实现也起到了很大帮助。
> 我们都知道es5 为我们提供了六种数据类型。分别是： 
>
> 对象（Object）、数字类型（Number） 、布尔类型（Boolean）、字符串类型（String）、空类型（Null）、未定义类型（Undefind）
>
> - [Symbol 类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)*（基本）*他表示独一无二的值。
> - [Set 类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)*（复杂）*
> - [Map 类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)（复杂）
> - [WeakSet 类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)*（复杂）*
> - [WeakMap 类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)*（复杂）*
> - [TypedArray 类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)*（复杂）*
>
> 这样下来js 就有七种数据类型了。
>
> 
>
> Symbol是一种特殊的数据类型,其特点为一旦定义了之后就不可更改,故此适合用来作为对象的属性名.使其在上游定义的属性不会再下游被重写和覆盖掉.
> Symbol()对象是symbol基本类型数据的隐式对象包装器.其相当与String()和string、Number()和number、Boole()和boole.
> symbol是基本数据类型.
>
> 

```
let s = Symbol();
s // Symbol()
```



内置的Symbol值:

Symbol.hasInstance
对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。

Symbol.isConcatSpreadable
对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。

Symbol.species
对象的Symbol.species属性，指向当前对象的构造函数。创造实例时，默认会调用这个方法，即使用这个属性返回的函数当作构造函数，来创造新的实例对象。

Symbol.match
对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。

Symbol.replace
对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。

Symbol.search
对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。

Symbol.split
对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。

Symbol.iterator
对象的Symbol.iterator属性，指向该对象的默认遍历器方法。

Symbol.toPrimitive
对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。

Symbol.toStringTag
对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。

Symbol.unscopables
对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。





> 8 问题1: number 还有哪些常用属性、方法和常用函数 ???(js number 数字类型函数)
>
> 9 问题2: 函数 和 方法有什么区别 ???



​	**Number方法（整体转换0）:**

```
var a = "+100";
alert( a+100 ); // "100100"
alert(Number(a)); // 100 

var a1="000100";
alert(Number(a1));//100

var a2 = "";
alert( Number(a1) ); // 0

var a3 = "  ";
alert( Number(a1) ); // 0

var a4 = []; //[""]  [123]  ["123"] [1,2,3]
alert( Number(a4) ); // 0  0  123  123  NaN

var a5 = null;
alert( Number(a5) ); // 0

var a6；
alert( Number(a6) ); // NaN

var a7=function(){alert(0)};
alert( Number(a7) ); // NaN

var json={abc:123}
alert( Number(json) ); // NaN

```





> <u>Number 对象方法(方法	描述)</u>
>
> toString	把数字转换为字符串，使用指定的基数。
> toLocaleString	把数字转换为字符串，使用本地数字格式顺序。
> toFixed	把数字转换为字符串，结果的小数点后有指定位数的数字。
> toExponential	把对象的值转换为指数计数法。
> toPrecision	把数字格式化为指定的长度。
> valueOf	返回一个 Number 对象的基本数字值。
>
> <u>Number 对象属性(属性	描述)</u>
> constructor	返回对创建此对象的 Number 函数的引用。
> MAX_VALUE	可表示的最大的数。
> MIN_VALUE	可表示的最小的数。
> NaN	非数字值。
> NEGATIVE_INFINITY	负无穷大，溢出时返回该值。
> POSITIVE_INFINITY	正无穷大，溢出时返回该值。
> prototype	使您有能力向对象添加属性和方法。



> ​	the difference
>
> **函数（function）**是可以执行的javascript代码块，由javascript程序定义或javascript实现预定义。函数可以带有实际参数或者形式参数，用于指定这个函数执行计算要使用的一个或多个值，而且还可以返回值，以表示计算的结果。
>
> 　　**方法（method）**是通过对象调用的javascript函数。也就是说，方法也是函数，只是比较特殊的函数。

假设有一个函数是fn，一个对象是obj，那么就可以定义一个method：

```
　obj.method = fn;
　obj.method();    //定义之后的调用
```

> ​	函数是可以用函数直接量定义，也就是函数可以直接储存在变量之中，因为函数和字符串、数值一样也是数据类型。
>
> 假如储存函数的变量是全局变量，也即是window对象的一个属性。因此，当你调用这个函数时，实际上也是调用window对象的一个方法。所以在函数和方法之间并没有技术上的区别，真正的差别在于设计和目的，
>
> 方法是用来对this对象进行操作的，this对象是方法的一个重要属性，当this对象出现在方法主体内部，this值就指向调用该方法的对象。而函数通常是独立的，并不需要经常使用this对象。

```js
function Rect(w, h){    //使用this对象，避免自己调用自己
    this.width = w;
    this.height = h;
}
function area(){
    return this.width * this.height;
}
var r = new Rect(4, 5);
r.area = area;    //将函数赋值给对象的属性，来定义方法

var result = r.area();    //20
```



> 问题10: js中 string还有哪些常用属性、方法 和 常用函数 ???

```
JavaScript String对象常用方法、属性
length属性
小写转换toLowerCase()
大写转换toUpperCase()
字符串替换replace()
字符串匹配match()
字符串拼接concat()
字符串分割split()
字符串检索indexOf()
```





> 问题11: 如何删除数组中的某个值, 有几种方法
>
> 



> 11	js中使用splice删除数组中某一项或几项的几种方法
>
> splice(a,b,c) a 是下标定位的位置；
>
> b是从a起 ，之后b个字母，b= 0 时候，
>
> c 是插入的字符串，数组

```js
js中的splice方法

　　splice(index,len,[item])    注释：该方法会改变原始数组。

splice有3个参数，它也可以用来替换/删除/添加数组内某一个或者几个值

index:数组开始下标        len: 替换/删除的长度       item:替换的值，删除操作的话 item为空

如：arr = ['a','b','c','d']




删除 ----  item不设置

arr.splice(1,1)  
//arr = ['a','c','d']         删除起始下标为1，长度为1的一个值，len设置的1，如果为0，则数组不变

arr.splice(1,2)  
//arr = ['a','d']          删除起始下标为1，长度为2的一个值，len设置的2



替换 ---- item为替换的值

arr.splice(1,1,'ttt')      
//['a','ttt','c','d']         替换起始下标为1，长度为1的一个值为‘ttt’，len设置的1

arr.splice(1,2,'ttt')        
//['a','ttt','d']         替换起始下标为1，长度为2的两个值为‘ttt’，len设置的1

 

添加 ----  len设置为0，item为添加的值

arr.splice(1,0,'ttt')        //['a','ttt','b','c','d']         表示在下标为1处添加一项‘ttt’
```



> 	11-2：delete      
>
> delete删除掉数组中的元素后，会把该下标出的值置为undefined,数组的长度不会变

```js
var arr = ['a','b','c','d'];
delete arr[1];
arr;  
//["a", undefined × 1, "c", "d"] 中间出现两个逗号，数组长度不变，有一项为undefined
更新2016-11-17：在stackoverflow看到jquery之父John Resig曾经的文章写过的一个代码：



// 跑不了
// Array Remove - By John Resig (MIT Licensed)
Array.prototype.remove = function(from, to) {
  var rest = this.slice((to || from) + 1 || this.length);
  this.length = from < 0 ? this.length + from : from;
  return this.push.apply(this, rest);
};
下面给出一些实际的用例：

// 移除数组中的第二项
array.remove(1);
// 移除数组中的倒数第二项
array.remove(-2);
// 移除数组中的第二项和第三项（从第二项开始，删除2个元素）
array.remove(1,2);
// 移除数组中的最后一项和倒数第二项（数组中的最后两项）
array.remove(-2,-1);
这个例子跟上面第一个的还是挺相似的，不过没有检查元素的具体项目，而是通过元素在数组的下标位置来定位删除。
```

> 
>
> 问题12: 有哪些常用的数组方法 or 函数???
>
> 不改变原数组的方法：
> 

```js
//1.indexOf() 和lastIndexOf()

//1.1 indexOf() : 返回元素在数组的索引，从0开始。若数组不存在该元素，则返回-1。
arr.indexOf(10); //-1


//1.2 lastIndexOf():
//返回元素在数组中最后一次出现的索引，如果没有出现则返回-1.
arr.lastIndexOf(2); // 4


2.slice(): 与字符串的substring()方法一样，截取数组的一部分，返回一个新的数组。
2.1 通常，接受2个参数作为一个左闭右开区间，即包括开始索引位置的元素，但不包括结束索引位置的元素。
var arr = [1, 2, 3,4,5,6];
arr.slice(0,2)    //[1, 2]； 只返回索引0,1位置的元素


2.2 可以省略第二个参数，即截取到原数组的最后一个元素。
arr.slice(2,);    //[3, 4, 5, 6] 


2.3 如果没有传参数，则返回一个从头到尾截取所有元素的新数组。可以用来复制一个数组。
var copyArr = arr.slice();
copyArr;   //[1, 2, 3, 4, 5, 6]


3.concat(): 合并数组。把当前的数组和另一个数组连接起来，并返回一个新的数组。
var a  = copyArr.concat(arr)

3.1 concat()方法的参数可以有多个，也可以任意任意类型，数值、字符串、布尔值、数组、对象 都可以，参数会被被添加到新的数组中。

var arr1 =  [1, 2, 3,4,5,6];
var arr2 = ['a','b','c'];
var arr3 = arr1.concat(arr2);
arr3;   //[1, 2, 3, 4, 5, 6, "a", "b", "c"]


3.2 注意，如果参数是数组, 会被拉平一次，即数组会被拆开来，加入到新的数组中。具体看示例：

var arr1 = [1, 2, 3];
var arr2 = arr1.concat(66,'abc',true,[10,20],[30,[31,32]],{x:100});
arr2;  //[1, 2, 3, 66, "abc", true, 10, 20, 30, [31,32], {x:100}]
4.join(): 转成字符串。它会把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。

4.1 参数是用来指定连接的字符串。见示例代码：

var arr = [1, 2, 3];
arr.join('*')   //"1*2*3"
4.2 如果没有指定参数，默认是用,连接。

var arr = [1, 2, 3];
arr.join()   //"1,2,3"
5.toString(): 返回数组的字符串形式

var arr = [1, 2, 3];
arr.toString() // "1,2,3"
6.valueOf():返回数组本身

var arr = [1, 2, 3];
arr.valueOf() // [1, 2, 3]
7.map():

7.1 对数组的所有成员依次调用一个函数，返回值是一个新数组。

var arr = [1, 2, 3];
arr.map(function(elem){
    return elem*2;
});
//[2, 4, 6, 8]
arr; //[1, 2, 3]
7.2 map方法接受一个函数作为参数,该函数调用时，map方法会将其传入3个参数，分别是当前成员、当前位置和数组本身(后2个参数可选)。

arr.map(function(elem, index, arr) {
    return elem * index;
}); 
//[0, 2, 6]
7.3 map方法还可以接受第2个参数，表示回调函数执行时this所指向的对象。

8.forEach(): 与map方法很相似，也是遍历数组的所有成员，执行某种操作。注意：forEach方法一般没有返回值

var arr = [1, 2, 3];
function log(element, index, array) {
    console.log('[' + index + '] = ' + element);
}
arr.forEach(log);
// [0] = 1
// [1] = 2
// [2] = 3
注意: forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。

9.filter():

9.1 筛选数组的元素，返回值是符合筛选条件元素组成的一个新数组。

var arr = [1, 2, 3, 4, 5];
arr.filter(function (elem) {
  return (elem > 3);
});
//[4, 5]
9.2 filter方法接受一个函数作为参数,该函数调用时，fitler方法会将其传入3个参数，分别是当前成员、当前位置和数组本身(后2个参数可选)。

var arr = [1, 2, 3, 4, 5];
arr.filter(function (elem, index, arr) {
  return index % 2 === 1;
});
//[2, 4]
9.3 filter方法还可以接受第2个参数，指定测试函数所在的上下文对象（即this对象）。

10.some()和every(): 类似“断言”（assert），用来判断数组成员是否符合某种条件。

10.1 接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。

10.2 some方法是只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。

var arr = [1, 2, 3, 4];
arr.some(function (elem, index, arr) {
  return elem >= 3;
});
// true
10.3 every方法则是所有数组成员的返回值都是true，才返回true，否则false。

var arr = [1, 2, 3, 4];
arr.every(function (elem, index, arr) {
  return elem >= 3;
});
// false
10.4 注意，对于空数组，some方法返回false，every方法返回true

10.5 some和every方法还可以接受第2个参数，用来绑定函数中的this关键字。

11.reduce()和reduceRight(): 依次处理数组的每个成员，最终累计为一个值。

11.1reduce是从左到右处理（从第一个成员到最后一个成员）

arr.reduce(function(x, y){
  console.log(x, y)
  return x + y;
});
// 1 2
// 3 3
// 6
11.2reduceRight则是从右到左处理（从最后一个成员到第一个成员）

arr.reduceRight(function(x, y){
  console.log(x, y)
  return x + y;
});
// 3 2
// 5 1
// 6
改变原数组的方法：
1.push(): 向数组的末尾添加若干元素。返回值是改变后的数组长度。

var arr = [1, 2];
arr.push(3) ;// 3
arr; //  [1, 2, 3]
arr.push('b','c'); //5
arr; //[1, 2, 3, "b", "c"]
arr.push([10,20]); //6
arr; //[1, 2, 3, "b", "c", [10,20]]
2.pop(): 删除数组最后一个元素。返回值是删除的元素。

var arr =[1, 2, 3, "b", "c", [10,20]];
arr.pop(); //[10, 20]
arr;  // [1, 2, 3, "b", "c"]
3.unshift(): 向数组头部添加若干元素。返回值是改变后的数组长度。

var arr = [1, 2];
arr.unshift(3,4 );  //4
arr;  // [3, 4, 1, 2]
4.shift(): 删除数组最后一个元素。返回值是删除的元素。

var arr = ['a', 'b', 1, 2];
arr.shift(); //'a'
arr;  //['b', 1, 2]
5.sort(): 数组排序。

5.1 注意：默认是将所有元素转换成字符串，再按字符串Unicode码点排序。返回值是新的数组。

var arr = [1, 2, 12, 'a', 'b', 'ab', 'A', 'B']
arr.sort();  //[1, 12, 2, "A", "B", "a", "ab", "b"] 注意：12排在了2的前面
5.2 如果元素都是数字，要按从小到大排序，可以传入一个回调函数作为参数。

var arr = [1, 2, 12, 100]

arr.sort(function(a,b){
    return a-b;
});
// [1, 2, 12, 100]
5.3 如果想要从大到小排序：

arr.sort(function(a,b){
    return b-a;
});
//[100, 12, 2, 1]
6.reverse(): 颠倒数组中元素的位置

var arr = [1, 2, 12, 'a', 'b', 'ab', 'A', 'B'];
arr.reverse();
//["B", "A", "ab", "b", "a", 12, 2, 1]
7.splice(): 修改数组元素（新增、删减、替换）。从指定的索引开始删除若干个元素，然后再从该位置添加若干个元素。返回值是删除的元素组成的数组。参数1是删除元素的起始索引，参数2是删除的元素个数，之后的参数为待添加的元素。

7.1 只删除,不添加。可以传入2个参数：

var arr = ['Alibaba', 'Tencent', 'Baidu', 'XiaoMi', '360'];

// 从索引2开始删除3个元素
arr.splice(2, 3); // 返回删除的元素 ['Baidu', 'XiaoMi', '360']
arr; // ['Alibaba', 'Tencent']
7.2 只添加,不删除。第2个参数设为0，即不删除元素。

arr.splice(2, 0, 'Toutiao', 'Meituan', 'Didi'); // 返回[],因为没有删除任何元素
arr; //["Alibaba", "Tencent", "Toutiao", "Meituan", "Didi"]
7.3 先删除若干元素，然后在删除的位置上在添加若干个元素。

var  arr =["Alibaba", "Tencent", "Toutiao", "Meituan", "Didi"]
arr.splice(2,2,'Apple','Google');  //["Toutiao", "Meituan"]
arr; //["Alibaba", "Tencent", "Apple", "Google", "Didi"]
Array.isArray()
用来判断一个值是否为数组, 如果参数为数组，返回true，否则，返回false.

var arr = [1,2]
Array.isArray(arr);  //true;

Array.isArray('a'); //false
```





> 问题13: 如何删除 对象中的某个属性
>
> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete



> 从对象中真正删除属性的唯一方法是使用删除操作符;将属性设置为undefined或为null只会删除与属性关联的值，而不删除键。
> 下面的输出bar undefined和foo null-仅删除了baz，因此从输出中将其丢失。
>
> 

```js

var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;
 
for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, '' + obj[i]);
    }
}
```

```js
//例如有对象

var person={"name": "xiaojiayu", "age": 24, "gender": "man"};
1
///则删除年龄属性age的方法

delete person.age
```



> 问题14:  字符串, null, undefined 自动类型转换时会变成什么值
>
> https://juejin.im/post/5a7172d9f265da3e3245cbca

隐式转换中主要涉及到三种转换：

1、将值转为原始值，ToPrimitive()。

2、将值转为数字，ToNumber()。

3、将值转为字符串，ToString()。

```
const a = {
  i: 1,
  toString: function () {
    return a.i++;
  }
}
if (a == 1 && a == 2 && a == 3) {
  console.log('hello world!');
}

```



## 对比python

> python：	bool别的类型转换成 布尔类型

```
>>> bool([])
False
>>> bool({})
False
>>> bool(())
False
>>> bool("")
False
>>> bool(0)
False
>>> bool(0.0)
False
>>> bool()
False
```



## 常见报错

> ​	1·He11 o is not defined
>
> 意思:He11o是没有定义
>
> 解决
>
> - 定义一个变量 Hello
> - 不要用He11o

> ​	属性、方法的区别
>
> 属性是没有括号 console.log(str.length)
>
> 方法是有括号的；                                                       

> ​	\>>> ;2D
>
> 用shift+键盘左键







## 自己的笔记

> '/\r'是回车，前者使光标到行首，（carriage return）  
> '\n'是换行，后者使光标下移一格，（line feed）
>
> \r 是回车，return
> \n 是换行，newline
> 对于换行这个动作，unix下一般只有一个0x0A表示换行("\n")，windows下一般都是0x0D和0x0A两个字符("\r\n")，苹果机(MAC OS系统)则采用回车符CR表示下一行(\r)
>
> 
>
> Unix系统里，每行结尾只有“<换行>”，即“\n”；
>
> Windows系统里面，每行结尾是“<回车><换行>”，即“\r\n”；
>
> Mac系统里，每行结尾是“<回车>”,即“\r”。



JS特点

•跨平台

•安全性

•事件驱动

•弱类型

•解释性



**数据类型（布尔类型转换）bsofun**

•Boolean  		false

•String				 ''

•Object 			null

•Function 		无

•Undefined  	undefined

•Number 			 0  0.0  NaN







**js 中引入外部文件**

**必须**需要写`<script src = "1.js"></script>`    ;

同样也可以显示外部调用的函数，只需要在同一个文件夹下面就可以了。

你可以将脚本放置于` <head>` 或者` <body>`中，放在` <script> `标签中的脚本与外部引用的脚本运行效果完全一致。



```
var ar = new Array();
    // document.write(ar) //ar  这个就不显示了
    document.write('<hr>')
    console.log(ar)//Array(0)
```

**API**

API（Application Programming Interface，应用（编程）程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定。 

目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问原码，或理解内部工作机制的细节。

要连接某个东西，a给b提供的就是接口。

**JavaScript 输出数据：**

- 使用 **window.alert()** 弹出警告框。	（写在script中）			

- ```
  你可以弹出警告框来显示数据：
  ```

  

- 使用  **document.write()** 方法将内容写到 HTML 文档中

```
document.write() 方法可以用在两个方面：
 1、 页面载入过程中用实时脚本创建页面内容，用来追加一些标签。
 2、清除当前页面内容(包括源文档的任何变量或值)。重新生成内容。
		在清除全部页面内容，然后生成新的内容，即“覆盖文档"。
```



- 使用 **innerHTML** 写入到 HTML 元素。

```
<script>
document.getElementById("demo").innerHTML = "段落已修改。";
</script>
 document.getElementById(id) 方法
请使用 "id" 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容
只是替换了 id 为 three 里的内容，没有覆盖页面。
```



- 使用 **console.log()** 写入到浏览器的控制台。

```
浏览器中使用 F12 来启用调试模式， 在调试窗口中点击 "Console" 菜单。
```



Date()显示时间Mon Aug 12 2019 10:51:41 GMT+0800 (中国标准时间)



**javascript语法**

```
1. sublime的插件 emmet.
2. 火狐的插件 firebug.  按下F12即可打开调试工具.
3. 多行注释是不能嵌套的
4. typeof是函数用来检测变量类型.
5. console.log输出打印变量的功能.
6. NaN `not a number`
7. js中单双引号定义字符串的功能是一样的
8. js的字符串内容中不能直接敲换行.
9. NaN 防止程序报错
10. `else if`中间必须要加空格
11. switch case  用在具体的个数中星期 等。
    1. 比对的值必须要全等于.
    2. 多个case可以简写.


```





**js对象**声明方式

•new Object

•{}

•构造函数 

```
var phone = new Object();

		//添加属性
		phone.name = 'iphone';
		phone['price'] = 2000;
		
		console.log(phone);

--------------------
<script>
		var computer = {
			brand: 'apple',
			
			

		console.log(computer);

	</script>
------------------
//构造函数形式
		function Meinv(name,height,weight,sanwei) {
			this.name = name;
			this.height = height;
			

			this.sing = function(){
				alert('我可以唱歌');
			}
		}

		//创建
		var bingbing = new Meinv('范冰冰','180cm');
 y

		bingbing.sing();

		alert(bingbing.name);
		alert(bingbing['sanwei']);

```



**成员操作**

```
•.

•[] 当变量获取一个phone中的属性的时候，必须用这个。
```



**this**

```
•对象内部等于当前这个对象.

•对象外部等于window
```











## Js笔记

1. 认识什么是JS
   JS是JavaScript的简称
   JavaScript是什么？

   作用区分：

   - HTML:  呈现网页的内容          -- 定义一个人(有鼻子有眼)
   - CSS:   用于设置网页的样式     -- 进行化妆

- JavaScript：设置页面特效     -- 你想飞，你想上天

  JS的作用：

  1. 用于校验用户输入的表单数据
  2. 用于与用户进行交互式体验
  3. Ajax 异步加载技术
  4. 实现瀑布流、无刷新加载数据

2. 如何在HTML中使用JS

3. JS的内容：
   JS：
      客户端浏览器的JS

   ```
     1. ECMAScript的核心语法结构(如何使用JS、如何定义JS的变量)
     2. 包含DOM对象
   ```

   3. 包含BOM对象

   

   > ​	变量名的格式：

   - 字母数字下划线 以及（$）
   - 首字母不能为数字
   - 严格区分大小写
   - 不能使用关键字

   ```
   变量的命名规则：
     首字符必须是英文字母、下划线、$
     后跟任意长度的数字、字母、下划线、$
     严格区分大小写
     不允许使用JS的关键字和保留字
        关键字：JS已经使用的名字
        保留字：系统打算去用，但是目前还没有用
     命名尽量有意义
     推荐使用驼峰命名法
        变量名如果是由多个单词组成，第一个单词的首字母小写，其他单词的首字母要进行大写
   ```

```
var bool =true;
alert(typeof bool)// boolean  布尔
小数（浮点数） -- 精度，不准确的数！
      任何情况下都不要比较两个浮点数的大小
 */ 
console.log(typeof(0.1+0.2));     // 0.30000000000000004 
NaN 一个不是数字的数值类型
   1. 应该返回一个数字结果，但是返回发不了，此时返回NaN

   特点：
      a. NaN与任何一个数进行运算返回的结果都是NaN
      b. NaN不与任何一个数相等
// alert(Number);//function Number() { [native code] }

var max =Number.MAX_VALUE;  //1.7976931348623157e+308
// alert(max)
alert(Number.MIN_VALUE)//5e-324
alert(Number.MIN_VALUE>0.1) //false
alert(3**2)
alert(Number.MAX_VALUE**2) //Infinity
// 字符串string
var str = '有一天我去杨思涵的家里，看到他老婆满身大汉！';
console.log(typeof str);      // string

// 对象 object
var obj = new Object();
// 属性
obj.name = '蜘蛛侠';
obj.tusi = function () {
   console.log('我可以做吐司面包...');
}
console.log(typeof obj);   // object
console.log(obj); //[object Object]

```

> ++ 符号优先级比=要高，所以先运算a++表达式，a++表达式运行时有规律的！
>  ++在后，先执行表达式的运算，再执行自身的+1
>  ++在前，先执行自身+1，再执行表达式的运算
>
> -- 执行规律：
>    --在前，先执行自减操作 自身-1，再参与表达式的运算--a
>    --在后，先参与表达式的运算，再执行自身-1

|      | 值（++ --在后面不变）                                        | a的自身变化（都会加或减） |
| :--- | :----------------------------------------------------------- | :------------------------ |
| a++  | 3（除了这个值不变）<br />var b=1;a = b++; a= a; console.log(a) ;a=1 | 4累加 自身加一            |
| ++a  | 4                                                            | 4                         |
| a--  | 3（除了这个值不变）                                          | 2 累减自身减一            |
| --a  | 2                                                            | 2                         |
|      | a++  = > a = a+1  牛皮                                       |                           |

```
        
运算符的优先级： ++ > - > =
var a = 3;

   var c = ++a - a++
表达式的值： 4  - 4 = 0
a自身的值：  4    5

var c = a++ + ++a; 
    表达式的值：   3 +  5 = 8
    a自身的值：    4   5   5
------------------------------
运算符的优先级： -- > - > =
  
      var c = a-- - --a
    表达式的值：3  - 1 = 2
    a自身的值： 2   1
    
      运算符的优先级：++ > -- > - > =
      var c = a++ - --a
    表达式的值： 3 -  3 = 0
    a自身的值：   4    3
    
    
    a = 2;
    alert(1+ ++a) //4
```



```js
   var a = 3;
        var c = a++;

        console.log(a);	// 4
        console.log(c);	// 3

        var a = 3;
        var c = ++a;
        console.log(a);	// 4
        console.log(c);	// 4


        var a = 3;
        var c = a--;

        console.log(a);	// 2
        console.log(c);	// 3

        var a = 3;
        var c = --a;
        console.log(a);	// 2
        console.log(c);	// 2

			var a=3 ;
    var aa =  a-- + a++  - --a + a--  //5
    //alert(b)
        // 值    3  + 2     - 2 +2  =5
        // 自身 2 3   2 1
    alert(aa)
    var a= 3;
    alert(a-- + a++  - --a + a-- +'haole 有氧的 ')  //5
```









**减法**



**加法规律：**

查看类型

alert提示信号

alter改变







**变量的类型：**

```
	显式变量类型 -- typeof函数返回的变量类型为标准
​		
​			Boolean	布尔类型 ；String	字符串类型	；Object	对象类型
​			
​			FunctIon函数类型
​		
​			Undefined 未定义

​			Number	数值类型
```

```
		简短记忆缩写：bsofun(be so fun 如此有趣)
```





```
function makebe() {
    alert("FDSDFDSFDS")

}
alert(makebe)
alert(makebe()) //undefined
// console.log(makebe())
//FDSDFDSFDS 函数调用
//未定义 是 console出来的
```





parseInt() 将其他类型的变量尝试转为数值类型的整数
			1. 数值类型：
				整数 原样输出
				小数 去除小数的位数，保留整数
			2. 布尔值类型全部转为NaN
			3. 字符串类型
				首字母是否是数值类型：
					不是，直接转为NaN
					是，只识别对应有效的整数
			4. undefined 转为NaN





parseFloat() 尝试将其他类型的变量转为数值类型的小数
		1. 数值类型直接原样输出
		2. 布尔值类型全部转为NaN
		3. 字符串类型
			首字符是否为数字
				是，进行识别为有效的小数
				不是，直接转为NaN
		4. 未定义类型转为NaN类型









其他类型变量转为布尔值为假的情况：
			1. 布尔值类型的假
			2. 数值类型
				0/0.0/NaN
			3. 未定义类型 undefined
			4. 字符串类型的 空字符串 ''









**js 用var 和不用var的区别**

```
(1).在函数作用域内 加var定义的变量是局部变量，不加var定义的就成了全局变量。

(2).在全局作用域下，使用var定义的变量不可以delete,没有var定义的变量可以delete.也就说明隐含全局变量严格来说不是真正的变量，而是全局对象的属性，因为属性可以通过delete删除，而变量不可以。

(3).使用var 定义变量还会提升变量声明

等不等==；===；

==和===的区别："==" 只要求值相等; "===" 要求值和类型都相等


```







**逻辑运算符**

：最终返回的结果，一般来说都是布尔值	
	 

```
	逻辑或 ||
	逻辑与 &&
		逻辑与左右两侧都有表达式，当左右两侧都为布尔值true，最终返回true
	逻辑非 !
	
	逻辑与：
​				当左右两侧为布尔值表达式时，执行逻辑判断，最终返回布尔值
​				当左右两侧不是布尔值表达式时，
​					当左侧为真，返回右侧数据
​					当左侧为假, 返回左侧数据
​	逻辑或：
​				当左右两侧表达式为布尔值表达式时，执行逻辑判断，返回布尔值
​				当左右两侧不是布尔值表达式:
​					当左侧为真，返回左侧的值；
​					当左侧为假，返回右侧的值
```

​			

**运算符划分**

```
运算符划分：
			作用：算术、比较、赋值、逻辑判断、连接
			参与运算的变量数量：
				一元运算符：参与运算的变量有一个
					a++ a-- !a
				二元运算符: 参与运算的变量要有两个
					+ - / * % += ...
				三元运算符(三目运算符)：
					表达式?真区间:假区间
					执行规则：表达式为真，走真区间，否则走假区间
					真的是前面，假的走后面
```



​			



**ajax**  

不太会用



1. 实现ajax相关的效果时,一定要讲firebug(web调试工具)打开.(F12)

   请求中 -> 响应  是服务器返回的结果.

2. readyState是一个成员属性, 用来表示对象的状态.
   状态有5种,  0,1,2,3,4

   0   请求未初始化
   1   建立了链接
   2   服务器接收到了请求
   3   服务器正在处理中
   4   处理完毕, 数据已经返回给客户端

3. `status`是一个成员属性, 用来表示服务器的响应状态.
   200   ok
   404   not found
   403   forbidden

4. `responseText` 是一个成员属性, 用来存储服务器返回的数据的.

5. 在实现ajax效果的时候, 有些情况是不需要刷新客户端页面的. 就是没有更改客户端代码, 只是改了服务器端代码情况. 

6. `x.setRequestHeader('content-type','application/x-www-form-urlencoded');` 发送post参数的时候,一定要加.

7. 建议大家在firebug的网络控制台查看ajax请求.(XHR是筛选功能).

8. 表示状态的时候 , 0为成功, 非0数字代表失败.

9. json_encode是一个函数, 能够将数组转成字符串, 而且字符串的形式是json形式. (json 形式其实跟js的对象的形式是一样的);

10. 针对服务器返回数组形式的数据,

    - 服务器端要使用`json_encode`转化数据
    - 客户端要使用`eval`函数转变,转成合法的js数据

11. ajax请求对象,就好比是一个微型的http客户端.

12. 同源策略: 当前页面的url和要请求的远程url, 两者的协议, 端口和域名必须要保持一致.

    ajax发送前提: 同源策略.

13. 服务器的错误信息其实也是html代码.

14. firebug网路控制台的请求的`响应` 是错误的分水岭. 
    如果响应数据是ok的 , 服务器就是ok的, 错误肯定是在客户端
    如果响应数据是不对的, 那么服务器一定是有问题的.





**jQuery**

•jquery是一个免费,开源的javascript库;是一个工具可以帮我们做一些事情。

https://code.jquery.com/jquery-3.4.1.js

```
cdn第三方的
https://docs.microsoft.com/en-us/aspnet/ajax/cdn/overview#jQuery_Releases_on_the_CDN_0
<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.js">
百度用的jQuery
https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/static/protocol/https/jquery/jquery-1.10.2.min_65682a2.js
```



ctrl+s保存

1. jquery其实是一个独立的js文件.

2. 下载软件的时候,尽量到官网下载.

3. 善于积累,发现并解决慢的情况.

4. 动静分离,可以提高网站的访问速度.  一个是本地服务器 一个是第三方服务器

5. eq  equal 等于

6. lt  `less than` 小于

7. gt  `greater than` 大于

8. 获取元素的方式并非只有一种.

9. 获取样式的时候,必须要将样式名写全才行.

10. `<span class="a b"></span>` 代表当前元素有两个类名, jquery中可以使用addClass添加多个类名.

11. 如果发送异步的ajax,建议大家使用 `$.get`  `$.post`, 如果发送同步请求只能使用 `$.ajax`.

12. 跨域 跨的是`域名`.

13. link的href属性, script的src属性, img标签 src属性, 在设置url的时候, 跟url的后缀关系不大. 

    其实这些属性的功能,主要是向服务器发送一次http请求, 获取相应的资源.

14. 搭建虚拟主机的流程

    - 修改http.conf 打开虚拟主机子配置文件. (去掉前面的#) 

    - 修改 虚拟主机配置文件  `httpd-vhosts.conf`

      ```
      <VirtualHost *:80>
      	ServerName server.com
      	DocumentRoot D:\wamp64\www\lesson\012
      	<Directory  "D:\wamp64\www\lesson\012">
      		Options +Indexes +Includes +FollowSymLinks +MultiViews
      		AllowOverride All
      		Require local
      	</Directory>
      </VirtualHost>
      ```

    - 重启wampserver(apache  nginx);

    - 修改hosts文件.

15. 检测域名是否解析成功
    `ping  server.com`

16. 跨域的原理  script标签本身具有跨域功能,  所以服务器返回结果的时候, 形式是`函数调用的形式`, 参数是服务器要返回的数据 eg:  `callback(json_encode($data))`,  此时客户端一定要有一个事先声明好的函数, 名字要跟服务器返回的名字一致 eg: `function callback(data) {...}`

17. 客户端 eg:

    ```
    $.getJSON('http://server.com/server.php?callback=?', {a:100,b:200}, function(data){
    	console.log(data);
    });
    ```

    服务器端 eg:

    ```
    $str = json_encode(['name'=>'xiaobai','age'=>20]);
    $func = $_GET['callback'];
    echo "$func($str)";
    ```

18. 一般都是讲jquery代码放置在方法中

    ```
    $(document).ready(function(){...})
    
    $(function(){...})
    ```









## Js学习(h5)

**1JavaScript介绍和基本类型**

认识什么是JS
    	JS是JavaScript的简称
    	JavaScript是什么？

```
	作用区分：
		HTML:	呈现网页的内容			-- 定义一个人(有鼻子有眼)
		CSS:	用于设置网页的样式		-- 进行化妆
		JavaScript：设置页面特效		-- 你想飞，你想上天

	JS的作用：
		1. 用于校验用户输入的表单数据
		2. 用于与用户进行交互式体验
		3. Ajax 异步加载技术
		4. 实现瀑布流、无刷新加载数据

2. 如何在HTML中使用JS

3. JS的内容：
	JS：
		客户端浏览器的JS
		1. ECMAScript的核心语法结构(如何使用JS、如何定义JS的变量)
		2. 包含DOM对象
		3. 包含BOM对象
```



**2javaScript运算符**

运算符
	变量 -- 是存储值的容器
	将变量进行相关的数学运算、逻辑运算等其他运算的符号

运算符的种类：

```
	算术运算符：
​		+ - * /
​	赋值运算符：
​		=
​	比较运算符：
​		> < 
​	连接运算符：
​		+
​	逻辑运算符：
​		逻辑与 && ||
​	位运算符：
​		& | >> << 


```

**3流程控制**

```
在任何一门语言中：变量、运算符、流程控制
	变量：存储值，用于计算
	运算符：算术运算、逻辑运算...
	流程控制：
		流程：如何走
		控制：根据条件进行控制

JS三大流程控制结构：
	顺序结构：
		指程序自上而下依次执行

	分支结构：
		根据一定的条件，有不同的分支

	循环结构：
		根据一定的条件，循环往复的做某一件事情
```

​		



**分支结构**

```
			单分支 if
				格式： 
					if (表达式) {
						流程体
					}
				规则：表达式为真，执行流程体

			双分支 if ... else
				格式：
					if (表达式) {
						// 真流程体
					} else {
						// 假流程体
					}

				规则：表达式为真执行真流程，否则执行假流程

			多分支
				if else if
				switch // 具体的就用这个呗，不是范围

```



**循环结构**

```
			固定结构+执行规则
			while循环
				while (条件表达式) {
					// 循环体
				}

				执行规则：
					当表达式为真，执行循环体；
					循环体执行完毕，会自动再次判断条件表达式
					满足条件，再次执行循环体
					不满足条件，跳出循环

			do...while循环
				do {
					// 循环体
				} while(条件表达式) 
				执行规则：
					先执行循环体，再次判断条件表达式
					满足条件，继续执行循环体
					不满足结束循环
			for 循环
```





循环练习题：

```
01 02 03 04 05 06 07 08 09 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30
31 32 33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48 49 50
```



**4JavaScript函数**

函数：
	概念：
		函数是一段完成指定任务的已命名代码块

```
作用：
	将重复的功能进行封装，进行独立，在需要的位置进行复用
	一次声明，多次调用
	便于后期维护和更新
```

​	
应用场景





```
函数的组成：函数名 + 函数体

	函数的结构：
		function 函数名 () {
			// 函数体
		}

	函数的调用：
		函数名()

	函数名的命名规范：和变量的命名规范是一致！
		1. 首字符必须是字母、下划线或者是$
		2. 后跟任意长度的数字、字母、下划线、$
		3. 严格区分大小写
		4. 不能使用系统的关键字和保留字
		5. 命名尽量有意义
		6. 推荐使用驼峰命名法
```

​	

**按照函数格式(形式)的不同，进行划分：**

```js
1. 有参数的函数、无参数的函数
2. 匿名函数、回调函数、立即执行函数
3. 闭包函数、递归函数

设置函数参数的默认值：
1. 直接在函数定义的位置的小括号中进行赋值
2. 低版本默认值的处理
在函数内部判断该参数是否有默认值，如果没有，赋值初始值



1. 使用function关键字定义函数 -- 具有优先级，优先将function关键字定义的函数优先执行
function table() {
        document.write('<table border="1" width="666"' +
            'height = "300" cellpadding="3" cellspacing="0" align=" center">');
    }
    table();
2. 使用函数表达式的形式定义函数  将匿名函数赋值给变量
var memeda = function () {
        document.write('Iyutet');
    }
    console.log(typeof memeda);    // function
    document.write(memeda())
3. 使用 new Function 构造函数定义函数 new Function() 调用中最末尾的参数是函数体，其他前面的都是参数
var hehe = new Function('uname','alert("Hello,"+uname)');
    document.write(typeof (hehe))
    hehe('np')
    
    函数一旦声明，允许任意调用(在任意的位置调用函数 -- 函数定义前、函数定义后、函数的内部)
			适用于function关键字定义的函数
			使用函数表达式、new Function构造函数定义的函数，不能在函数定义前调用
```

局部作用域：函数的内部
		全局作用域：函数的外部

```
	局部变量：
		在函数的内部使用var关键字定义的变量

	全局变量：
		在函数的外部使用var关键字定义的变量

	特点：
		1. 局部变量是无法直接影响全局变量的
		2. 在局部作用域中可以使用全局作用域的变量
```

作用域链：
			函数内部变量在进行查询时，遵守的规则：
				1. 首先从函数自身所在的作用域进行查找
				2. 如果没有，向父级或者是先辈作用域进行查找
				3. 如果没有，最终的值就是undefined

```js
function ss() {
    var money = 0;
    return money;
    // 将money的值返回到函数的外部，返回到函数调用的位置
}

document.write(ss()) //0
```

```
函数执行规律：
    主程序遇到函数，进入到函数的内部进行执行，执行完毕，将返回值返回到函数调用的位置，继续向下执行
```





```
head是头部，body是整个页面的显示部分。
 
在HTML body部分中的JavaScripts会在页面加载的时候被执行。
在HTML head部分中的JavaScripts会在被调用的时候才执行。
<html>
<head>
<title>这是我的测试</title>
</head>
<body>
my test
</body>
</html>

没有把信息写在head标签中的。 

/**
* 定义实现表格的函数table()
* @param number row 表格的行数
* @param number col 表格的列数
*/

```



```sh
1.五种IO模型包括：

阻塞IO、非阻塞IO、信号驱动IO、IO多路转接、异步IO。其中，前四个被称为同步IO。


阻塞程度：阻塞IO>非阻塞IO>多路转接IO>信号驱动IO>异步IO，效率是由低到高的。



2.虚拟内存-3g[哈哈]—
内存地址是假的，操作系统给的，
地址一样，实际上指向不同


3.流：1.液体移动。 2.像水那样流动不定。


二进制流是指流动的是二进制数字序列，若流中有字符，则用一个字节的二进制ASCII码表示，若是数字，则用一个字节的二进制数表示。

FIFO存储器：
    First Input First Output ：队列，
    先进先出 ； 
    
    
物理内存：
操作系统的虚拟内存。
32位，内存地址只有4g的 个。  
内存放在硬盘中去，切到桌面的时候，就很卡。怎么把内存的东西放在c盘中的，怎么转化的？
初始化内存，如果有变量、就会出现映射表，
不同的进程中，是没办法共享的。


操作系统是另外一个进程，程序也是一个进程，他们没有办法操作数据；
R
q（） 然后 n 结束
Save workspace image? [y/n/c]: 

python
exit（）


node

（To exit, press ^C again or type .exit  
要退出，再次按^C或键入.exit）


 ~ git:(master) ✗ ps
 
 （ PID TTY           TIME CMD
 8358 ttys000    0:00.29 -zsh
 8775 ttys000    0:00.10 node
 8838 ttys001    0:00.13 -zsh）
➜  ~ git:(master) ✗ kill -9 8838
终端进程杀不掉，必须用这个- 9



```





**5对象 Object**

​	一切皆对象！
​	

```
.和[]的区别！！！
console.log(obj[0]); // 如果对象的属性名是数字，必须使用中括号[]的形式进行访问操作
使用[]中括号的形式动态访问对象的属性
```

JS中没有数组类型！JS中数组是以内置对象的形式存在！

```
	数组：
		存储多个值(数组单元)的集合(仓库)
		数组在进行定义时，每一个值(单元)都有一个编号---索引
			JS中数组的索引一定是从0开始的，依次递增，一定是数值类型
```

​		数组元素的遍历：将数组元素一一的进行取出





**foreach**

```
	forEach(function(value, index, arrSelf) {
			value 指向当前元素的值
			index 指向当前元素的索引
			arrSelf 指向当前数组本身
		})
	
	自动将数组单元一一进行取出，放到回调函数中进行操作
```





**JS特效：**

```
		1. 获取元素
		2. 设置元素的操作
```

​	

```
	获取元素的方式：
	1. 使用ID的方式获取元素，返回的是一个具体的对象
		document.getElementById(ID名)
	2. 使用className 类名的方式获取元素，返回类数组对象
		document.getElementsByClassName('类名')
	3. 使用tagName标签名的方式获取元素，返回类数组对象	
		document.getElementsByTagName('标签名') 
	4. 使用name名字的方式获取元素，返回类数组对象
		document.getElementsByName('name值')
```

**轮播图**

```
轮播图特效原理分析：
    1. 页面布局
        容器         定位 相对定位
            图片        定位：绝对定位
            左右箭头   定位：绝对定位
            圆点列表   定位：绝对定位

    2. 轮播图的逻辑运行原理
        轮播图：轮显 ： 轮着显示
            有一张进行显示，其他的都是隐藏的

            约定：li身上有类名active，进行显示
            将active类名移动到指定的元素身上，那么当前的元素就会显示
            将active类名从某个元素身上移除，那么该元素就会隐藏

            圆点列表是跟随图片一起运动的
```

```
  鼠标移入和移出事件：
       第一组
           特点：阻止冒泡
           onmouseenter    鼠标移入
           onmouseleave    鼠标移出

       第二组
           特点：有冒泡
           onmouseover     鼠标移入
           onmouseout     鼠标移出


       冒泡事件：子元素触发某个类型的事件后，该元素的父级以及先辈元素触发同类型的事件

```







```
定义数组的方式：
		1. 使用 new Array() 方式定义数组
		2. 使用字面量 [] 的方式定义数组

```



```
filter() 过滤数组单元,将满足条件的元素进行过滤 

当数组调用filter方法时，自动将数组的每一个单元从左向右依次放入到回调函数中进行判断处理，如果返回true，当前的数组单元会被返回到新数组中，否则无任何操作
```



```
作为筛选的条件，返回true元素会被返回到新数组中
形参value接收的是每一个数组单元的值, 形参index 接收的数组单元的索引
console.log(value, index);

字符串的长度.length
console.log(value.length);
```

```
map() 对数组单元进行回调函数的处理,结果返回到新数组中
    自动将数组的单元从左向右依次放入到回调函数中进行处理
```

```
some() 数组中只要有一个元素满足即可，返回true；否则返回false

    some对数组的单元从左向右依次检测，满足条件即返回true，终止遍历；如果不满足，继续向下执行
```

```
every() 数组中每一个元素都要满足，才会返回true；否则返回false

       every() 将数组单元进行一一的遍历，如果有一个不满足条件，立刻返回false，终止遍历；如果都满足最终才会返回true


reduce() 将数组的元素从左到有依次进行操作
 利用reduce()方法进行数组单元的累加操作
```

```
prevValue   上一个值
nowValue   当前单元的值
index     当前单元的索引
arrSelf    当前数组本身

回调函数的4个参数：
    prevValue 自动获取数组第一个单元的值，回调函数返回的值会自动放到prevValue中

reduce() 方法的第2个参数，设置prevValue的初始值


    reduceRight() 从右侧开始，向左侧一一进行执行

```







```
/**
 * 定义数组去重的函数 arr_unique()
 * @param array arr 要进行数组去重的数组
 * return array newArr 返回的包含所有不重复单元的数组
 */
 
  /**
     * 定义反转数组单元的方法 arr_reverse()
     * @param array arr 要进行数组单元反转的数组
     */
     
     
 /**
     * 自定义统计数组单元个数的函数 arr_count()
     * @param array arr 用于计算数组单元个数的数组
     * return number num 最终的arr的单元个数
     */
```

**6-内置对象**





```
1. JS中的内置对象
2. 数组 Array 
3. 数学对象 Math 
4. 时间对象 Date 
5. 字符串.对象 String 
6. 正则对象 RegExp 
在JS中有.一个特殊类型的数据是定义好的对象，直接拿来使.用
包含有数组、数学对象、时间对象、正则对象、字符串.对象
数组是存储数据的仓库，每个储藏室都有.一个数字编号(索引 index) 
1. 使.用 new Array()定义数组
// 如果定义时只传.入.一个数字，表示声明.一个.长度为该数字的数组，默认值为undefined 
var arr = new Array(10); 
// 常规定义
var users = new Array('.二郎神','孙悟空','猪.八戒'); 
2. 使.用[]定义数组
// 定义数组
var arr = ['.玉皇.大帝','王.母','宋江']; 
JavaScript 第六章
本章主要内容
.一、JS中的内置对象
.二、数组 Array 
概念
定义.方式

// 在数组对象中有属性length 
var len = arr.length; 
1. 每.一个数组单元的值都是有.一个编号对应的，这个编号就称之为索引(index) 
2. 索引的值从0开始
3. 索引的最.大值为数组.长度-1 
1. 使.用循环遍历数组
for(var i=0;i<arr.length;i++>){ 
// i 当前数组的索引 
// arr[i] 就是当前数组的值
} 
2. 使.用forEach()函数遍历数组
arr.forEach(function(value,index,arrSelf){ 
/* 
第.一个参数 value 获取的是当前数组单元的值 
第.二个参数 index 获取的是当前数组单元的索引 
第三个参数 arrSelf 获取的是当前数组本身 
*/ 
}) 
1. Array.isArray() 判断是否是数组
如果是数组，返回true, 
如果不.是数组，返回false 
2. concat() 连接两个或多个数组，返回结果
// 连接值
arr.concat('美.女.'); 
// 连接数组
arr.concat([2,3],[4,3]); 
数组.长度
索引 index 
数组遍历
数组常.用.方法

3. join() 将数组单元的值拼接成字符串.，可以指定连接符
// 默认返回以逗号(,)分割的字符串.
arr.join(',') 
4. reverse() 翻转数组的单元的顺序
arr.reverse() 
5. toString() 将数组转为字符串.，并返回结果
6. pop() 弹出数组最后.一个单元的值，并返回
7. push() 从数组的尾部压.入值，返回新的数组.长度
8. shift() 删除并返回数组第.一个单元的值
9. unshift() 从数组头部压.入值，并返回数组的新.长度
10. slice() 从数组中截取
11. splice() 删除数组，并向数组中添加元素
12. indexOf() 正序查询数组单元的值
如果存在，返回符合查询条件的第.一个结果所在的位置
13. lastIndexOf() 倒序查询数组单元的值
如果存在，返回符合查询条件的第.一个结果所在的位置
如果不.存在，返回-1 
14. map() 映射，原数组单元经回调函数处理.后，返回新的结果

arr.map(function(value){ 
return value*value; 
}) 
// 使.用map()获取对象数组中特定的属性值
var users = [ 
{ 
username : '宋江', 
email : 'songjiang@liangshan.com' 
}, 
{ 
username : '吴.用', 
email : 'zhiduoxing@liangshan.com' 
} 
]
// 获取邮箱地址
users.map(function(user){ 
return user.email; 
}) 
15. filter() 过滤，返回符合条件的结果的值
// 获取数组中的偶数
arr.filter(function(i){ 
// 返回真，对应的值i，就会返回到新数组中 
return i%2==0; 
}) 
16. some() 筛选，只要有.一个符合条件就返回true 
// 只要有.一个男的，就返回真
var users = ['男','.女.','.女.']; 
// 此时res的值为true 
var res = users.some(function(value){ 
if(value == '男'){ 
return true; 
} 
}); 
17. every() 筛选，只有当每.一个单元都符合条件时才整体返回真

// 判断是否全部是男.生
var users = ['男','男','.女.']; 
// 此时res的值为false 
var res = users.every(function(value){ 
if(value == '男'){ 
return true; 
} 
}); 
18. sort() 数组排序
在使.用sort()函数时，需要传.入对应的.比较函数，作为判断条件
19. reduce() 
arr.reduce(function(prevValue,currentValue,currentIndex,arrSelf){ 
}[,initValue]) 
20. reduceRight() 
// 等.比于reduce()，只不.过是从右侧开始计算
1. 计算数组单元的个数
2. 翻转数组
3. 查询出如下格式数组中所有money>1000的.人
// 数组格式
var uses = [ 
{ 
username : '张三', 
money : 10000 
} 
... 
]; 
4. 求数组中的最.大值
5. .自定义数组排序函数--冒泡排序
6. 数组去重
实战案例.

Math.PI 圆周率 PI 
Math.random() 获取[0,1)随机数
Math.round() 四舍五.入
Math.floor() 舍去取整、向下取整
Math.ceil() 向上取整、进.一取整
Math.abs() 返回数值的绝对值
Math.max() 返回所传参数的最.大值
Math.min() 返回所传参数的最.小值
Math.pow(x,y) 返回x的y次幂
Math.sin() 正弦值
Math.cos() 余弦值
Math.tan() 正切值
1. 定义获取随机数的函数
2. 随机点名器.
.用于处理.时间和.日期的对象，默认.自动将当前的.日期时间（时间戳）存储为初始值，该值是从1970年.1 
.月1.日0:0:0到现在的毫秒数
三、数学对象 Math 
数学常量.
数学.方法
实战案例.
四、时间对象 Date 
获取时间戳对象

// 获取当前此刻的时间戳
var now = new Date(); 
// 获取指定时间的时间戳
// 1. 传.入合法的时间字符串.
var time = new Date('2017-1-1 11:0:0'); 
var time = new Date('2017/2/14 10:00:00'); 
// 2. 传.入时间戳(毫秒数)或者是时间戳对象
var time = new Date(0); 
getTime() // 返回1970年.1.月1.日到指定.日期的时间戳，毫秒数
now() // 返回1970年.1.月1.日到此刻的时间戳
getFullYear() // 获取年.份
getMonth() // 获取.月份(实际.月份=getMonth()+1) 
getDate() // 获取.日
getHours() // 获取.小时
getMinutes() // 获取分钟
getSeconds() // 获取秒
getMilliseconds() // 获取毫秒
toString() // 将时间对象转为字符串.格式显示
toLocaleString() // 将时间对象转为本地化的字符串.格式显示
1. .网站时间显示
2. 抢购倒计时
1. 单引号
var str = '床前明.月光'; 
2. 双引号
var str = "疑是地上霜"; 
时间对象常.用.方法
实战案例.
五、字符串.对象 String 
定义字符串.的.方式

3. 反引号
var str = `举头望明.月`; 
4. new String() 
var str = new String('低头思故乡'); 
该.方式获取的字符串.，使.用typeof打印类型为object 
转义符号是.一些特殊的字符字.面量.，.用于表示.非打印字符，或者具有其他特殊.用途的字符 
\n 换.行. 
\t 制表 
\b 退格 
\r 回.车 
\f 进纸 
\\ 反斜线 
\' 转义' 
\" 转义" 
\xnn 以.十六进制代码nn表示.一个字符(其中n为0-F) 
\unnnn 以.十六进制代码nnnn表示的.一个Unicode字符(其中n为0-F) 
在JS中定义的字符串.是不.解析变量.的，所以使.用字符串.连接运算符 + 拼接变量.与字符串.
var str = 'mumuda'; 
console.log(str.length); // 6 
// 类似于数组的取值.方式
str[index] 
转义符号
字符串.连接变量.
字符串..长度
字符串.取值
字符串.常.用.方法

charAt() // 返回指定索引位置的字符
charCodeAt() // 返回指定字符的unicode值
concat() // 拼接两个或多个字符串.
indexOf() // 正序查找 
如果存在，返回第.一个符合条件的数据的索引 
如果不.存在，返回-1 
lastIndexOf() // 倒序查找 
如果存在，返回第.一个符合条件的数据的索引 
如果不.存在，返回-1 
trim() // 去除.首尾空.白字符
toUpperCase() // 全部转为.大写
toLowerCase() // 全部转为.小写
slice() // 截取字符串.
split() // 使.用指定的分割符分割字符串.
match() // 使.用正则表达式进.行.匹配，并返回包含结果的数组
repeat() // 字符串.重复拼接
replace() // 替换
search() // 查询
substr() // 截取
substring() // 截取
1. 测.一测你是王者荣耀的谁
概念：正则表达式是.一种描述.文本的特定模式(使.用.一些特定的符号) 
作.用：执.行.字符串.的查找匹配以及替换等操作
1. 使.用new RegExp()构造函数
var pattern = new RegExp(表达式,模式); 
2. 使.用字.面量.//定义正则表达式
var pattern = /表达式/模式; 
实战案例.
六、正则对象 RegExp 
概念和作.用
定义正则表达式的.方式
正则表达式的组成部分

正则表达式由原.子、元字符和模式修正符共同组成
原.子：描述字符
元字符：修饰描述原.子的数量.、位置等信息
模式修正符：描述是否要进.行.全局匹配、多.行.匹配、是否忽略..大.小写等
1. 普通的字符
a-z A-Z 0-9 -_等
2. .非打印字符
\n 换.行.符
\r 回.车符
\f 换.页符
\s 匹配任何空.白字符
\S 匹配任何.非空.白符
\t 制表符
\w 匹配字.母、下划线、数字
\W 匹配除了. 字.母、下划线、数字以外的字符
\d 匹配0-9的数字
\D 匹配除了.0-9数字以外的任意.一个字符
3. 特殊的转义转义字符(转义元字符) 
转义具有特殊意义的 . * ? ^ $等符号
.用于描述原.子所在位置、数量.、模式单元等信息的符号
描述数量.
* 匹配0个、1个或多个
? 匹配0个或1个
+ 匹配1个或多个
{n} n为.非负整数，匹配恰好n次
{n,} n为.非负整数，匹配.至少n次
{m,n} m,n为.非负整数，匹配出现.至少m次，最多n次
描述位置
原.子
元字符

^ 表示开始位置
$ 表示结束位置
\b 表示单词边界位置
\B 表示.非单词边界位置
特殊元字符
. 匹配换.行.符\n以外的任意.一个字符
[] 原.子列.表，匹配列.表中的任意.一个
[^] .非原.子列.表，匹配除了.列.表中字符的任意.一个
| 或者
\un n是4位由16进制数字，.用于表示.一个unicode字符
模式单元
() 匹配模式单元，.小括号内匹配的内容会进.行.存储
(?:) 匹配模式单元，.小括号匹配的内容不.会进.行.存储
\n 表示模式单元的引.用
g 全局匹配
i 忽略..大.小写
m 表示多.行.匹配
贪婪模式： 
+*元字符在进.行.模式匹配时，尽可能获取最多的可能
.非贪婪模式
使.用特定的.方式取消贪婪模式
.*? 取消*的贪婪模式
.+? 取消+的贪婪模式
正则.方法
模式修正符
贪婪模式和.非贪婪模式
正则表达式.方法

test() 检测是否能匹配结果 
存在，返回true 
不.存在，返回false 
exec() 执.行..一次正则表达式匹配 
存在，返回包含结果信息的数组 
不.存在，返回null 
字符串..方法
search() 
match() 
split() 
replace() 
1. 邮箱
/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/ 
/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.{1,2}[a-z]+)+$/ 
2. Unicode编码中的汉字范围
\u4E00-\u9FA5 
3. IP地址
/((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/ 
/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01] 
?[0-9][0-9]?)$/ 
4. HTML标签
/^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$/ 
1. .用户注册信息验证
2. 字符串.表情替换为表情图.片
3. 数据查询获取(图.片地址、.文章内容等) 
常.用正则表达式
实战案例.


```





**7.7JavaScript获取方式**

内置对象

​	Math 数学对象
​	Date 时间对象

```
变量在内存中的存储方式：
		基本类型值：
			内存中存储的是对应的值
			操作的是具体的值
			
			包含的类型：undefined null number boolean string
		引用类型值：
			内存中存储的是地址
			操作的是地址，实际存储的值是没有改变
			包含的类型：object
```





```
15位9是3
14位9是2
因为他最多小数位是17？

var a = 2.499999999999999999;
var a = 2.399999999999999999;
var newA = Math.round(a);
console.log(newA+'cnm');

弧度2π 和 度360 ===> 2π = 360
        Math.sin() 求正弦值,需要的是弧度
        Math.cos() 求余弦值，需要的是弧度
        90 * 2 * Math.PI / 360
        var value = Math.sin(30 * Math.PI / 180);			// 趋向于 1/2
        
通过目前学习的这些函数，定义获取m,n之间随机整数的函数 rand()
            rand(m, n)
            rand(1, 3) 返回1-3之间的随机整数 1 2 3
            rand(0, 5) 返回0-5之间的随机整数 0 1 2 3 4 5
```

**rand()**

```
/**
	 * 定义获取m,n之间的随机整数 rand()
	 * @param number m 表示随机数的起始值
	 * @param number n 表示随机数的结束值
	 * return number num 最终获取的随机数
	 */
	 
	 
	 
	 m,n之间的值。
	  function rand(m,n){
        var num = Math.floor(Math.random()*(n-m+1))+m
        return num
    }
    
     var num = rand(4,5);
    console.log(num)
    
```

```
Date 时间对象
		存储的是和时间相关的信息
		计时：
			从1970年1月1日0时0分0秒开存储获取的
			0时区为参考点 -- 本初子午线
			
			获取时间对象，返回的是一个时间戳对象，返回的是从1970年1月1日0时0分0秒到现在此刻的毫秒数
```

```
时间戳：返回1970年1月1日0时0分0秒到此刻的毫秒数
		new Date() 获取的此刻的时间戳对象
		
		获取指定时间的时间对象的方式：
			1. 传入时间戳
			2. 传入合法的、可识别的时间格式字符串
			3. 按照年月日时分秒毫秒的顺序传入参数，定义指定的时间，注意：月份会自动+1
		
    
    var now =new Date()
    console.log(now.toLocaleString())			获取1970年1月1
			1970/1/1 上午8:00:00
			
			
var time = new Date('2019/11/11 11:11:11')
    console.log(time.toLocaleString())
    var time = new Date(2019,11,22,11,11,11,999)				//传入的月份是会自动+1
    console.log(time.toLocaleString())
    // 2019/11/11 上午11:11:11
    // 2019/12/22 上午11:11:11
```





```
定义获取当前时间字符串的函数 setTime()


   /**
     *  定义补充前导零的函数 fillZero()
     *  @param number i 需要判断是否要进行补充前导的变量
     *  return number i 返回最终处理后的结果
     */
```

**8.字符串**

​	

```
JS中基本变量类型的一种
声明方式、常用的属性和方法

	字符串定义方式：
			1. 使用单引号定义字符串
			2. 使用双引号定义字符串
			3. 使用实例化构造函数定义字符串对象
			4. 使用反引号定义字符串，允许换行存在
```







```js
var str = `菇凉多少钱\$\{\}，

${money}块钱/晚`;
	console.log(str);
	
//	菇凉多少钱${}， 
	
	1000块钱/晚
```

特殊转义符号：
			\n 		换行符
			\r 		回车符
			\t		制表符

```
计算机只识别二进制，字符如何用二进制进行表示：	 	
		计算机电子协会约定：如何表示字符 -- ASCII 256个
		每一个国家都有自己的符号 -- 中国 GBK GB2312
		当符号不能够被识别时，就会乱码！

		W3C组织约定一个叫做万国码 Unicode 字符
```



 使用\unnnn 4位十六进制表示Unicode字符

```
// 中文在Unicode字符中的表示范围：
var str = '\u4e00';	// 中文的起始位置 一
var str = '\u9fa5'; // 中文的结束位置  龥

    console.log('\u6211'); //我 
```







```
viewport 视图窗口
		width = device-width 设置页面的宽度为设备的宽度
		initial-scale 页面初始化的缩放比例
		maximum-scale 页面允许的最大缩放比例
		minimum-scale 页面允许的最小缩放比例
		user-scalable 页面是否允许缩放
			no/0 表示禁止用户缩放页面
			yes/1 表示允许用户缩放页面
移动端的页面：
		视图viewport
		
		默认情况下，当一个PC端的页面在移动端打开时，会自动进行缩放
			PC端 默认视口宽度为980px  移动端iphone 6 实际宽度为375px 浏览器为了保证将页面的数据都进行显示 -- 页面缩小

		为了解决上述的问题：设置视图窗口，设置页面的宽度、高度根据设备实际的宽度、高度
```

```

测一测、算一算案例：
        界面：
            提供一个供用户输入名字的位置

        功能：
            根据用户输入的名字，结合一定的算法(随机数)，得出结果
            用户输入的相同名字，得出的结果要保持一致！增大可信度！

    移动端的页面：
        视图viewport

        默认情况下，当一个PC端的页面在移动端打开时，会自动进行缩放
            PC端 默认视口宽度为980px  移动端iphone 6 实际宽度为375px 浏览器为了保证将页面的数据都进行显示 -- 页面缩小

        为了解决上述的问题：设置视图窗口，设置页面的宽度、高度根据设备实际的宽度、高度
```



**9正则表达**

正则对象 RegExp

正则表达式：
	由一些特殊的特定字符以特定的形式，组合在一起，能够进行字符串的描述、规则的验证、替换、查找操作

应用场景：
	1. 用户数据的格式验证
	2. 爬虫 -- 数据匹配格式
	3. 网站中进行敏感词汇的替换

```
正则表达式中：
		原子 表示你想要匹配的字符
		元字符 用于描述位置、数量等信息
		模式修正符 区分大小写、是否全局匹配等
```

​			
​	元字符：修饰、描述原子的位置、数量等信息
​		*/
​	
​		// 匹配字符串 -- aa 更多的a数量: 指定个数3个、至少3个、最多3个
​		/*
​			{} 描述原子的数量
​				{m} 	描述其前原子恰好出现m次
​				{m,}	描述其前原子至少出现m次
​				{m,n} 	描述其前原子至少出现m次，最多n次





```
贪婪模式：
			.+或者是.* 获取最多的符合条件的数据

		拒绝贪婪模式：
			.+?或者.*?拒绝贪婪模式


    // 想使用模式单元，但是不想储存的结果 (?:)表示当前的模式单元不进行存储

```

模式修正：
			g 	表示的全局匹配
			i 	表示的忽略大小写
			m 	表示将包含\n换行符在内的字符，视为多行





```
常见域名：
				.com
				.com.cn
				.net
				.edu
				.cn
				var emailReg = /^[a-z0-9-_]+?@[0-9a-z-]+?\.[a-z.]+?$/i
				
				
				
				读正则表达式
			1. 如果能够没有就不给！
			2. 先整体再局部

			/((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/
			匹配的结果：
				200.200.200.250
				0.0.0.0
```





**a事件 event**

​	概念：用户与页面的元素发送交互性行为

```
事件具有三要素：
	事件源：
		触发事件的元素

	事件类型
		事件的类型：
			鼠标的移入、移出
			鼠标的单击
			...

	事件处理句柄(handle 处理的方法或者函数)
		针对当前的时间进行什么样的操作

```









```
鼠标事件：
			单击事件o nclick
			双击事件
			右键事件
			鼠标移入事件
			鼠标移出事件
			鼠标移动事件
			鼠标按下事件
			鼠标抬起事件

	// 单击事件
	red.onclick = function () {
		console.log('现在是单击事件...');
	}

	// 双击事件
	red.ondblclick = function () {
	}

	// 右键事件
	red.oncontextmenu = function () {
	}

	// 鼠标移入事件
	red.onmouseover = function () {
	}

	// 鼠标移出
	red.onmouseout = function () {
	}

	// 鼠标移动事件
	red.onmousemove = function () {
	}

	// 鼠标按下
	red.onmousedown = function () {
	}

	// 鼠标抬起
	red.onmouseup = function () {
	}

键盘事件：
    onkeydown  按下
    onkeyup    抬起
    onkeypress 按下
```









## JavaScript25题

```
写在前面
出题: 邹义良 2019-08-08
不定项选择题，0个或多个，如果没有正确答案，填E

```

1. 以下说法正确的是________。

   ```none
   A. js是跨平台、面向对象的动态编程语言 
   B. js是一种具有函数优先的解释型编程语言   c语言可以传来传去的
   C. js是基于原型、多范式的编程语言       
   不是基于面向对象的，是原型链的继承考核。函数式执行-面向对象式的编程
   D. js的核心语言叫ECMAScript
   es5 es6  ecsa这个组织定了这个标准。
   
   
   abcd 学习前端框架
   ```

2. 以下说法正确的是________。

   ```none
   A. js能运行在浏览器中
   B. js能运行在服务端
   C. js能绘制出动态图像
   D. js具有基于事件循环的并发模型
   
   abcd
   
   nodejs  
   画布-canvas
   ```

3. 下面代码运行结果________。

   ```none
   var userName = "jack"
   console.log(username)
   
   A. 输出:jack
   B. 报错:缺少分号
   C. 报错: username is not defined
   D. 报错: console.log is not a function
   
   
   c
   知识点。
   职业敏感性。--name
   js的class不区分大小写。
   
   
   ```

4. 下面代码运行结果________。

   ```none
   if(true){
       var foo = 1
       let bar = 2
   }
   
   console.log(foo)
   console.log(bar)
   
   A. 输出 1 然后报错 bar is not defined
   B. 输出 1 2
   C. 报错 foo is not defined 然后输出 2
   D. 没有输出，只报错 bar is not defined
   
   a
   var是在函数作用域中生效的，
   
   var foo =1 
   fun()[{ var foo =2  }
   let  es6 限制在这个花阔的 里面， var 是可以到里面去的，let访问的到
   
   if也是花阔好{}, 所以访问不到。
   
   ```

5. 下面代码运行结果________。

   ```none
   var a = 1
   var a = 2
   {
       let a = 3
   }
   console.log(a)
   
   A. Identifier 'a' has already been declared
   B. Uncaught SyntaxError: Unexpected identifier
   C. 输出2
   D. 输出3
   
   es6
   自闭和的函数：{}  用let
   就是做成一个作用域，不污染全局空间。
   var a 
   var a.这个不会报错，
   
   let b 
   let b。不会报错，能用代码 ，
   花阔好是语句，不是对象。
   
   ```

6. 下面代码运行结果________。

   ```none
   const PI = 3.14
   function test(){
       var PI = 3.14159
   }
   test()
   console.log(PI)
   
   A. 输出 3.14
   B. 输出 3.14159
   C. Identifier 'PI' has already been declared
   
   var是定义到全局，
   但是在函数里面不会改变。所以选择a
   ```

7. 下面代码运行结果________。

   ```none
   let foo = 1
   const bar = 2
   foo = 3
   bar = 4
   console.log(foo)
   console.log(bar)
   
   A. 输出 3 4
   B. 输出 3 2
   C. 输出 1 2
   D. 报错 Assignment to constant variable
   
   d
   ```

8. 下面代码能正确运行的有________。

   ```none
   A. var 姓名 = "张三";       console.log(姓名)
   B. var $name = "李四";     console.log($name)
   C. var 7niu = "王五";      console.log(7niu)
   D. var user-name = "赵六"; console.log(user-name)
   
   
   尊严之战。
   $ 解块润， 可以单用¥变量,
   js  字母 数字 下划线 $ 还支持 中文 繁体 小日本 法文，  
   这种表情符号，用excel 是存不进去的  
   mysql 都是 uff8m64 字符
   
   不能数字开头
   ab
   ```

9. 下面代码运行结果________。

   ```none
   var foo
   console.log(foo)
   
   A. null   赋值为空
   B. undefined  声明了 但是没赋值；
   C. false
   D. None
   
   
   b
   ```

10. 下面代码运行结果________。

    ```none
    var myvar = "foo"
    
    function test(){
      console.log(myvar)
      var myvar = "bar"   //变量的声明提前，在同一个作用里面就会比输出提前。
    }
    test()
    
    A. undefined
    B. null
    C. foo
    D. bar
    
    
    堆
    栈：从上往下压， 
    同一个作用域就混乱，所以找不到，
    var a = 2
    ==> var a;
    		a = 2
    		
    变量都是先声明，再使用
    
    a
    ```

11. 下面代码在Chrome中运行结果________。

    ```none
    var myvar = "foo";
    
    console.log(myvar)
    console.log(window.myvar)
    console.log(globalThis.myvar)
    
    A. foo undefined undefined
    B. foo null null
    C. foo foo foo
    D. foo 
        window.myvar is not defined 
        globalThis.myvar is not defined 
        
    语言本身是数据类型：变量 循环 math数学对象。7个核心对象
    settimeout console 的宿主 node 浏览器都可以用，mongodb也可以运行js。
    
    alter数组环境中找，window.alter 
    
    window   window.alter 顶层对象，
    var a=1 ,全局对象就是 wondow.a =1  ; 如果 是放在函数中，定义定义的都是局部变量。
    globathis。 是不论什么环境都是顶层对象，
    globa。 顶层对象，放一些无归的，panseInt就在顶层对象中，， 
    myvar
    
    api 小到一个登陆接口，get post ；java中 函数的调用 也是api
    js 可以定义：node  浏览器  手机开发里；浏览器对象模型；提供了环境。
    浏览器中定义了很多东西有多高，浏览器都是大家抄的；
    
    
    
    宿主环境不同
    
    
    
    c
    ```

12. 最新的 ECMAScript 标准定义的数据类型，选出正确的________。abd 

    ```none
    A. boolean、number
    B. null、undefined
    C. int、string
    D. symbol、object
    
    js无int 有number
    剩下都是他的数据类型。
    
    boo t f
    number -1  0 1  0.1 
    3/0是正无穷大Infinity  -3/0 -Infinity
    abc 转不出的东西是NaN 非数值（not a number）
    passInt 是number类型
    bigint 不能和int做运算的；
    js中是比较完备的数字类型
    
    fuction也是对象。
    原始数据类型 是7中。
    对象： boo num null undef string symbol  bigint
    
    
    
    
    symbol符号:成为不相等的，用来做唯一标记的
    const u =symbol() 都是调用不同的东西
    
    对象是默认就是引用的；
    var u = { name :"a"}
    var u2 = u 
    在内存中都是一个，只是两个名字， 存储在堆中；
    go就是结构体，没有对象
    c就是指针
    php $ 就是饮用传递
    数组是拷贝，对象的赋值是用的
    
    abd
    ```

13. 下面代码运行结果________。

    ```none
    var a = 1
    var b = 2
    var c = "3"
    console.log(a+b+c)
    console.log(a+c-b)
    
    A. 6   2
    B. 123 2
    C. 15  11
    D. 33  11 
    
    
    
    
    d
    ```

14. 下面代码运行结果________。

    ```none
    var n = "2"
    switch(n){
        case 1:
            console.log("星期一")
        case 2:
            console.log("星期二")
    }
    
    A. 星期一
    B. 星期二
    C. 星期一 星期二
    D. 什么也不输出
    
    
    js是弱类型，但是也是注意数据类型，类型不统一就是什么也不输出
    d
    ```

15. 下面代码运行结果________。

    ```none
    function test(n){
        try{      
            throw new Error("foo")   //js的反印号解析变量
            console.log(n)
        }catch(e){   
            console.log(e.message)
            return
        }finally{    //无论如何都会执行
            console.log("{$n}")
        }
    }
    
    test("bar");
    
    A. foo {$n}
    B. foo bar
    C. bar foo
    D. bar foo {$n}
    
    
    a
    ```

16. 下面代码运行结果________。

    ```none
    for(var i=0;i<=3;i++){
        if(i==2){
            continue
        }
        console.log(i)
    }
    
    A. 0 1
    B. 0 1 2
    C. 0 1 3
    D. 0 2 3
    
    continue 跳过当前
    break 结束
    return函数返回
    c
    ```

17. 下面代码运行结果________。

    ```none
    var data = ['a','b','c','d']
    for(var i in [1,2,3]){
        console.log(data[i])
    }
    
    A. abc
    B. bcd
    C. 123
    C. 012
    
    for ---in 取 0，1，2 取的索引
    for ----of 取得1，2，3。  php ：for each  python ：for --in
    arr =[ 4,5,4]
    结果一样都是
    
    a
    ```

18. 下面代码运行结果________。

    ```none
    let arr = [3, 5, 7];
    arr.foo = "hello";
    
    for (let i of arr) {
       console.log(i)
    }
    
    A. 0 1 2 foo
    B. 3 5 7
    C. 0 1 2 hello
    D. 3 5 7 hello
    
    
    
    of 换成 of 就是a
    b
    ```

19. 下面代码能正确输出3的是________。

    ```none
    let arr = [3, 5, 7];
    A. console.log(arr.count)
    B. console.log(arr.length)
    C. console.log(len(arr))
    D. console.log(size(arr))
    
    
    b
    a无count
    解块瑞size
    ```

20. 下面代码运行结果________。

    ```none
    let arr = [3, 5, 7];
    A. console.log(arr.count)
    B. console.log(arr.length)
    C. console.log(len(arr))
    D. console.log(size(arr))
    ```

21. 下面代码运行结果________。

    ```none
    var name = 'mary'
    var foo = {
        name:'jack',
        say1: function(){console.log(this.name)}, //是方法
        say2(){console.log(this.name)},  //(){} 就是方法，是等价的
        say3:()=>{console.log(this.name)},  //箭头函数 ，是函数，继承最外层的对象。出现的概率很高。
    }
    
    foo.say1()
    foo.say2()
    foo.say3()
    
    A. jack mary undefined
    B. jack jack jack
    C. jack jack mary
    D. jack jack undefined
    
    
    js set几何 互异 无序 不重复 关注的value值 ，不可以重复的
    		php数组的key 就是一个set集合
    		python
    		并发冲突：全局变量里面， i = 1 1+1=2  1 +1 
        数据库中并发冲突，都会2 ，做100个就是95，并发；如果是set userId就可以解决。
        加锁，还在用，不能读；别并发变成串形化
    
    redis
    
    let
    算法很重要
    
    
    怎么看是不是js es6
    setIncate(function test(){  this })  //函数是对象，7种数据类型，剩下都是对象object
    <==>setT（ ()=>{} ）
    不等价；箭头函数无this ， 自己无this ，如果有就是继承过来的。
    
    
    ajax
    name = jaek
    hi(){
    
    var _this = this  //加这个
    $get（URL，function(res){
    setmeout(fuction{
    
    _this.name =res //z这句不行
    }
    )}
    }
    
    
    ==》指向外层对象的时候，我们用箭头函数，上面就是window
    name = jaek
    hi(){
    $get(url ,res=>)
    
    
    最外层是个大的对象。
    答案：c
    ```

22. 下面代码运行结果________。

    ```none
    var a = "b"
    var user = {
        a,
        [a]:"c",
        "c":"d"
    }
    console.log(user.a)
    console.log(user.b)
    console.log(user.c)
    console.log(user[a])
    console.log(user['a'])
    
    答案：bcdcb
    
    
    
    
    var a = "b"
    var user = {
        a,   		// 前面是keys：value<=>'name'=name<=>name: name <==>name缩写，属性的缩写；方法的缩写，
        [a]:"c",  [a] //<==>求值 ‘b’= 后面的值“c”
        "c":"d"
    }
    //console.log(user['a'])
    console.log(user.a)  //就直接找  a= ['a'] 加引号就是自变量找a
    
    console.log(user.b)
    console.log(user.c)
    console.log(user[a])  //就是调用求出a ，找b的值
    
    A. b c d c
    B. b undefined d b
    C. a undefined d undefined
    D. b c d undefined
    
    
    a
    
    ```

23. 下面代码运行结果________。

    ```none
    const p1 = new Promise(function (resolve, reject) {
        setTimeout(() => resolve("data1"), 2000)   //2s
    })
    
    const p2 = new Promise(function (resolve, reject) {
        setTimeout(() => reject(new Error('fail')), 1000)  //1s
    })
    
    Promise.all([p1, p2]).then(result => {
        console.log(result[0])				//自动对应上
        console.log(result[1])
    }).catch(error => console.log(error.message))
    
    A. data1 fail
    B. fail data1
    C. fail fail
    D. fail
    
    Promise.all会等待1，2都回来执行。自动等。//自动对应上，他的结果。顺序对应。
    任意一个都是执行一次，解决多个异步，多个执行，。Promise.all就是解决这个问题。
    Promise.all可以解决很多场景，都类似
    
    
    
    a文件
    b文件
    a+b文件合并
    
    希望并发执行；ajax
    
    版本一：串形的。
    ajax(url,(res)=>{
    	ajax(url,(res)=>{
    		ajax(url3,(res3)={
    				ok
    			
    		})
    	})
    })
    
    版本二：
    定时器
    首先 返回每个阐述结束
    set	写一个定时器 然后进行循环结束这个定时器，进行 ajax3
    
    版本三：
    
    
    
    d
    
    ```

24. 下面代码能正确将该div的类名改为active的是________。

    ```none
    <div id="foo" class="invalid">
    
    A. document.getElementById('foo').class="active"
    B. document.getElementById('foo').className="active"
    C. document.getElementById('#foo').className="active"
    D. document.getElementById('#foo').class="active"
    
    
    
    
    b
    
    ```

25. 下面代码运行结果________。

    ```none
    var f = (function(i){
        console.log(i)
        i++
        return function(i){
            console.log(i)
        }
    })
    
    f(2)(3)
    
    
    
    
    var f = (function(i){
        console.log(i)
      
    })(1)
    
    
    变形：
    var f = (function(i){
        console.log(i)
        i++
        return function(i){console.log(i) }})
    
    f(2)(3)
    
    
    
    
    两个函数无关系。
    A. 2 2
    B. 2 3
    C. 2 4
    D. 3 4
    
    b
    
    ```









## 参考文档

```
es5和es6的区别
https://my.oschina.net/u/3214926/blog/877908

ES5/ES6 的继承除了写法以外还有什么区别？
https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20

ES6 class		es6类
https://github.com/xiaohesong/TIL/blob/master/front-end/es6/understanding-es6/class.
http://post.pinee.xin/
http://xiaohesong.github.io


ES5/ES6的继承的区别
https://segmentfault.com/a/1190000019971909

javascript声明对象时 带var和不带var的区别
https://www.cnblogs.com/vincent2d/p/4886920.html

JS 基础 —— JavaScript 关键字（keyword）与保留字
https://blog.csdn.net/qq_19865749/article/details/78128894


JavaScript 保留关键字
https://www.runoob.com/js/js-reserved.html


ECMAScript 6 入门 
http://es6.ruanyifeng.com/#docs/symbol

js中map文档
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map


JavaScript 数据类型和数据结构
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures


```







