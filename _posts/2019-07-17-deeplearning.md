---
layout: post
title: "深度学习花书学习笔记deeplearning"
date: 2019-07-17
tag: 机器学习machineLearning
---









## 第二章 线性代数



**标量、向量、矩阵和张量：**

标量：单独的数

向量：有序排列的一组数

矩阵：二维数组

张量：多维数组

转置：矩阵操作，对角线镜像

**矩阵和向量相乘：**

矩阵乘法：不满足交换律。

**单位矩阵和逆矩阵：**

单位矩阵：任意矩阵和单位矩阵相乘不变，单位矩阵除对角线为1，其余全为0

逆矩阵： A`-1*A =I     矩阵可逆的条件：方阵且所有列向量线性无关。

**线性相关和生成子空间：**

线性相关：冗余表示，任意一个向量不能由其他向量线性组合称为线性无关。

生成子空间：一组向量所能组成达到的点的集合 

**范数：**

范数：衡量向量大小：$$(\sum |x_i|^p)^\frac{1}{p}$$ 比如 ![l1](https://private.codecogs.com/gif.latex?L%5E%7B%5E%7B%5E%7B1%7D%7D%7D)范数就是各方向绝对值之和。最大范数为向量中的最大值。

向量点积可表示为： $$x^ty$$ = $$ ||x|| *||y||*cos\theta$$





**特殊类型的矩阵和向量：**

对角矩阵：只在对角线有非0值           优势，计算效率高

对称矩阵：转置和自己本身相等的矩阵

单位向量：具有单位范数的向量， 

正交：向量夹角为90度

标准正交：为90度且范数为1

正交矩阵：行列矩阵都为标准正交的方正。$$A^T $$ A= $$AA^T$$ = I，意味着$$A^(-1) =A^T$$，方便求逆。 



**特征分解：**

特征向量：与方阵相乘后相当于缩放自身向量的非零向量。 ![A\nu = \lambda \nu](https://private.codecogs.com/gif.latex?A%5Cnu%20%3D%20%5Clambda%20%5Cnu) 此时![\lambda](https://private.codecogs.com/gif.latex?%5Clambda)为![\nu](https://private.codecogs.com/gif.latex?%5Cnu)对应的特征值。

​                特征向量缩放后，依旧为特征向量。特征值不变。因此通常指考虑单位特征向量。

特征分解：矩阵A有n个线性无关的特征向量。对应特征值组成对角矩阵。矩阵可分解为：

​                   ![A = Vdiag(\lambda )V^{-1}](https://private.codecogs.com/gif.latex?A%20%3D%20Vdiag%28%5Clambda%20%29V%5E%7B-1%7D)

​                  通常特征值矩阵中，对角元素降序排列，构成唯一矩阵。

正定矩阵：所有特征值为正数，半正定矩阵：所有特征值非负。同理负定和半负定。

**奇异值分解：**

奇异值分解：SVD缩写。所有实数矩阵都可以奇异值分解。

​                ![A = U D V^{T}](https://private.codecogs.com/gif.latex?A%20%3D%20U%20D%20V%5E%7BT%7D)

​                 假设A为m*n矩阵，则U是m*m矩阵，D是m*n矩阵，V是n*n矩阵。U和V为正交矩阵，D为对角矩阵,且D不一定为方                       阵。矩阵D中的对角元素为奇异值。U的列向量为左奇异向量，V的列向量为右奇异向量。其中，左奇异向量是![AA^{T}](https://private.codecogs.com/gif.latex?AA%5E%7BT%7D)的                   特征向量，右奇异向量是![A^{T}A](https://private.codecogs.com/gif.latex?A%5E%7BT%7DA)的特征向量。 主要作用就是拓展对非方阵的求逆。

 

什么是奇异值？特征值分解和奇异值分解的使用场景和区别？

 

**Moore-Penrose伪逆：** 

​              解决非方阵的求逆：![A^{+} = VD^{+}U^{T}](https://private.codecogs.com/gif.latex?A%5E%7B&plus;%7D%20%3D%20VD%5E%7B&plus;%7DU%5E%7BT%7D), 其中D+是对角矩阵D，非零元素取倒数再转置？（对角矩阵转置不是一样吗）

**迹运算：**

矩阵对角元素之和。迹运算满足交换律。Tr(A) 表示。

**行列式：**

det(A)，是一个将方阵映射到实数的函数。等于方阵特征值得乘积。其绝对值表示矩阵乘法后空间扩大或缩小比例。1不变，0失去所有体积。

**实例：主成分分析：**

PCA 求出彼此正交的特征值最大的几个特征向量。

 















# 第三章 概率和信息论



**概率分布**

离散型变量对应概率质量函数（PMF）：P。 ~表示遵从分布：x~P(x)

联合概率分布，多个变量的分布。P(x,y)

P的定义域为x所有可能，且P(x)位于0到1之间，且所有P(x)之和为1。

连续型变量对应概率密度函数（PDF）。此时P(x)可以大于1 。

### 边缘概率分布：

知道联合概率分布后求子集的分布。

​    离散型：![P(x = x)) = \sum P(x = x,y= y)](https://private.codecogs.com/gif.latex?P%28x%20%3D%20x%29%29%20%3D%20%5Csum%20P%28x%20%3D%20x%2Cy%3D%20y%29)

​    连续型: ![p(x) = \int p(x,y)dy](https://private.codecogs.com/gif.latex?p%28x%29%20%3D%20%5Cint%20p%28x%2Cy%29dy)

### 条件概率：

主要公式：![P(y = y| x = x) = P(y = y,x=x)/P(x = x)](https://private.codecogs.com/gif.latex?P%28y%20%3D%20y%7C%20x%20%3D%20x%29%20%3D%20P%28y%20%3D%20y%2Cx%3Dx%29/P%28x%20%3D%20x%29)

### 条件概率的链式法则：

联合分布符合条件概率的链式法则。

若变量相互独立，可以表示为因子的乘积形式。

### 期望、方差和协方差：

期望：x由P产生时，f作用于x时，f(x)的平均值。    符合线性约束

​     离散型： ![E_{x~P}[f(x)] = \sum P(x)f(x)](https://private.codecogs.com/gif.latex?E_%7Bx~P%7D%5Bf%28x%29%5D%20%3D%20%5Csum%20P%28x%29f%28x%29)

​     连续型： ![\int p(x)f(x)dx](https://private.codecogs.com/gif.latex?%5Cint%20p%28x%29f%28x%29dx)

方差：反应函数值变化的差异大小：体现算法的稳定性

![Var(f(x)) = E[(f(x)-E[(f(x))])^{2}]](https://private.codecogs.com/gif.latex?Var%28f%28x%29%29%20%3D%20E%5B%28f%28x%29-E%5B%28f%28x%29%29%5D%29%5E%7B2%7D%5D)

方差的平方根为标准差。

加一部分：

何为偏差：预测值和真实值之间的差距

如何计算？：偏差 = 

方差和偏差的各自使用场景：高方差对于过拟合，高偏差对应欠拟合？

bagging可以减少方差，boosting减少偏差。

bagging对应：同样样本的多种若学习的组合

boosting对应：同种学习方式的多轮（每轮样本权重不一样）

协方差：两个变量线性相关性的强度和变量的尺度。

![Cov(f(x),g(x)) = E[(f(x) - E[(f(x)])(g(y) - E[g(y)])]](https://private.codecogs.com/gif.latex?Cov%28f%28x%29%2Cg%28x%29%29%20%3D%20E%5B%28f%28x%29%20-%20E%5B%28f%28x%29%5D%29%28g%28y%29%20-%20E%5Bg%28y%29%5D%29%5D)

两个变量相互独立则协方差为0，协方差不为0则一定相关。

独立性要求更高，除协方差为0，还需排除非线性关系。

协方差矩阵的对角元素为方差。

### 常用概率分布：

均匀分布U，即x∼U(a,b)x∼U(a,b)

伯努利=0-1分布，单个二值随机变量 。

P(x = 1) = ![\phi](https://private.codecogs.com/gif.latex?%5Cphi)

P(x = 0) = 1- ![\phi](https://private.codecogs.com/gif.latex?%5Cphi)

E = ![\phi](https://private.codecogs.com/gif.latex?%5Cphi)

V = ![\phi](https://private.codecogs.com/gif.latex?%5Cphi)(1-![\phi](https://private.codecogs.com/gif.latex?%5Cphi))

范畴分布=多项式分布，多个离散二值随机变量的任意分布 。

以上两个分布主要就是简单。

高斯分布=正态分布：

最常用的分布，主要参数均值![\mu](https://private.codecogs.com/gif.latex?%5Cmu)，方差![\sigma ^{2}](https://private.codecogs.com/gif.latex?%5Csigma%20%5E%7B2%7D)。当均值为0，标准差为1时，称为标准正态分布。

使用精度矩阵替代原有函数，简化运算。

指数分布：在x=0处有边界点的分布。

![p(x;\lambda ) = \lambda 1_{x\geqslant 0}exp(-\lambda x)](https://private.codecogs.com/gif.latex?p%28x%3B%5Clambda%20%29%20%3D%20%5Clambda%201_%7Bx%5Cgeqslant%200%7Dexp%28-%5Clambda%20x%29)

Laplace分布：允许任一点![\mu](https://private.codecogs.com/gif.latex?%5Cmu)设置为峰值。

Dirac分布：广义函数，除了某一点外其余都为0，但是积分为1，作为经验分布的一部分

经验分布：把概率密度1/m赋给m个点，使得在每个点处等分布，而且呈现Dirac分布（不扩散到其他值处）

混合分布：多种分布混合，其值取决于每一个值所对应的分布，比如GMM（高斯混合模型），是任何平滑密度函数的万能近似器 。

后验概率：知道某个之后另一个的概率 P(c|x)

常用函数：

logistic sigmoid函数 : ![\sigma (x) = \frac{1}{1+exp(-x)}](https://private.codecogs.com/gif.latex?%5Csigma%20%28x%29%20%3D%20%5Cfrac%7B1%7D%7B1&plus;exp%28-x%29%7D)

![img](https://img-blog.csdn.net/20180924215042940?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

值域在0到1，适合输出概率，但是会存在梯度饱和，对输入不再敏感。但是也常用于激活函数。

softplus函数：![\varsigma (x) = log(1+exp(x))](https://private.codecogs.com/gif.latex?%5Cvarsigma%20%28x%29%20%3D%20log%281&plus;exp%28x%29%29)

![img](https://img-blog.csdn.net/2018092421543876?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

类似RELU。

### 常用函数的有用性质：

![img](https://img-blog.csdn.net/20180924215526664?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 贝叶斯法则：

![P(x|y) = \frac{P(x)P(y|x)}{P(y)}](https://private.codecogs.com/gif.latex?P%28x%7Cy%29%20%3D%20%5Cfrac%7BP%28x%29P%28y%7Cx%29%7D%7BP%28y%29%7D)。

### 连续型变量的技术细节：

一阶微分矩阵，又称为Jacobian矩阵。

### 信息论：

香农熵：整个概率中不确定性的总量。

K-L散度：相对熵。衡量两种分布之间的差异。

![D_{KL}(P||Q) = E[logP(x)-logQ(x)]](https://private.codecogs.com/gif.latex?D_%7BKL%7D%28P%7C%7CQ%29%20%3D%20E%5BlogP%28x%29-logQ%28x%29%5D)

离散型变量下，KL散度度量Q表示P时，所需要的额外信息量。即KL越大，分布越不一致。Q的分布越不完整也可能。

非负。非对称。生成对抗网络有用，由于其不对称，可能造成。。。。

交叉熵：

![H(P,Q) = H(P) + D_{KL}(P||Q)](https://private.codecogs.com/gif.latex?H%28P%2CQ%29%20%3D%20H%28P%29%20&plus;%20D_%7BKL%7D%28P%7C%7CQ%29)

![H(P,Q) = -E_{x~P}logQ(x)](https://private.codecogs.com/gif.latex?H%28P%2CQ%29%20%3D%20-E_%7Bx~P%7DlogQ%28x%29)

### 结构化概率模型：

可以通过有向图和无向图表示变量间分布的互相影响。











# 第四章 数值计算



### 上溢和下溢：

由于舍入带来的误差，导致参数为0或者无穷大，使得无法运算。这个一般会通过加上一些项使得分母不为0来解决。通常基础库都已经帮我们解决了，自己做的时候要注意。

### 病态条件：

输入的轻微变动导致输出的大幅变换。

### 基于梯度的优化方法：

目标函数=准则

误差函数=代价函数=损失函数

梯度下降：向导数的反方向移动一步来减小f(x)。

驻点：导数为0的点。

鞍点：导数为0但是不是极值。

深度学习通常都找不到最大或最小值，只要能满足要求即可。

梯度：针对多维输入函数，各个变量的偏导数，组成的向量。

二阶导数组成的矩阵：hessian矩阵（实对称矩阵，因为计算顺序可调换 ）

二阶导数可以反映曲率的变化。计算时算子顺序可变。、

牛顿法：相对梯度下降一次次下降，牛顿法直接求出最值。但是hessian矩阵运算较大，一般采用拟牛顿法。

仅使用梯度信息的为一阶优化算法，使用Hessian矩阵的为二阶优化算法。

Lipschitz连续：没有突然很大的变化。微小的输入变化，输出变化也不大。

凸优化：只对凸函数有用，极值就是最值。

### 约束优化：

在定义域中的子集找寻最值。

KKT方法：针对优化约束的通用解决方案，将约束问题转化为无约束问题。SVM中用到了。

​     引入广义lagrange函数：

​     ![L(x,\lambda ,\alpha ) = f(x) + \sum \lambda _{i}g^{(i)}(x) + \sum \alpha _{j}h^{(j)}(x)](https://private.codecogs.com/gif.latex?L%28x%2C%5Clambda%20%2C%5Calpha%20%29%20%3D%20f%28x%29%20&plus;%20%5Csum%20%5Clambda%20_%7Bi%7Dg%5E%7B%28i%29%7D%28x%29%20&plus;%20%5Csum%20%5Calpha%20_%7Bj%7Dh%5E%7B%28j%29%7D%28x%29)

​     其中：![\lambda](https://private.codecogs.com/gif.latex?%5Clambda)和![\alpha](https://private.codecogs.com/gif.latex?%5Calpha)为KKT乘子。原有约束集合S表示为：![S = {\left \{ x|\forall i, g^{(i)}(x) = 0 and \forall j,h^{(j)}(x)\leq 0} \right \}](https://private.codecogs.com/gif.latex?S%20%3D%20%7B%5Cleft%20%5C%7B%20x%7C%5Cforall%20i%2C%20g%5E%7B%28i%29%7D%28x%29%20%3D%200%20and%20%5Cforall%20j%2Ch%5E%7B%28j%29%7D%28x%29%5Cleq%200%7D%20%5Cright%20%5C%7D)

### 实例：线性最小二乘通过多种方式求最值。









# 第五章 机器学习基础



### 学习算法：

主要应用于：

分类：输出对应的类。

输入缺失分类：数据不完整，通过机器学习方式补全，主要用GAN

回归：输出输入对应的值。

转录：转录非结构化数据为离散数据。

机器翻译：序列对序列的转换。

结构化输出、异常检测、合成和采样、去噪等等。

 

性能度量：

准确率表示输出正确结果的样本比率。

错误率表示输出错误样本的样本比率。

。。。填补roc,auc之类如果后面几章没有的话

机器学习算法分类：

主要分为有监督和无监督学习还有强化学习。

有监督学习的样本具有标签。无监督学习无标签，主要用于聚类、去噪等。强化学习也没有标签，只是对行为进行奖惩，相当于设定一个规则，最经典代表alpha go zero,没有任何数据即可完成学习。本书没有强化学习，等笔记写完继续强化学习。

实例：线性回归

均方误差：mse  为 ![\frac{1}{m} \sum (f(x)-y)_{2}^{i}](https://private.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7Bm%7D%20%5Csum%20%28f%28x%29-y%29_%7B2%7D%5E%7Bi%7D)              

f(x) = wx + b，b为偏置。

### 容量、过拟合和欠拟合：

训练误差为在训练集上的误差，泛化误差为在测试集上的误差，我们主要期望得到一个泛化误差小，即泛化能力强的模型。

我们的测试集和训练集期望是独立同分布的。

机器学习遇到的主要问题是欠拟合和过拟合。模型的容量表示模型的能力，能力过强容易过拟合，过弱容易欠拟合。

表示容量：模型的可选函数族。

有效容量：通常不会找到最优函数，只要能符合预期即可，所以有效容量小于表示容量。

奥卡姆剃刀表示同样能解释观测现象的假设中，相对简单的模型更好。

VC维：量化模型容量的参数。二元分类器的容量。西瓜书中有详细解说，后面补充。

贝叶斯误差：从预先知道的分布预测二出现的误差。

非参数模型：最近邻算法。（就是不用训练的意思吗？）

没有免费午餐定理：没有一个无敌的计算机算法。但是目前好像很多算法都期望能够运用于多领域。强人工智能不就是这个意思吗。

正则化：加入对模型复杂度的惩罚机制，即代价函数。正则化定义是指修改学习算法，降低泛化误差而非训练误差。

### 超参数和验证集：

验证集是训练集互斥的一部分，用于挑选超参数。超参数是设置而非训练的。

通常训练集中80%训练参数，20%挑选超参数。

交叉验证：k折交叉验证。分成K分，训练k次，取误差平均。

### 估计、方差和偏差：

点估计：![\hat{\theta}](https://private.codecogs.com/gif.latex?%5Chat%7B%5Ctheta%7D)为![\theta](https://private.codecogs.com/gif.latex?%5Ctheta)的点估计。就是预测的函数呀感觉。。

偏差：![bias(\hat{\theta }) = E(\hat{\theta })-\hat{\theta }](https://private.codecogs.com/gif.latex?bias%28%5Chat%7B%5Ctheta%20%7D%29%20%3D%20E%28%5Chat%7B%5Ctheta%20%7D%29-%5Chat%7B%5Ctheta%20%7D)

偏差为0则无偏估计。有偏无偏主要针对看是对什么的估计，而不是对模型的估计。比如对方差和均值估计。

置信区间：

![img](https://img-blog.csdn.net/20180925165456749?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

增加容量会降低偏差，增加方差。

一致性表示必然收敛。（不知道这个定义有什么用）

### 最大似然估计：

从不同模型中得到特定函数作为适合的估计。

定义为各个参数取最大概率时的累乘。

可以看到所有的似然估计最后都变成对数，主要是为了将累乘变成累加，即方便运算，又可以避免数值下溢。

最大优势是样本数量很大时，可以很好的收敛到参数的真实值。

### 贝叶斯统计：

不同于之前都属于频率派统计。贝叶斯统计主要观察完整样本，而后计算。

数据量较小时使用贝叶斯，很大时计算代价太大。

### 监督学习方法：

logistic sigmoid函数：将线性函数的输出压缩在0到1之间，输出一个概率，称为逻辑回归，但实际上一般用来分类。

常用监督学习方法：

支持向量机：

找到一个可以分离开两类样本的最大分割平面。书中说不支持输出概率，但实际是有变种可以输出概率的。可以搜支持向量回归。然后花书中对支持向量的介绍不够详细，详细原理推荐李航的《统计学习方法》。

支持向量的含义就是离分割平面距离最近的样本。分割平面仅与支持向量有关，与其他样本无关。但是大多情况下样本是无法线性可分的，这时候支持向量机的创新性的引入了核函数，将样本可分。核函数将原本不可分的样本映射到了高维空间变得可分。最常用的核函数就是高斯核，用K表示，标准正态分布的高斯核被称为径向基函数。

K近邻算法：

分类算法，没有训练过程，待测样本直接认为是离其最近的K个样本分类中的众数。当k为1时，退化为最近邻算法，k为样本集大小时，则永远为样本中最多的类。K的选择方法通常是交叉验证法。

主要使用中考虑三点：距离度量方式选择、k值选择、分类决策选择

k近邻一般通过k-d树搜索，这两个k不相关。

弱点：无法判断特征的强弱。

决策树：

决策树根据信息增益、信息增益比和基尼系数分为ID3,C4.5和CART

一般为防止过拟合采用剪枝技术。

### 无监督学习方法：

主要应用降维、稀疏表示、独立表示、聚类。表示学习后面会有专门章节介绍

主成分分析：

### 聚类算法

书中说无法衡量聚类结果的好坏，但是其实是可以的。

衡量是否可以聚类：

霍普金斯距离：![H =\frac{\sum y_{i}}{\sum x_{i}+\sum y_{i}}](https://private.codecogs.com/gif.latex?H%20%3D%5Cfrac%7B%5Csum%20y_%7Bi%7D%7D%7B%5Csum%20x_%7Bi%7D&plus;%5Csum%20y_%7Bi%7D%7D)

其中xi yi代表。。。（记在笔记本上的，不记得出处了，百度没找到。。明天翻翻书）

衡量聚类结果：轮廓系数：![s(v) = \frac{b(v)-a(v)}{max(a,b)}](https://private.codecogs.com/gif.latex?s%28v%29%20%3D%20%5Cfrac%7Bb%28v%29-a%28v%29%7D%7Bmax%28a%2Cb%29%7D)

k-均值聚类：

个人理解，该算法重点在如何选取最初的k个点以及选取K值为多少。

随机选取

这里再介绍几种聚类算法：

。。。

密度聚类：DBSCAN

 

层次聚类：类似哈夫曼树编码方式的聚类，效率较低，不许知道簇数目，对于距离度量方式不敏感。

 

### 随机梯度下降：

就是每次不使用全部样本，仅使用一个小batch的样本量进行运算，提高训练速度。后面会有一个章节专门介绍其优化方式。

 

### 构建机器学习方法：

主要构成由：特定的数据集、代价函数、优化过程和模型

 

### 促使深度学习方法的挑战：

维数灾难：导致运算过于复杂以及样本不足。

局部不变性和平滑正则化：

主要是指我们通常的学习都具有局部不变和平滑的先验，即在小范围内样本变化不会很大。导致当函数较复杂时，我们需要学习的样本很多。才能覆盖所有测试集。

局部核：核函数k(u,v)在u = v时很大，当距离拉大时减小。用于度量测试样本和每个样本的相似性。

流形学习：西瓜书中更加详细，后面补。

 











#  第六章 深度前馈网络



深度前馈网络又称多层感知机、前馈神经网络。即只有从x向y方向的传播，最终输出y。

主要包括输入层、隐藏层和输出层。神经网络的模型可以解决非线性问题。

计算网络的参数通过反向传播；如果每一层隐藏层都只有wx+b的运算，则多层累加变为w1*(w2*(w3*x))+a = W*x +a,失去了非线性能力。故每一层后面会加上一个激活层。

**实例：学习XOR**

单个线性函数无法解决XOR的问题，但是多个线性函数的组合，每个线性函数理解为一个神经元，就可以表示XOR运算。

这里提到了RELU激活函数g(x) = max{0,x}，也叫整流线性单元，是大多前馈神经网络的默认激活函数。主要优势运算简单。后面有专门章节介绍和比较各个激活函数。

**基于梯度的学习：**

代价函数：和其他机器学习使用方式类似。

使用最大似然学习条件分布：

学习条件统计量：

**输出单元：**

主要就是sigmoid 和softmax两种,都存在饱和的问题，前者在输入过大和过小时，后者在有某个预测特别大时。

sigmoid：主要用于二分类，或输出概率。 这边提到softplus:ζ(x)=ln(1+exp(x))

softmax：

![img](https://img-blog.csdn.net/20180928153021920?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

输出每个类可能的概率。多分类以及预测自然语言处理中预测下一句话之类时可以用到。但是如果可能性太多的话，运算过大，可以通过树状结构减少运算。

### 隐藏单元：

隐藏单元主要包括仿射变换 wx+b 和激活函数g(x)，重点研究激活函数：

下面介绍几种常见激活函数：

### ReLU族

ReLU：整流线性单元 g(z0) = max(0,z)，最常用。

优势：计算方便，大于0部分不存在梯度饱和。

计算时通常将仿射变换的b初始设置一个较小的正数，如0.1，这样开始时大多数样本都可以通过。

缺点：无法学习小于0的样本。

 

针对上述缺点出现了很多变种：

LeakReLU:

![img](http://p0.ifengimg.com/pmop/2017/0701/CFC5A1C95A84A6D8CF3FFC1DD30597782AEEAE57_size20_w740_h231.jpeg)

这样可以学习小于0的部分。

PReLU:同LeakReLU，但是a参数是根据数据确定的，而非事先指定

学习方式如下：

![img](https://img-blog.csdn.net/20180928150435880?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

RReLU:

![img](http://p0.ifengimg.com/pmop/2017/0701/B3F2F3EA627EBB55D88C8F8FB36942C56B350A4B_size14_w740_h221.jpeg)

![img](http://p0.ifengimg.com/pmop/2017/0701/C56E5C6FCBB36E70BA5EBC90CBD142BA320B3DF6_size19_w740_h217.jpeg)

RReLU:训练时是波动的，测试时就固定下来了。

ELU:

SReLU:

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180122221658209?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA5MDkzNzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

激活后样本均值为0，方差为1，相当于自归一化，效果比batchnormlize好。

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20180122215532377?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjA5MDkzNzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

参考别人的一幅图再。

补充一个softplus:

ζ(x)=ln(1+exp(x)):

![img](https://img-blog.csdn.net/20180928154509868?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

softplus相当于平滑版的ReLU。

再回忆一下这些激活函数的性质：

![img](https://img-blog.csdn.net/20180928154659234?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### Sigmoid族

在整流线性单元之前，主要使用Sigmoid激活函数和tanh激活函数

Sigmoid: ![g(z) = \sigma (z)](https://private.codecogs.com/gif.latex?g%28z%29%20%3D%20%5Csigma%20%28z%29)

将实数压缩到0到1，适用于输出概率

导数

tanh:g(z) = tanh(z) = 2![\sigma](https://private.codecogs.com/gif.latex?%5Csigma)(2z)-1

将实数压缩到-1到1

导数

sigmoid函数容易饱和，不适合前馈神经网络中隐藏层的激活。但是在诸如LSTM的网络中有用。

二分类问题，一般隐藏层用tanh。因为其均值为0，保持整个网络始终输入0均值的数据，较易优化。






其他都不常用了。也没有什么优势就不介绍了。

 

### 架构设计：

理论上深度学习网络可以近似实数空间中的所有函数，只要神经元足够多。

深度学习之所以优越，就是因为同等的表达能力，深层网络需要的神经元小于浅层网络且相对不容易过拟合。

深度网络不单单是一层层的依次链接，后面章节会有介绍多种变种的深度学习网络。

### 反向传播和其他的微分算法：

从x到y时前向传播，产生一个标量代价函数：![J(\theta )](https://private.codecogs.com/gif.latex?J%28%5Ctheta%20%29)

反过来从y计算梯度调整参数称为反向传播。

通过计算图来看数据流向：

![img](https://img-blog.csdn.net/2018092716373817?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

主要通过链式法则计算。

这里花书的略深奥了，看了bilibili的一篇视频很不错，链接如下：

https://www.bilibili.com/video/av16577449?from=search&seid=6361052292273718140

大概的意思如下：

反向传播是一层层传播的，比如最后一层往倒数第二层传播，而后第二层继续往第三层传播。不是像我之前一个同事理解的，先计算最后一层相对倒数第二层的偏导，然后计算最后一层相对倒数第三层的偏导，即每次都是最后一层往上传播，这个是不对的。

我们可以理解最后一层的输出为![a_{L}](https://private.codecogs.com/gif.latex?a_%7BL%7D),这个是经过神经网络后最后得到的输出。而实际的输出为y。那么这里的误差就是![^{(a-y)^{2}}](https://private.codecogs.com/gif.latex?%5E%7B%28a-y%29%5E%7B2%7D%7D),我们设他为Z。这里的Z是输出层所有输出和预期的均方差之和。即：

![Z = \sum (ai_{L}-y)^{2}](https://private.codecogs.com/gif.latex?Z%20%3D%20%5Csum%20%28ai_%7BL%7D-y%29%5E%7B2%7D)

这个![a_{L}](https://private.codecogs.com/gif.latex?a_%7BL%7D)是怎么来的呢，就是经过前面一层所有的权重相乘后相加再加上偏移获得：

![a_{L} =\sigma (w_{1}a1_{L-1} +w_{2}a2_{L-1} + w_{3}a3_{L-1} + ... + w_{n}an_{L-1} + b)](https://private.codecogs.com/gif.latex?a_%7BL%7D%20%3D%5Csigma%20%28w_%7B1%7Da1_%7BL-1%7D%20&plus;w_%7B2%7Da2_%7BL-1%7D%20&plus;%20w_%7B3%7Da3_%7BL-1%7D%20&plus;%20...%20&plus;%20w_%7Bn%7Dan_%7BL-1%7D%20&plus;%20b%29)

这里a1表示前一层和w1对应的那个权重在上一层得到的激活值。

得到前面的Z，而后即可针对w,a,以及b分别求他们的偏导，更新他们的新的值。w和b更新为新的值，a的值可以认为是上一层的预期输出，其差值正好可以作为再上一层的均方误差进行训练。

这里每一次更新不是一个样本，而是一个打乱的小批次，这就是随机梯度下降。

这就是根据自己理解的反向传播算法了。

 













# 第七章 深度学习中的正则化



正则化：减少测试误差的策略统称，可能会增加训练误差。

### 参数范数惩罚

在目标函数后面添加一项参数惩罚项![\mho (\theta )](https://private.codecogs.com/gif.latex?%5Cmho%20%28%5Ctheta%20%29)，参数越多越复杂，则惩罚越大。

根据对参数的惩罚方式不一样，分为以下几种：

### ![L^{2}](https://private.codecogs.com/gif.latex?L%5E%7B2%7D)正则化：

![\mho (\theta ) = \frac{1}{2}\left \| w \right \|_{2}^{2}](https://private.codecogs.com/gif.latex?%5Cmho%20%28%5Ctheta%20%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%5Cleft%20%5C%7C%20w%20%5Cright%20%5C%7C_%7B2%7D%5E%7B2%7D)，也被称为岭（Ridge）回归。

书上是上述公式，但是不知道右下角那个2什么意思，好像有问题呀。但实际意义就是权值向量各元素平方和再求平方根。用于防止过拟合。

主要用于权重衰减。原理即通过添加正则项，缩放权重w的分量。

### ![L^{1}](https://private.codecogs.com/gif.latex?L%5E%7B1%7D)正则：

![\mho (\theta ) = \left \| x \right \|](https://private.codecogs.com/gif.latex?%5Cmho%20%28%5Ctheta%20%29%20%3D%20%5Cleft%20%5C%7C%20x%20%5Cright%20%5C%7C),也称lasso回归，各权值向量各绝对值之和。用于特征选择产生稀疏模型。

原理不再时缩放w，而是添加一项和w同向的常数，最终使一些不重要的参数推为0。

### 作为约束的范数惩罚

显式约束和重投影技术。

类似第四章的方式，加上一个约束条件后，转换为求对等问题的方式。

书中说这种方式还不错，但是好像没见人用过呀。。

### 正则化和欠约束问题

 

### 数据集增强

增加泛化能力的一个很好的方法就是增大训练的数据量，但是数据量不足的情况下只能通过造假数据了。

数据集增强就是在原有的数据集下进行一些小变换来生成新的数据集。主要应用在图形上的一些变换吧，如旋转平移裁剪。

还有语音识别中加入少量噪声的方式。

### 噪声鲁棒性

不仅可以对输入增加噪声，还可以对权重增加噪声，让模型正则化；给输出增加噪声，含义就是不相信输出一定时真的，存在一定的错误率，从而让模型正则化更强。

### 半监督学习

就是充分利用数据吧，没有具体介绍。自己上网查阅资料补上后面。

### 多任务学习

不同的学习任务共享部分通用的参数。主要意思就是迁移学习吧感觉。

### 提前终止

early stopping。

在训练的适合同时判断随着是否验证集上效果更好，同时记录当时的训练轮数。因为随着训练的轮数增加，一般验证集的效果时一个U型的，我们期望通过earlystopping取到最优点轮数。取到最优点轮数k后，有两种训练方式：

- 将验证集加入训练集，参数恢复随机，重新训练k次
- 保留当前参数，将验证集加入后继续训练，当效果达到原有k轮时停止。

其原理类似L2正则。为什么类似L2原理太复杂，回头再看

### 参数绑定和参数共享

对参数添加对应关系的约束，如参数a等于参数b，就是参数绑定

强制某些参数一样，就是参数共享。最常见的就是cnn，显著降低参数数量，在不需要增加训练数据的情况下提高网络大小。

### 稀疏表示

相对于L1对特征值和模型参数的直接稀疏，稀疏表示惩罚神经网络中的激活单元，间接惩罚模型参数。具体方式也没看懂。。

### Bagging和其他集成方法

主要有bagging,boosting,ensemble三种

### bagging：

有放回的抽取训练样本。导致产生不同的训练样本，而后通过不同的训练样本，训练产生不同的结果，而后多个结果综合得到最终结果的方式。可以将多个弱分类器产生强分类器，如随机森林。

### boosting:

在同样的训练机上多次训练，每次可以采用不同的算法，每次运算时，样本根据上次运算的结果，赋予不同的权重，错分的赋予更高的权重，而后进行训练，最终将多个结果综合，代表性的有xgboost，gbdt

### blending:

用不相交的数据集训练，最后取平均。

### stacking:

将样本分为不相交的部分，通过一部分训练得到若干学习器，在另一部分测试所得学习器。将预测结果作为输入，真实结果作为输出，训练更高级学习器。不是很理解，找个具体的算法研究后面。

### Dropout

训练时随机让网络中的部分节点失活，防止过拟合。最终使用的时候全部正常。原理类似bagging

貌似这个方式和batch normalize不能同时使用。

**对抗训练**

在有对抗扰动的训练集样本上训练网络。

因为神经网络主要是基于线性模块构建的，多个输入的线性函数，输出容易非常迅速的改变，如每个参数增加x，则总共增加w*x之多，所以局部敏感。容易被欺骗。

感觉目前主要的应用就是生成对抗网络（GAN）,后面会专门写相关介绍，还是很厉害的网络。

### 切面距离、正切传播和流形正切分类器

流形学习中用到，参照前面那章，后面具体讲解。











# 第八章 深度模型中的优化



### 学习和纯优化有什么不同

我们期望降低的是期望泛化误差，也叫风险。但是我们平时训练时是以训练误差计算，俗称经验风险最小化。可能导致过拟合。

训练方式：

当原问题较难运算时，可以计算对等问题，使用代理损失函数。但是提前终止算法使用的是真实的损失函数一般。

当训练数据过多时，一般每次训练不使用全部样本，而是选取部分批次来训练，大大降低了训练成本，提高训练速度。

但是要注意，选取批次样本时，要先将数据打乱（shuffle），这样选取的批次才具有随机和独立性。

使用单个样本来训练的方式称为在线学习或随机学习。整个训练集的算法称为批量或确定性算法。但是小批量也可简单的称为随机算法。

基于小批量的算法，可以认为每次从同分布数据集中，取出部分数据，这样每次训练样本都不会重复，可以更好的泛化。

### 神经网络优化中的挑战

梯度范数：

局部极小值：神经网络中存在多个局部极小值点，我们很容易得到局部极小值而造成代价更大。

高原、鞍点和其他平坦区域：

鞍点，某些切面极小值的同时在某些切面极大值。

平台区域也较难找寻极值点，会不断扰动。

悬崖和梯度爆炸：突然很大的斜率。可以使用梯度截断来克服

长期依赖：无法记忆之前神经网络处理的内容，以及层数太多导致梯度消失与梯度爆炸。

非精确梯度：精确梯度难以计算的情况下求近似。

局部和全局结构间的弱对应：局部优化可能较难实现的时候，重点关注参数初始化方式。

### 基本算法

随机梯度下降：SGD 每次取补丁批量的小样本，计算梯度，然后根据梯度的均值，原有参数减去学习率乘以梯度的均值。

看到一种优化方式，初始时，批量大小逐渐增加，加快初始时训练速度。

动量相关算法（Polyak）：动量相关，原有SGD更新梯度的基础上，增加了一个动量，代表本次梯度方向的动量，让模型更稳定，更容易训练。主要解决Hessian的病态条件，和随机梯度的方差。

Nesterov动量算法：动量算法的变种，提高收敛速度，但是没有改进收敛率。计算方式只是改变了其中一部分的运算顺序。

### 参数初始化策略

均匀初始化和高斯初始化比较常用，目前没有对初始化方式的什么明确要求，主要要求就是不能为一样的值。

### 自适应学习率算法

AdaGrad：缩放每个参数反比于其所有梯度历史平方之总和的平方根。

RMSProp：带动量的自适应。

自适应这边有一种类似股票均值漂移的方式。

Adam: AdaGrad + RMSProp，这本书和其他地方看的不一样好像

余弦算法：学习率不断减小，向余弦函数一样

重启算法：余弦函数右半段的不断重复，一定程度避免进入局部极小值，当学习率为0后，重启一次，达到原有学习率最高值的一定比率。

### 二阶近似方法

牛顿法：二阶算法运算量较大，直接迭代计算梯度和二阶Hessian矩阵的逆，通常采用近似的拟牛顿法。

![\Delta \theta = -H^{-1}g](https://private.codecogs.com/gif.latex?%5CDelta%20%5Ctheta%20%3D%20-H%5E%7B-1%7Dg)

共轭矩阵：

BFGS：计算近似逆矩阵来实现。但需要存储整个逆矩阵，不适合大数据及。

L-BFGS：减小存储空间的方法。

### 优化策略和元算法

批标准化：每层的输入再做一次标准化，加快运算速度。

坐标下降：将一个最优化问题拆分，循环优化所有变量，而不是同时一次性优化全部变量。通常应用于部分变量不依赖于另一部分变量。这里举例使用的稀疏编码中权重矩阵W和线性解码激活矩阵H，交换固定一个训练另一个，那么生成对抗网络不也是这个意思吗。

Polyak平均：前面说的均值算法，通过多次梯度下降得到的参数![\hat{\theta }](https://private.codecogs.com/gif.latex?%5Chat%7B%5Ctheta%20%7D)，得到此刻的参数为之前几次得到的均值。应用于非凸问题时，使用指数衰减计算平均值：

![\hat{\theta }^{(t)} = \alpha \hat{\theta }^{(t-1)} +(1 - \alpha )\theta ^{(t)}](https://private.codecogs.com/gif.latex?%5Chat%7B%5Ctheta%20%7D%5E%7B%28t%29%7D%20%3D%20%5Calpha%20%5Chat%7B%5Ctheta%20%7D%5E%7B%28t-1%29%7D%20&plus;%281%20-%20%5Calpha%20%29%5Ctheta%20%5E%7B%28t%29%7D)

监督预训练：使用浅层网络的模型训练得到的数据作为辅助帮助复杂模型进行训练。还有就是迁移学习。

延拓法：从简单问题出发，逐渐演变为复杂问题。主要代表为课程学习方法。











#  第九章 卷积网络



### 卷积运算

内积和外积中的内积被通常认为时卷积，可交换性是因为他经过了翻转。但是神经网络中一般不应用翻转。而是直接使用互相关函数：

![S(i,j) = (I*K)(i,j) =\sum \sum I(i + m,j + n)K(m,n).](https://private.codecogs.com/gif.latex?S%28i%2Cj%29%20%3D%20%28I*K%29%28i%2Cj%29%20%3D%5Csum%20%5Csum%20I%28i%20&plus;%20m%2Cj%20&plus;%20n%29K%28m%2Cn%29.)

![img](https://img-blog.csdn.net/20181006210028175?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 动机

三大特性：稀疏交互、参数共享、等变表示。

稀疏交互：核的大小远小于输入。相对于全连接，一个输入项只影响较少神经元，大大减少运算量。

参数共享：也叫绑定权重，每个核的权重不变，遍历整个输入。使我们只需要少量参数，

等变表示：卷积网络具有平移等变的性质。

### 池化

应用于卷积层和激活层之后，调整输出。使其更容易运算并具有一定的平移不变性。并在一些需要处理不同大小的输入输出时很有用。

主要有：maxpool、averagepool、ROI池化，前两个就是取最大值和取均值，还有个取最多值的池化。特殊的是ROI池化，这里简单介绍一下：ROI：感兴趣区域

ROI池化：将不同大小的ROI池化为相同大小。步骤如下：

1. 根据输入，将ROI映射到feature map上
2. 根据输出块大小，将ROI区域划分为大小相近的块。比如输出是2*2，就划分为2*2块，每块大小相近
3. 每块进行max pooling

### 卷积与池化作为一种无限强的先验

卷积：学得函数只包含局部连接关系并具有平移不变性。

池化：每个单元都具有对少量平移的不变性。

当先验不成立时不好用了就。

### 基本卷积函数的变体

padding方式：对最边缘的数据进行填充以保持大小不变性。主要三种方式：

1. valid方式：不填充,最终输出图像m-k+1.
2. same：填0保持输入输出大小不变。
3. full：填0足够多，保持每个像素在每个方向被访问k次，最终输出图像看睹m+k-1.

平铺卷积：

。。。

### 结构化输出

意思就是能力强，可以输出各种类型吧。。举例是注意力模型。

### 数据类型

没看懂表述的意义，就是说卷积网络可以处理不同尺度的输入输出呗。。金字塔模型么比如。

### 高效的卷积算法

一个d维的核可以表示为d个向量的外积时，表示其可分离。可以使用分离后矩阵代替，大大降低参数量，提高预算速度。inception网络采用了此方式。

### 随机或无监督的特征

三种方式：

1. 简单随机化特征核
2. 人工设置，如sift特征，锐化特征等
3. 使用无监督标准学习核。

已经不流行了，相对于监督训练可以提供一些正则化，允许我们训练更大的结构。

### 卷积网络的神经科学基础

V1：初级视觉皮层。卷积网络主要覆盖其三大特性：空间映射、简单细胞、复杂细胞。

### 主流卷积神经网络介绍：

Fast-RCNN











# 10 序列建模：循环神经网络



**展开计算图**

就是将循环图展开成展开图而已。

**循环神经网络**

![img](https://img-blog.csdn.net/20181009113924331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img-blog.csdn.net/20181009114259784?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

 

就是如上网络，将某一层不断重复，输出重新作为输入的一部分。

**双向RNN**

应用于上下文环境都影响结果的场景，如语音识别，文章翻译等

**基于编码-解码的序列到序列架构**

可以将可变长度的输入转变为可变长度的输出。这里也提到了注意力模型。后面了解下自编码网络有没有用到循环神经网络的技术。自编码网络是将一个东西编码后解码再还原成原有事务。这里的编码解码不一样，是一个序列到另一个序列。

**深度循环网络**

将循环网络应用于深度学习中的部分层。

**递归神经网络**

主要用于推断学习，处理同样大小的序列，深度降低。主要问题是如何构建树。一种方式构建平衡二叉树，一种以先验知识为基础构建。

**长期依赖挑战**

循环网络涉及相同函数的多次组合，当次数过多时，导致极端非线性。比如梯度消失和梯度爆炸。

后面几节介绍采取的一些措施减少长期依赖。

**回声状态网络**

谱半径：特征值得最大绝对值。

添加了储层计算。用来存储之前学到的知识，用于后续处理。

ESN：回声状态网络

 

貌似很少遇到回声状态网络这个概念。

**渗漏单元和其他多时间尺度的策略**

时间维度的跳跃连接：构造t到t+n时刻的连接，减轻梯度消失和梯度爆炸。

渗漏单元和一系列不同时间尺度：![\mu ^{t} = \alpha \mu ^{t-1} + (1-\alpha )\upsilon ^{t}](https://private.codecogs.com/gif.latex?%5Cmu%20%5E%7Bt%7D%20%3D%20%5Calpha%20%5Cmu%20%5E%7Bt-1%7D%20&plus;%20%281-%5Calpha%20%29%5Cupsilon%20%5E%7Bt%7D)，当![\alpha](https://private.codecogs.com/gif.latex?%5Calpha)接近1时，能记住之前很长一段时间信息。![\alpha](https://private.codecogs.com/gif.latex?%5Calpha)可手动设置或者通过学习。

删除连接：主动删除长度为1的连接并用更长的连接替换。

**长短期记忆和其他门控RNN**

这里主要介绍两种最常用的LSTM和GRU，可以有效克服长期依赖。

LSTM：长短期记忆

主要包括三个模块：

忘记们：

输出门：

输入门：

GRU：门控循环单元

**优化长期依赖**

主要针对梯度爆炸和梯度消失。

当梯度爆炸时，可以使用梯度截断，有两个思路，一个是当梯度大于一定阈值时，设置当前梯度为阈值；另一个是大于阈值时，随机往一个方向走一小步，看能否跳出这段不稳定区域。

梯度消失时使用信息流正则化，加入以下正则：

![img](https://img-blog.csdn.net/20181009094902908?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

这段没理解。如何引导信息流。

**外显记忆**

就是通过使用专门的存储单元存储得到的记忆，可以保存较多的内容，而后通过寻址的方式查找记忆来进行学习。

可以基于内容寻址。寻址方式可以类似注意力机制。示意图如下：

![img](https://img-blog.csdn.net/20181007220723369?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

 

 













# 11 实践方法论

**性能度量**

根据任务需求，需要有不同的性能度量方式，常规度量方式如下：

| _      | 真                 | 假                 |
| :----- | :----------------- | :----------------- |
| 认为真 | true positive(TP)  | false positive(FP) |
| 认为假 | false negative(FN) | true negative(TN)  |

![img](https://img-blog.csdn.net/2018100918332741?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

准确率：![A = \frac{TP+TN}{TP+FP+FN+TN}](https://private.codecogs.com/gif.latex?A%20%3D%20%5Cfrac%7BTP&plus;TN%7D%7BTP&plus;FP&plus;FN&plus;TN%7D)

精确率：![P = \frac{TP}{TP+FP}](https://private.codecogs.com/gif.latex?P%20%3D%20%5Cfrac%7BTP%7D%7BTP&plus;FP%7D)

召回率：![R = \frac{TP}{TP+FN}](https://private.codecogs.com/gif.latex?R%20%3D%20%5Cfrac%7BTP%7D%7BTP&plus;FN%7D)

PR曲线：

F1分数： ![F = \frac{2pr}{p+r}](https://private.codecogs.com/gif.latex?F%20%3D%20%5Cfrac%7B2pr%7D%7Bp&plus;r%7D)

覆盖：

IoU：

![img](https://img-blog.csdn.net/20180929105826904?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![iou](https://img-blog.csdn.net/20161121150037641)

ROC：曲线是以假正率（FP_rate）和真正率（TP_rate）为轴的曲线，ROC曲线下面的面积我们叫做AUC

**默认的基准模型**

根据任务类型，选择默认的基准模型

序列一般就是LSTM和GRU，结构化一般就是卷积，其中激活函数一般是ReLU或其变种。

优化算法一般使用Adam，

初始一般不使用批标准化，如果优化出现问题再使用。

一般包含温和正则，如提前终止earlystop和dropout。dropout和batchnormalize一般不同时使用，会有冲突。

如果已有近似领域的研究，可以使用迁移学习。

项目开始时考虑是否使用无监督学习。

**觉得是否收集更多参数**

首先确定训练集上的性能是否可接受，可接受再增加模型规模调整超参数来看训练效果，如果增大模型和调优效果不佳，可能是数据质量问题，可能需要重新收集训练集。如果测试集性能比训练集差很多，那主要考虑多收集数据。考虑收集数据的代价以及需要多少数据，可通过绘制数据量和泛化曲线之间的关系来得到。

**选择超参数**

**手动设置：**

当只有实践调整一个超参数时，首选学习率。一般是u型曲线。

调整其他参数时，需同时监控训练误差和测试误差，判断是否过拟合或欠拟合。

训练集误差大于测试集：增加模型能力。

训练集误差小于测试集：添加正则化

**网格搜索：**

对数尺度中搜索，不断缩小搜索范围。效率较低

**随机搜索：**

无需离散化超参数值，且效率较高

**贝叶斯超参数优化：**

TPE:

SMAC:

**调试策略**

可视化计算值模型的行为；

可视化最严重的错误：在最容易出错的地方着手修改。通过矩阵列出出错项。

根据训练和测试误差检测：通过看两者的曲线来判断过拟合或者欠拟合。

拟合极小的数据集：先从小数据集开始搞。

比较反向传播导数和数值导数：看梯度是否正常，反向传播导数和数值导数差值如何。

监控激活函数值和梯度直方图；









# 第十二章 应用

**大规模深度学习**

首先深度学习之所以能够在现在获得大的突破，主要依靠于硬件技术的进步和大数据的发展。卷积神经网络需要的高并发，依赖于GPU的发展不断进步，甚至已经有了很多专用设备，如谷歌TPU，阿里和华为也都有最新针对AI算法的芯片。

高并发时可能导致梯度下降出问题，目前多采用异步梯度下降。

当模型过大时，通常可以通过模型压缩来减少内存和运算时间。（具体方法这里没提）

模型可以动态选择运算单元，如注意力模型。

**计算机视觉**

应用很广的一个领域，如无人驾驶中识别红绿灯等。这里主要介绍了预处理和数据集增强的一些方式：

**预处理：**

主要介绍三种方式：全局对比度归一化、局部对比度归一化和白化

**语音识别**

语音转文字的一种应用。传统方式主要通过HMM和GMM实现；深度学习发展后，可通过受限玻尔兹曼机可实现，后面章节才有详细介绍。

**自然语言处理**

机器学习很大的一个分支，为了解决词的高维和稀疏性，提出了以下方案：

- n-gram:将连续的n个单元作为一个整体。因为稀疏性，计算时需要添加平滑，或者大小n-gram相嵌（回退方法）
- word-embedding:词向量。word2vec 
- 高维输出：每个词作为一个维度输出了。计算量较大，为克服计算量大的问题，提出了以下几个方法：

1. 短列表：常见词组合组成列表
2. 分层softmax：这里说结果并不好
3. 重要采样：给权重
4. 噪声对比估计和排名损失：

- 结合n-gram和神经网络
- 神经机器翻译：使用注意力机制对其数据片段，一次性读取整个句子，然后每次根据注意力聚焦不同的部分。

**其他应用**

**推荐系统**

之前多使用协同过滤，有冷启动问题，所以有基于内容的推荐系统。后面介绍了基于强化学习的推荐系统，貌似不常用啊。

**知识表示、推理和回答**







# 第十三章 线性因子模型



线性因子模型通常用作其他混合模型的组成模块，用于描述数据生成过程。

各种线性因子模型的主要区别在先验概率不一样。概率PCA服从高斯先验。

独立成分分析不服从高斯先验。其功能类似em算法。用于分离特征。区别？

慢特征分析（SFA）源于慢性原则。

稀疏编码可以进行特征选择。

PCA就像在一个流体上按照最大横截面积切了，然后最长的方向就是主成分，正交的最长的就是次长，类推。

具体这张是什么意义就没看懂。。。







# 第十四章 自编码器

**RBM**

受限玻尔兹曼机：后面有专门章节介绍。书中这里多次提到，感觉这个书的顺序也很不合理啊，很多这种问题。。。

**欠完备自编码器**

编码输出维度小于输入的编码器称为欠完备自编码器，可以得到有效特征。

**正则自编码器**

编码输出维度大于等于输入的编码器称为过完备自编码器。可能学不到任何有用信息

稀疏自编码器：![img](https://img-blog.csdn.net/201810221704552?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

其中g(h) 是解码器输出，h是编码器输出。即h = f(x)

去噪自编码器DAE：最小化重构误差![L(x,g(\tilde{x}))](https://private.codecogs.com/gif.latex?L%28x%2Cg%28%5Ctilde%7Bx%7D%29%29)

收缩自编码器CAE：类似稀疏编码的惩罚项![\Omega (h,x) = \lambda \sum \left \| \Delta xh_{i} \right \|](https://private.codecogs.com/gif.latex?%5COmega%20%28h%2Cx%29%20%3D%20%5Clambda%20%5Csum%20%5Cleft%20%5C%7C%20%5CDelta%20xh_%7Bi%7D%20%5Cright%20%5C%7C)，x变化较小时，目标变化也不大，可反映训练数据的分布。

后面会有详细介绍。

**表示能力、层的大小和深度**

和介绍深度网络优势一样，深度的好。。训练方式是通过训练一堆浅层自编码器来贪心预训练深度架构。

**随机编码器和解码器**

包含噪声的编解码吧就是

**去噪自编码器**

通过加噪声的样本经过编解码后和原有样本比对得到损失函数。学习结果可以产生一种向量场。

**使用自编码器学习流形**

**收缩自编码**

添加正则项鼓励f的导数尽可能小。

CAE:

**预测稀疏分解**

PSD:用于无监督特征学习，后面章节会有介绍。

**自编码器的应用**

主要应用于降维、降维之后可应用于信息检索。通过降维后的数据，加上二值化，可以显著加速。同时每个维度二值化的数据可以很方便的搜索相近的项。如0100100和1100100等只有一位不一样的，可以认为是相似的。

通常在最后一层使用sigmoid进行二值化输出。需要通过添加噪声和加大输入的方式，将输出饱和，尽量输出0和1









# 第十五章 表示学习



本章的表示学习主要就是通过无监督训练学习特征的意思。

这种没有具体的算法，就是介绍表示学习的应用和大概的分支，至于如何进行表示学习，没有详细介绍。感觉可以直接跳过。。

**贪心逐层无监督预训练**

贪心算法在无监督训练中的应用，每层只关心当前，进行训练。

无监督指低层训练的网络在训练高层时不会改变。

后面就是通过实验证明无监督预训练好。。。

**迁移学习和领域自适应**

监督学习的应用场景介绍。

**半监督解释因果关系**

生成对抗网络的好处。。

**分布式表示**

通过分布式将输入空间分成多个区域。主要理解就是类似将一个物体通过多个特征表示出来。可以进行类似word2vec的计算。通过一个戴眼镜男人减去一个男人加上一个女人的照片，得到戴眼镜女人的照片。即将样本的生成方式变成分布式。

**得益于深度的指数增益**

一样，深度增加，网络的表示能力时指数及增加的。

**提供发现潜在原因的线索**

感觉就是介绍一些表示学习的先验吧，如样本通常变化平滑、流形表示、层次组织等。

感觉这章价值不大，可能我没用到吧还。。









# 第十六章 深度学习中的结构化概率模型



**非结构化建模的挑战**

主要介绍非结构化对内存要求大，速度慢。而结构化相对好很多。主要例子，a影响b ，b影响c，非结构化的处理的话，还需要处理a影响c的情况，结构化不需要。

**使用图描述模型结构**

主要分为有向图和无向图，有向图又叫信念网络或贝叶斯网络。就像前面介绍的那样可以减少很多参数，适用于因果关系。

无向图又称马尔科夫随机场（MRF）或马尔科夫网络。

这里介绍了配分函数：配置分母的函数，让所有可能性之和为1。后面会有专门的章节介绍。

能量函数：所有概率不为0，通过指数运算可得。![\tilde{p}(x) = exp(-E(x))](https://img-blog.csdnimg.cn/20181222112500673)

通常基于能量的模型也被称为玻尔兹曼机。rbm

分离和d-分离，分别存在于无向图和有向图。当两个变量集中间存在可观察变量时，并且不存在直连时，两个变量集就是分离的。

无向图和有向图可以相互转换，无向图转换为有向图时，通过一个拓扑排序，而后每个变量集针对后面所有的变量集都有一个指向其的链接。

因子图：无向图中添加一层方块区域，表达函数的作用于，解决无向图中表达的模糊性。如图

![img](https://img-blog.csdnimg.cn/20181114115514864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXRpYW5oZW5nNjU0,size_16,color_FFFFFF,t_70)

**从图模型中采样**

原始采样：按照拓扑的顺序采样。多个拓扑图时，任意一个顺序都可。但是只适用于有向图。无向图采样较复杂，使用Gibbs采样，下一章有介绍，较复杂。

**结构化建模的优势**

就是简化流程，将现有知识和知识的学习分开。

**学习依赖关系**

潜变量：无法被观察到的变量。

推断潜在变量的常用方法：

1、隐马尔可夫模型；

2、因子分析；

3、主成分分析；

4、偏最小二乘回归；

5、潜在语义分析和概率潜在语义分析；

6、EM算法。

就是学习潜变量，以及介绍潜变量的好处，高效表示。

**推断和近似推断**

具体介绍将在第十九章。就是深度学习可以应用于推断。

**结构化概率模型的深度学习方法**

深度学习的潜变量主要通过自主学习，而非人工设定。







# 参考文献

````

````

