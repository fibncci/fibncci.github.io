---
layout: post
title: "JavaScript 二进制求和 -leetcode 67"
date: 2019-10-22
tag: 日志
---



```js

JavaScript 二进制求和

解一（伪）：

转换为十进制进行计算，再将结果转换为二进制返回。会产生溢出

var addBinary = function(a, b) {
    a = parseInt(a,2);
    b = parseInt(b,2);
    return (a+b).toString(2)
};


解二：

将字符串每一位分割入数组保存，先将a和b数组长度补齐为二者最大长度+1，多出来的一位用来放置进位。计算过程就和小时候笔算十进制一样，本位相加，超出则进位。最后若首位为0则削去首位。

var addBinary = function(a, b) {
    function add(x,y) {
        if (x) return (x+y);
        else return y
    }
    a = a.split('').map(Number);
    b = b.split('').map(Number);
    var len = Math.max(a.length,b.length)+1;
    while(a.length!==len) a.unshift(0);
    while(b.length!==len) b.unshift(0);
    var c = [];
    for (var i=len-1;i>=0;i--){
        c[i] = add(c[i],a[i]+b[i]);
        if (c[i]>1) {
            c[i-1]=add(c[i-1],1);
            c[i]=c[i]-2;
        }
    }
    if (!c[0]) c.shift();
    c = c.join('');
    return c;
};


解三：
解二的速度很快，但内存消耗很大。解三在解二的基础上省略了一开始字符串和数组的转换，也利用JavaScript弱类型的特性省去了数字和字符的转换。

var addBinary = function (a, b) {
    var len = Math.max(a.length, b.length) + 1;
    while (a.length !== len) a = '0' + a;
    while (b.length !== len) b = '0' + b;
    var c = [];
    for (var i = len - 1; i >= 0; i--) {
        c[i] = c[i] ? c[i] + (a[i] - 0) + (b[i] - 0) : (a[i] - 0) + (b[i] - 0);
        if (c[i] > 1) {
            c[i - 1] = c[i - 1] ? c[i - 1] + 1 : 1;
            c[i] = c[i] - 2;
        }
    }
    if (!c[0]) c.shift();
    return c.join('');
};
```



