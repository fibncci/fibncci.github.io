#     Redis

属于非关系型数据库

> Redis 一个内存数据库，通过 Key-Value 键值对的的方式存储数据。由于 Redis 的数据都存储在内存中，所以访问速度非常快，因此 Redis 大量用于缓存系统，存储热点数据，可以极大的提高网站的响应速度。

![img](../assets/redis.png)

### 优点

> - 支持数据的持久化，通过配置可以将内存中的数据保存在磁盘中，Redis 重启以后再将数据加载到内存中；
> - 支持列表，哈希，有序集合等数据结构，极大的扩展了 Redis 用途；
> - 原子操作，Redis 的所有操作都是原子性的，这使得基于 Redis 实现分布式锁非常简单；
> - 支持发布/订阅功能，数据过期功能；

## Ubuntu 下安装

在 Ubuntu 系统安装 Redi 可以使用以下命令:

```
$sudo apt update
$sudo apt install redis-server
```

### 启动 Redis

```
$ redis-server
```

### 查看 redis 是否启动？

```
$ redis-cli
```

以上命令将打开以下终端：

```
redis 127.0.0.1:6379>
```

127.0.0.1 是本机 IP ，6379 是 redis 服务端口。现在我们输入 PING 命令。

```
redis 127.0.0.1:6379> ping
PONG
```

以上说明我们已经成功安装了redis。





# 1.1常用命令

## 基本操作

> Redis 是 Key-Value 内存数据库，操作是通过各种指令进行的，比如 `SET` 指令可以设置键值对，而 `GET` 指令则获取某一个键的值。不同的数据结构，Redis 有不同的指令，这样指令一共有几十个，下面主要介绍一些常用的指令。
>
> Redis 对 Key 也就是键有各种各样的指令，主要有下面的指令（下面的指令中小写字符串都是参数，可以自定义）：

```
>keys *  //返回键（key）

>keys list*   //返回名以list开头的所有键（key）

>exists list1  //判断键名为list1的是否存在   存在返回1， 不存在返回0

>del list1 //删除一个键（名为list1）

>expire list1 10 //设置键名为list1的过期时间为10秒后

>ttl list1 //查看键名为list1的过期时间，若为-1表示永不过期，-2表示已过期

>move age 1 //将键名age的转移到1数据库中。

>select 1 //表示进入到1数据库中，默认在0数据库

>persist age //移除age的过期时间

>flushdb:删除所有的数据 清除当前所在库的所有数据

>flushall 清空所有数据
```

## Redis 配置

Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。

你可以通过**CONFIG**命令查看或设置配置项。

```
redis 127.0.0.1:6379> CONFIG GET CONFIG_SETTING_NAME

redis 127.0.0.1:6379> CONFIG GET loglevel

1) "loglevel"
2) "notice"
```

## Redis 配置参数说明

redis.conf 配置项说明如下：

```
1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程
    daemonize no
2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定
    pidfile /var/run/redis.pid
3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，
    因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字
    port 6379
4. 绑定的主机地址
    bind 127.0.0.1
5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能
    timeout 300
6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose
    loglevel verbose
7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null
    logfile stdout
8. 设置数据库的数量，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id
    databases 16
9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合
    save <seconds> <changes>
    Redis默认配置文件中提供了三个条件：
    save 900 1
    save 300 10
    save 60 10000
    分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。

10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，
    但会导致数据库文件变的巨大
    rdbcompression yes
11. 指定本地数据库文件名，默认值为dump.rdb
    dbfilename dump.rdb
12. 指定本地数据库存放目录
    dir ./
13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步
    slaveof <masterip> <masterport>
14. 当master服务设置了密码保护时，slav服务连接master的密码
    masterauth <master-password>
15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭
    requirepass foobared
16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，
    如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，
    Redis会关闭新的连接并向客户端返回max number of clients reached错误信息
    maxclients 128
17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，
    当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。
    Redis新的vm机制，会把Key存放内存，Value会存放在swap区
    maxmemory <bytes>
18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，
    可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，
    所以有的数据会在一段时间内只存在于内存中。默认为no
    appendonly no
19. 指定更新日志文件名，默认为appendonly.aof
     appendfilename appendonly.aof
20. 指定更新日志条件，共有3个可选值： 
    no：表示等操作系统进行数据缓存同步到磁盘（快） 
    always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） 
    everysec：表示每秒同步一次（折衷，默认值）
    appendfsync everysec

21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，
    访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）
     vm-enabled no
22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享
     vm-swap-file /tmp/redis.swap
23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),
    也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0
     vm-max-memory 0
24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，
    vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；
    如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值
     vm-page-size 32
25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。
     vm-pages 134217728
26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。
    默认值为4
     vm-max-threads 4
27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启
    glueoutputbuf yes
28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法
    hash-max-zipmap-entries 64
    hash-max-zipmap-value 512
29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）
    activerehashing yes
30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件
    include /path/to/local.conf
```





# 1.2Redis的数据类型

> Redis通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。

### String（子串类型）

```
 set 命令：设置一个键和值，键存在则只覆盖，返回ok
 > set 键  值    例如： >set name zhangsan

 get 命令：获取一个键的值，返回值
 > get 键        例如：>get name

 setnx命令：设置一个不存在的键和值（防止覆盖），
 > setnx 键 值      若键已存在则返回0表示失败

 setex命令：设置一个指定有效期的键和值（单位秒）
 > setex 键 [有效时间] 值  例如: >setex color 10 red
  不写有效时间则表示永久有效，等价于set

 setrange命令：替换子字符串 (替换长度由子子串长度决定)
 > setrange 键 位置 子字串
 > setrange name 4 aa  将name键对应值的第4个位置开始替换

 mset命令：批量设置键和值,成功则返回ok
 > mset 键1 值1 键2 值2 键3 值3 ....

 msetnx命令：批量设置不存在的键和值,成功则返回ok
 > msetnx 键1 值1 键2 值2 键3 值3 ....

 getset命令：获取原值，并设置新值

 getrange命令：获取指定范围的值
 >getrange 键 0 4     //获取指定0到4位置上的值

 mget命令： 批量获取值
 >mget 键1 键2 键3....

 incr命令： 指定键的值做加加操作，返回加后的结果。
 >  键        例如： >incr kid
 incrby命令： 设置某个键加上指定值
 > incrby 键 m    //其中m可以是正整数或负整数

 decr命令： 指定键的值做减减操作，返回减后的结果。
 > decr 键        例如： >decr kid
 decrby命令： 设置某个键减上指定值
 > decrby 键 m    //其中m可以是正整数或负整数

 append命令：给指定key的字符串追加value，返回新字符串值的长度
 >append 键 追加字串

 strlen求长度 >strlen 键名   //返回对应的值。
```

### Hash类型

> Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。

```
hset命令：设置一个哈希表的键和值
>hset hash名 键  值
如：>hset user:001 name zhangsan
hget命令： 获取执行哈希名中的键对应值

hsetnx命令：设置一个哈希表中不存在的键和值
>hsetnx hash名 键  值  //成功返回1，失败返回0
如：>hsetnx user:001 name zhangsan

hmset命令:hmset user:001 username zhangsan age 20 sex 1 批量设置
hmget user:001 username age sex:批量获取值

>hexists user:001 name //是否存在， 若存在返回1

>hlen user:001  //获取某哈希user001名中键的数量

>hdel user:001 name //删除哈希user:001 中name键

>hkeys user:002   //返回哈希名为user:002中的所有键。
>hvals user:002   //返回哈希名为user:002中的所有值。
>hgetall user:002 //返回哈希名为user:002中的所有键和值。
```

### List列表（双向链表结构）

> Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）

```
list即可以作为“栈”也可以作为"队列"。
操作：
>lpush list1 "world"  //在list1头部压入一个字串
>lpush list1 "hello"  // 在list1头部压入一个字串
>lrange list1 0 -1  //获取list1中内容
    0:表示开头  -1表示结尾。

>rpush list2 "world"  //在list2尾部压入一个字串
>rpush list2 "hello"  // 在list2尾部压入一个字串
>lrange list2 0 -1  //获取list2中内容
    0:表示开头  -1表示结尾。

>linsert list2 before hello there
在key对应list的特定位置前或后添加字符串

>lset list2 1 "four"
修改指定索引位置上的值

>lrem list2 2 "hello"  //删除前两个hello值
>lrem list2 -2 "hello" //删除后两个hello值
>lrem list2 0 "hello"  //删除所有hello值

>ltrim mylist8 1 3    //删除此范围外的值

>lpop list2   //从list2的头部删除元素，并返回删除元素
>rpop list2   //从list2的尾部删除元素，并返回删除元素
>rpoplpush list1 list2    //将list1的尾部一个元素移出到list2头部。并返回

>lindex list2 1 //返回list2中索引位置上的元素
>llen list2 //返回list2上长度
```

# Redis 集合(Set)

> Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。

```
>sadd myset "hello" //向myset中添加一个元素
 成功返回1，失败(重复)返回0

>smembers myset //获取myset中的所有元素(结果是无序的)

>srem myset "one" //从myset中删除一个one
 成功返回1，失败(不存在)返回0

>spop myset //随机返回并删除myset中的一个元素
>srandmember myset //随机获取myset中的一个元素，但是不删除

> smove myset1 myset2 zhangsan:将myset1中zhangsan移动到myset2中
> scard myset1 返回myset1的个数
> sismember myset zhangsan:判断张三是否在myset中

>sdiff myset1 myset2 //返回两个集合的差集
以myset1为标准，获取myset2中不存在的。
>sdiffstore dstset myset1 myset2 ...// 返回所有集合的差集，并保存到dstset中

>sinter myset1 myset2 myset3... // 返回N个集合中的交集
>sinterstore dstset myset1 myset2 ... // 返回N个集合的交集并存储到dstset中

> sunion myset1 myset2 ...//返回所有集合的并集
> sunionstore dstset myset1 myset2// 返回所有集合的并集，并存储到dstset中
```

### Redis 有序集合Sset (sorted set)

> Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。
>
> 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
>
> 有序集合的成员是唯一的,但分数(score)却可以重复。

```
> zadd zset 70 张三向zset中添加zhangsan，分数为70
> zrem zset zhangsan:删除zset中zhangsan

> zincrby zset 60 zhangsan:如果zhangsan存在，则分数增加60，如果zhangsan不存在，那么分数就是60

> zrange zset 0 -1 withscores:根据score排序（根据score从小到大排序）
> zrevrange zset 0 -1 withscores:根据score排序（根据score从大到小排序）

> zrank zset zhangsan:返回zhangsan在zset中排名(从小到大的排序)
> zrevrank zset zhangsan:返回zhangsan在zset中排名(从大到小的排序)

> zrangebyscore zset 60 80 withscores:返回集合中score在给定区间的元素（包含60和80）
> zcount zset 60 80:返回集合中给定区间的数量
> zcard zset:返回集合中元素的个数
> zscore zset zhangsan:返回zhangsan元素的score
> zremrangebyrank zset 3 3:删除集合中排名在给定区间的元素 (从小到大)
> zremrangebyscore zset 10 20:删除 zset中 分数在 指定区间的元素
```





# 1.3Redis的高级实用特性

## Redis安全

> 我们可以通过redis的配置文件设置密码参数，这样客户端连接到redis服务就需要密码验证，这样可以让你的redis服务更安全。

查看是否设置了密码验证：

```
127.0.0.1:6379> CONFIG get requirepass
1) "requirepass"
2) ""
```

默认情况下requirepass参数是空的，这就意味着你无需通过密码验证就可以连接到redis服务。

临时修改密码（redis的服务重启后不再生效）

```
127.0.0.1:6379> CONFIG set requirepass "runoob"
OK
127.0.0.1:6379> CONFIG get requirepass
1) "requirepass"
2) "runoob"
```

**配置文件为Redis的添加密码**

```
修改配置文件
sudo vim /etc/redis/redis.conf

设置：requirepass redis的密码

# requirepass foobared

requirepass abc123

重启服务
sudo service redis restart

登录（两种）
1.# ./redis-cli -a  密码 //连接时指定密码来进行授权
2.redis-cli 进入后发现操作不了时
  auth 密码
  OK
---------------------
windows 下设置密码生效

修改配置文件

启动服务 加载配置文件redis-server redis.conf  \(加载一次即可\)

启动客户端
```

## Redis的事务

```
>multi   //开启一个事务
>set age 10 //暂存指令队列
>set age 20
>exec    //开始执行（提交事务）
或>discard //清空指令队列（事务回滚）
```

## Redis的乐观锁

```
Redis Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断
在事务前对被操作的属性做一个：
> watch age
>multi   //开启一个事务(在此期间有其他修改，则此处会失败)
>set age 10 //暂存指令队列
>set age 20
>exec    //开始执行（提交事务）
或>discard //清空指令队列（事务回滚）
```

## Redis的持久化机制（通过修改配置文件做设置）

```
1.snapshotting(快照)默认方式
   配置    save
   save 900 1 #900秒内如果超过1个key被修改，则发起快照保存
   save 300 10 #300秒内容如超过10个key被修改，则发起快照保存
   save 60 10000
2.Append-only file（aof方式）
   配置 appendonly on 改为yes
   会在bin目录下产生一个.aof的文件
   关于aof的配置
   appendonly yes //启用aof 持久化方式

   # appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化
     appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中
   # appendfsync no //完全依赖os，性能最好,持久化没保证
```

## Redis的发布订阅

> Redis发布订阅（pub / sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。
>
> Redis客户端可以订阅任意数量的频道。

下图展示了频道channel1，以及订阅这个频道的三个客户端 - client2，client5和client1之间的关系：

![pubsub1](http://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png)

当有新消息通过PUBLISH命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端：

![pubsub2](http://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png)

```
我们创建了订阅频道名为 redisChat:
redis 127.0.0.1:6379> SUBSCRIBE redisChat

Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "redisChat"
3) (integer) 1

现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。
redis 127.0.0.1:6379> PUBLISH redisChat "Redis is a great caching technique"
(integer) 1

redis 127.0.0.1:6379> PUBLISH redisChat "Learn redis by runoob.com"
(integer) 1

# 订阅者的客户端会显示如下消息
1) "message"
2) "redisChat"
3) "Redis is a great caching technique"
1) "message"
2) "redisChat"
3) "Learn redis by runoob.com"


----------------------------

序号    命令及描述
1    PSUBSCRIBE pattern [pattern ...] 订阅一个或多个符合给定模式的频道。
2    PUBSUB subcommand [argument [argument ...]] 查看订阅与发布系统状态。
3    PUBLISH channel message 将信息发送到指定的频道。
4    PUNSUBSCRIBE [pattern [pattern ...]] 退订所有给定模式的频道。
5    SUBSCRIBE channel [channel ...] 订阅给定的一个或多个频道的信息。
6    UNSUBSCRIBE [channel [channel ...]] 指退订给定的频道。
```











# 1.4 python 建行redis

### Python 访问 Redis

对于使用 Python 访问 Redis，我们需要先安装 `redis-py` 软件包，该包实现了 Python 的 Redis 驱动。通过以下命令建立工作环境，安装软件包：

```
$ sudo  pip3 install redis
```

### Python 操作 Redis

> Python 中访问 Redis 可以通过[redis-py](#)软件包进行。
>
> 类似于 PyMongo, 也是需要先创建一个 Redis 客户端，如下代码:
>
> 基本操作

```
import redis
r = redis.Redis(host='127.0.0.1', port=6379,decode_responses=True)
r.set('name', 'OK')
print(r.get('name'))
```



