---
layout: post
title: "python实战"
date: 2019-07-22
tag: ml
---







python练习

## 字典列表集合

python: hashmap -> dict -> {}

HashMap(哈希图): 你可以看看数据结构的书，由 <键，值> 对组成的，它们之间区别很小，可以看作近似相同

python: array -> list -> []
python: set -> set -> set()

```python
# dict

# color = {"red": 0.2, "green": 0.4, "blue":0.4}
# print color['red']
# print color['green']

# list
# color_list = ['red', 'blue', 'green', 'yellow']
# print color_list[2]

# set
# a_set = set()
# a_set.add('111')
# a_set.add('222')
# a_set.add('333')
# a_set.add('111')

# print(a_set)


```







```python
count=0# wu 计数
class Solution:
    def canCross(self, stones):# List[int]) -> bool:
        if stones[1] > 1:
            return False
        # 相邻石子间隔的距离
        steps = [stones[i]-stones[i-1] for i in range(1, len(stones))]
        # 如果全是1、2，直接返回true
        if max(steps) < 3:
            return True
        # 定义一个字典维护每个位置跳跃过的步长的列表
        jump = {0:[1]}
        # i为当前位置
        i = 0


        while i < len(steps):
            # 指向下一个位置
            i += 1
            if not jump.get(i-1):
                # 如果当前位置没有发生跳跃则表示是跳过的石头直接下个位置
                continue
            # 弹出当前位置步长列表，也可以直接get，每次pop出来应该能减小空间占用
            step = jump.pop(i-1)
            # 存放当前位置添加过的步长，防止重复添加
            used_step = set()
            while step:
                # 如果i到了末尾则表示成功过河
                if i == len(steps):
                    return True
                # 每次从步长列表弹出一个步长
                cur_step = step.pop()
                if cur_step in used_step:
                    continue
                # 步长加入集合防止重复
                used_step.add(cur_step)
                # 当前位置能跳哪些步长
                able_step = [cur_step-1,cur_step,cur_step+1]
                for step_ in able_step:
                    start = 0
                    for j in range(i, len(steps)):
                        # 累加跳的步长
                        start += steps[j]
                        # 有匹配的直接添加到字典里匹配位置上的步长列表里
                        if start == step_:
                            jump.setdefault(j,[]).append(step_)
                        # 一旦超出则直接退出循环进入下一个步长匹配
                        if start > step_:
                            break
        # 没有新的位置匹配则表示没能过河
        return False
a = Solution()


stones = [0,1,3,5,6,8,12,17]
stones = [0,1,3,5,6,8,12,172]

b=a.canCross(stones)
print(b)

# 一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。

# 给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。

# 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

# 请注意：

# 石子的数量 ≥ 2 且 < 1100；
# 每一个石子的位置序号都是一个非负整数，且其 < 231；
# 第一个石子的位置永远是0。
# 示例 1:

# [0,1,3,5,6,8,12,17]

# 总共有8个石子。
# 第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,
# 第三个石子在序号为3的单元格的位置， 以此定义整个数组...
# 最后一个石子处于序号为17的单元格的位置。

# 返回 true。即青蛙可以成功过河，按照如下方案跳跃： 
# 跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 
# 跳2个单位到第4块石子, 然后跳3个单位到第6块石子, 
# 跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。
# 示例 2:

# [0,1,2,3,4,8,9,11]

# 返回 false。青蛙没有办法过河。 
# 这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。


```

## print(\_\_doc\_\_)

作用:输出文件开头注释的内容

```python
print(__doc__)
Automatically created module for IPython interactive environment

"""我是你爸爸."""
print(__doc__)
#我是你爸爸.
一个注释，两个注释都是相同的；

```



  Python有个特性叫做文档字符串，即DocString，这个特性可以让你的程序文档更加清晰易懂，在python的系统文件里，也都在使用这个特性。因此推荐每个Python爱好者都使用它。
  DocString是有自己的格式的。一般是放在自己函数定义的第一行，用‘’符号指示，在这‘’里面添加函数功能说明就可以了。这个说明可以使用.doc（注意前后都是双_）属性，将DocString特性print打印出来。
  DocSting的典型用法就是help（）调用，它抓取DocString属性，清晰的给你展示出来。

**Python中print(\_\_name\_\_)**

```
def p():
　　print(__name__)
p()

1. 直接运行，输出__name__
2. 在IDLE下通过导入语句 import nameDemo，输出 nameDemo
3.if __name__ == '__main__':的意思是：只有在本程序直接运行的情况下，才会执行某些操作。



print(__name__)
__main__
```



## 调用C程序

Python底层是C, 所以调用C还是比较方便。调用C++有些麻烦。

Python提供了ctypes, 方便将Python类型转为C类型，实现传参数、函数返回类型的对应。ctypes网址:https://docs.python.org/2/library/ctypes.html

 

使用Python调用C主要有三步：

(1) 编写好C函数

(2) 把C函数打包成库文件

(3) Python加载库文件并调用

代码记录一下：

1. pycall.h

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

class PythonTest{
public:
    PythonTest():_is_inited(false), _num(0){
    
    }   

    int init(int num){
        _num = num;
        _is_inited = true;
        printf("inited ok\n");
        return 0;
    }   
    
    int str2(char *src, char* dest, int len){
        if (src == NULL || len <= 0){ 
            return 0;
        }   

        int src_len = strlen(src);
        int num = snprintf(dest, len, "%s%s", src, src);
        return (num < len -1)? num:0;
    }   

    bool is_inited(){
        printf("_num = %d\n", _num);
        return _is_inited;
    }   

private:
    bool _is_inited;
    int _num;
};
```





2. pycall_so.cpp

```c
#include "pycall.h"

extern "C" {

PythonTest py; 

int init(int num){
    return py.init(num);
}

bool is_inited(){
    return py.is_inited();
}

int str2(char* src, char* dest, int len){
    return py.str2(src, dest, len);
}

int add(int a, int b){ 
    return a + b;
}

}
```



3. pycall.py

```python
#coding=utf-8

import ctypes 
from ctypes import *

##加载库文件
ll = ctypes.cdll.LoadLibrary  
lib = ll("./libpycall.so")   

##call
fun=lib.init    ###类似C/C++函数指针
fun.restype = c_int ##设置函数返回值类型
print fun(8);
print "*" * 20

##call
fun=lib.is_inited
fun.restype = c_bool
print fun();
print "*" * 20

##call
fun=lib.str2
src = "hello world "
dest = "*" * 30     ###申请buf, 用于保存返回结果 
num = fun(src, dest, len(dest)) ###传递指针作为参数
if num != 0:
    print dest[:num]
else:
    print "buf is not ok"
print "*" * 20

##call
print lib.add(1, 2); 
print "*" * 20
```









## 技术面试题 青蛙403.py

```python
count=0# wu 计数
class Solution:
    def canCross(self, stones):# List[int]) -> bool:
        if stones[1] > 1:
            return False
        # 相邻石子间隔的距离
        steps = [stones[i]-stones[i-1] for i in range(1, len(stones))]
        # 如果全是1、2，直接返回true
        if max(steps) < 3:
            return True
        # 定义一个字典维护每个位置跳跃过的步长的列表
        jump = {0:[1]}
        # i为当前位置
        i = 0


        while i < len(steps):
            # 指向下一个位置
            i += 1
            if not jump.get(i-1):
                # 如果当前位置没有发生跳跃则表示是跳过的石头直接下个位置
                continue
            # 弹出当前位置步长列表，也可以直接get，每次pop出来应该能减小空间占用
            step = jump.pop(i-1)
            # 存放当前位置添加过的步长，防止重复添加
            used_step = set()
            while step:
                # 如果i到了末尾则表示成功过河
                if i == len(steps):
                    return True
                # 每次从步长列表弹出一个步长
                cur_step = step.pop()
                if cur_step in used_step:
                    continue
                # 步长加入集合防止重复
                used_step.add(cur_step)
                # 当前位置能跳哪些步长
                able_step = [cur_step-1,cur_step,cur_step+1]
                for step_ in able_step:
                    start = 0
                    for j in range(i, len(steps)):
                        # 累加跳的步长
                        start += steps[j]
                        # 有匹配的直接添加到字典里匹配位置上的步长列表里
                        if start == step_:
                            jump.setdefault(j,[]).append(step_)
                        # 一旦超出则直接退出循环进入下一个步长匹配
                        if start > step_:
                            break
        # 没有新的位置匹配则表示没能过河
        return False
a = Solution()


stones = [0,1,3,5,6,8,12,17]
stones = [0,1,3,5,6,8,12,172]

b=a.canCross(stones)
print(b)

# 一只青蛙想要过河。 假定河流被等分为 x 个单元格，并且在每一个单元格内都有可能放有一石子（也有可能没有）。 青蛙可以跳上石头，但是不可以跳入水中。

# 给定石子的位置列表（用单元格序号升序表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一个石子上）。 开始时， 青蛙默认已站在第一个石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格1跳至单元格2）。

# 如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

# 请注意：

# 石子的数量 ≥ 2 且 < 1100；
# 每一个石子的位置序号都是一个非负整数，且其 < 231；
# 第一个石子的位置永远是0。
# 示例 1:

# [0,1,3,5,6,8,12,17]

# 总共有8个石子。
# 第一个石子处于序号为0的单元格的位置, 第二个石子处于序号为1的单元格的位置,
# 第三个石子在序号为3的单元格的位置， 以此定义整个数组...
# 最后一个石子处于序号为17的单元格的位置。

# 返回 true。即青蛙可以成功过河，按照如下方案跳跃： 
# 跳1个单位到第2块石子, 然后跳2个单位到第3块石子, 接着 
# 跳2个单位到第4块石子, 然后跳3个单位到第6块石子, 
# 跳4个单位到第7块石子, 最后，跳5个单位到第8个石子（即最后一块石子）。
# 示例 2:

# [0,1,2,3,4,8,9,11]

# 返回 false。青蛙没有办法过河。 
# 这是因为第5和第6个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。

```



